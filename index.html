<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>zhangferry</title><meta description="只有频率相同的人，才能看见彼此内心深处不为人知的优雅。"><meta property="og:type" content="website"><meta property="og:title" content="zhangferry"><meta property="og:url" content="http://zhangferry.github.io/"><meta property="og:site_name" content="zhangferry"><meta property="og:description" content="只有频率相同的人，才能看见彼此内心深处不为人知的优雅。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://zhangferry.github.io/img/og_image.png"><meta property="article:author" content="zhangferry"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://zhangferry.github.io"},"headline":"zhangferry","image":["http://zhangferry.github.io/img/og_image.png"],"author":{"@type":"Person","name":"zhangferry"},"description":"只有频率相同的人，才能看见彼此内心深处不为人知的优雅。"}</script><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs2015.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><link rel="alternate" href="/atom.xml" title="zhangferry" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo_2.svg" alt="zhangferry" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zhangferry"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-24T00:11:27.000Z" title="2020-07-24T00:11:27.000Z">2020-07-24</time><span class="level-item">28 分钟 读完 (大约 4211 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/24/interview_summary_202006/">iOS面试总结（2020年6月）</a></h1><div class="content"><p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/headway-5QgIuuBxKwM-unsplash.jpg" alt=""></p>
<p><del>都说今年互联网行情很差，作为被大家喊了好几年“iOS开发没人要了”的iOS行情更差。那真实情况是什么样的呢，以我的经历给大家分析下</del>。应某个朋友建议，去掉这一句啊，目前iOS岗位还是挺多的，你可以这么想只要苹果爸爸不倒，iOS开发就不会没人要。但另一方面，招聘方对iOS开发的要求是在不断提高的，我们不能固步自封，满足现状，只有不断学习，不断进步，才能保持自身竞争力。</p>
<p>我的面试的阶段基本都在6月份，准备的阶段则要再往前推个半个月吧。期间约到了不少一二线互联网公司面试机会，前期由于准备不足也错失了一些机会，在之后的面试中不断总结经验，越来越有信心了，最终选择了爱奇艺。整体来看求职情况还算可以，不是很好但也不是很差，其中会带有一定运气成分，所以要换工作的话一定不要裸辞。</p>
<p>这里总结下这段时间的面试经历和一些心得，后面会附上期间遇到的面试题，大家可以尝试作答一下。</p>
<h2 id="求职准备"><a href="#求职准备" class="headerlink" title="求职准备"></a>求职准备</h2><p>如果确定了想要换工作就应该为求职做准备了。</p>
<h3 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h3><p>在确定了换工作的想法之后，我们就应该为面试做准备了。在回顾知识点的时候我建议分类去梳理：OC语法，Runtime，Runloop，多线程，性能优化等，这些是优先级高的内容，其次是网络知识，数据结构与算法等计算机通识知识。</p>
<p>有一本书非常推荐：《Objective-C高级编程》，建议精读。</p>
<p>开源库的话看<a href="https://github.com/RetVal/objc-runtime">Runtime(最新为可编译799.1版本)</a>吧，把类的定义，Runloop，weak，Autoreleasepool相关的代码都看下。</p>
<p>网络的知识点可以参考我的那篇：<a href="https://juejin.im/post/5efaa708e51d4534640e9aa0">iOS面试备战-网络篇</a>。数据结构与算法，按照类别刷个几十题应该能应付大多数情况了，iOS面试一般不会有太难的算法题。</p>
<h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历是求职的第一步，也是你能否获得面试机会的敲门砖，我们一定要好好打磨下。下面是我在脉脉上看到的HR在筛选简历时主要关注的点：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200719215109.png" alt=""></p>
<p>我在今年3月份的时候尝试投过几次简历，并没有太好的结果，后来进行了一些调整优化。6月份再投的时候相对好了些，陆续收到了些回应。本人之前并没有大厂经历，不是一流本科，但也能收到不少大厂的面试机会，所以我感觉自己的简历内容还是起到了一定的作用的。如果想参考我简历的话，可以关注公众号：「iOS成长之路」，回复：简历，进行下载。</p>
<p>上面有提到“高光时刻”，可以理解成亮点。怎么让自己的简历跟同能力水平的求职者不同，那就是找到属于我们的亮点。有一个建议，我们在写简历时，可以刻意夸大自己的能力，或者写我们想成为的样子，再之后我们就对着简历让这些内容一一实现，让它们变成自己的亮点。一定要注意不能只吹牛，不落实，因为被发现“造假”可是很严重的。</p>
<h3 id="简历投递"><a href="#简历投递" class="headerlink" title="简历投递"></a>简历投递</h3><p>以我的经历来说，相对靠谱的简历投递方式有：Boss直聘、脉脉、内推。</p>
<p>需要注意的是，Boss直聘和脉脉只有别人联系你，你再投递，反馈率才会高一些。如果是你主动联系的招聘方，那大概率是不会收到回应的。推测很多企业并没有很多的招聘岗位也会把招聘信息挂在上面，这种时候HR是不会关注投递的简历的。这也是为什么能看到很多人晒出投递上百个简历确一个回应的都没有的情况，不要气馁，这不一定代表你能力不行。</p>
<p>等招聘者联系是相对被动的，主动出击会更有效。那就是寻找内推，一般公司内推都有奖励的，所以公司内部人员都乐意去发布职位获取内推人选。脉脉，掘金，V2EX，一些知名公众号都能发现不少内推岗位，我们可以自己去挖掘。</p>
<h3 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h3><p>目前互联网公司大部分是2轮技术面+1轮HR，或三轮技术面+1轮HR。目前的面试形式多为视频面试，也有些是电话面试。视频面试的话，如果是通过Zoom，企业微信，钉钉等一般是不考察手写代码的。如果是通过牛客网，一般是会考察手写代码的。对于手写代码，仅有算法题会要求准确性，可运行，对于设计类题目，我们写出伪代码即可。</p>
<p>如果到了HR轮基本说明我们已经通过了面试，如果确定入职，接下来就是背调，薪资证明，学历证明，入职体检等一系列操作。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>以下是我面试过程中遇到的面试题，其中<a href="https://zhangferry.com/2020/06/30/interview-network/">网络</a>和<a href="https://zhangferry.com/2020/07/19/interview-multithreading/">多线程</a>问题已经分成两篇单独讲解了，这里就去除了这两部分。</p>
<h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><p>因为我最近两年多一直在用Swift，面试开始的自我介绍环节，我也会着重提这一点。但是很不幸，我得到的答案基本都是：面试主要考察OC。这也说明了大部分公司对Swift态度还是非常保守的，所以除非招聘信息里写了要求Swift技能，否则我们是没有必要专门准备Swift相关面试的。</p>
<p>当然面试过程中也遇到了几个Swift问题：</p>
<p>1、Swift中struct和class有什么区别？</p>
<p>2、Swift中的方法调用有哪些形式？</p>
<p>3、Swift和OC有什么区别？</p>
<p>4、从OC向Swift迁移的时候遇到过什么问题？</p>
<p>5、怎么理解面向协议编程？</p>
<h4 id="OC语法"><a href="#OC语法" class="headerlink" title="OC语法"></a>OC语法</h4><p>1、Block是如何实现的？Block对应的数据结构是什么样子的？__block的作用是什么？它对应的数据结构又是什么样子的？</p>
<p>2、GCD中的Block是在堆上还是栈上？</p>
<p>3、NSCoding协议是干什么用的？</p>
<p>4、KVO的实现原理</p>
<p>5、NSOperation有哪些特性比着GCD有哪些优点，它有哪些API？</p>
<p>6、NSNotificaiton是同步还是异步的，如果发通知时在子线程，接收在哪个线程？</p>
<h4 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h4><p>1、事件响应链是如何传递的？</p>
<p>2、什么是异步渲染？</p>
<p>3、layoutsubviews是在什么时机调用的？</p>
<p>4、一张图片的展示经历了哪些步骤？</p>
<p>5、什么是离屏渲染，什么情况会导致离屏渲染？</p>
<p>6、CoreAnimation这个框架的作用什么，它跟UIKit的关系是什么？</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>1、ARC方案的原理是什么？它是在什么时候做的隐式添加release操作？</p>
<p>2、循环引用有哪些场景，如何避免？</p>
<p>3、为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？</p>
<p>4、Autoreleasepool是实现机制是什么？它是什么时候释放内部的对象的？它内部的数据结构是什么样的？当我提到哨兵对象时，会继续问哨兵对象的作用是什么，为什么要设计它？</p>
<p>5、哪些对象会放入到Autoreleasepool中？</p>
<p>6、weak的实现原理是什么？当引用对象销毁是它是如何管理内部的Hash表的？（这里要参阅weak源码）</p>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>1、消息发送的流程是怎样的？</p>
<p>2、关联对象时什么情况下会导致内存泄露？</p>
<p>3、消息转发的流程是什么？</p>
<p>4、category能否添加属性，为什么？能否添加实例变量，为什么？</p>
<p>5、元类的作用是什么？</p>
<p>6、类方法是存储到什么地方的？类属性呢？</p>
<p>7、讲几个runtime的应用场景</p>
<h4 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h4><p>1、讲一下对Runloop的理解？</p>
<p>2、可以用Runloop实现什么功能？</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>1、对TableView进行性能优化有哪些方式？</p>
<p>2、Xcode的Instruments都有哪些调试的工具？</p>
<p>3、讲一下你做过的性能优化的事情。</p>
<p>4、如何检测卡顿，都有哪些方法？</p>
<p>5、缩小包体积有哪些方案？</p>
<h4 id="计算机相关"><a href="#计算机相关" class="headerlink" title="计算机相关"></a>计算机相关</h4><p>1、项目编译的流程是什么？手机上的应用程序自点击图标开始到首屏内容展示都经历了哪些步骤？</p>
<p>2、对于基本数据类型，一般是存储到栈中的，它有没有可能存在堆上，什么情况下会存储到堆上？</p>
<p>3、数据库中的事务是什么意思？</p>
<p>4、使用过什么数据库（我回答的Sqlite，Realm），Realm在使用时有哪些注意事项，如何实现批量操作？</p>
<p>5、LRU算法是否了解，如何实现一套LRU算法？</p>
<p>6、知道哪些设计模式，怎么理解设计模式的作用？</p>
<p>7、如果有1000万个Int类型的数字，如何对他们排序？</p>
<p>8、设计一套数据库方案，实现类似微信的搜索关键词能快速检索出包含该字符串的聊天信息，并展示对应数量（聊天记录的数据量较大）。</p>
<h4 id="简历相关问题"><a href="#简历相关问题" class="headerlink" title="简历相关问题"></a>简历相关问题</h4><p>1、Lottie实现动画效果的原理是什么？</p>
<p>2、OClint实现静态分析的原理是什么，它是如何做到的？</p>
<p>3、MVVM和MVC有什么区别？</p>
<p>4、静态库和动态库的区别是什么？</p>
<p>5、了解Flutter吗？它有没有使用UIKit？它是如何渲染UI的？</p>
<p>6、二进制重排的核心依据是什么？</p>
<p>7、如何设计一套切换主题的方案？</p>
<p>8、AVPlayer和IJKPlayer有什么区别？用IJKPlayer如何实现一个缓存视频列表每条视频前1s的内容？</p>
<p>9、类似微博的短视频列表，滑动停留播放，如何实现？</p>
<p>10、使用python做过哪些事？如何理解脚本语言？</p>
<h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><p>1、什么是Hash表，什么是Hash碰撞，解决Hash碰撞有什么方法？</p>
<p>2、如何遍历二叉树？</p>
<p>3、简述下快速排序的过程，时间复杂度是多少？</p>
<p>4、有一个整数数组，如何只遍历一遍就实现让该数组奇数都在前面，偶数都在后面？</p>
<p>5、假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>6、给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<a href="https://leetcode-cn.com/problems/reverse-integer/">leetcode 7</a></p>
<p>7、有红、黄、蓝三种颜色的气球。在牛客王国，1个红气球+1个黄气球+1个蓝气球可以兑换一张彩票。</p>
<p>2个红气球+1个黄气球可以兑换1个蓝气球。</p>
<p>2个黄气球+1个蓝气球可以兑换1个红气球。</p>
<p>2个蓝气球+1个红气球可以兑换1个黄气球。</p>
<p>现在牛牛有a个红气球，b个黄气球， c个蓝气球，牛牛想知道自己最多可以兑换多少张彩票。</p>
<h4 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h4><p>1、做过哪些工作职责之外的事情？</p>
<p>2、经历过最难的一次业务开发是什么样的，最终怎么解决的？</p>
<p>3、最近有学习什么新技术吗？有何收获？</p>
<p>4、你最擅长iOS哪方面的知识？怎么体现出来的？</p>
<p>5、常用哪些开源库，有没有研究过他们的原理？</p>
<p>6、如何保持个人成长？</p>
<h4 id="流程型问题"><a href="#流程型问题" class="headerlink" title="流程型问题"></a>流程型问题</h4><p>流程性问题基本都会包含下面四个，最好提前准备好</p>
<p>1、请做下自我介绍。</p>
<p>2、你有什么问题要问我的吗？</p>
<p>3、为什么离职？</p>
<p>4、对下份工作的期望是什么样的？</p>
<p>这些问题看似不起眼，但其实还挺重要的，很有可能面试官就是通过这几个问题决定了要不要你通过面试。</p>
<p>自我介绍就不说了，简明扼要介绍自己近几年的经历和成绩就行，控制在一分钟以内。</p>
<p>第二个，最好不要直接说没有问题了，提问面试官是我们整个面试过程中少有的掌握主动权的时刻，它可以体现我们自主思考的能力。最好提前了解下公司和招聘需求，准备几个问题，或者面试过程中提出我们产生的一些疑问。</p>
<p>离职原因，这个如实回答即可，只要不说是因为钱或者跟领导同事不和基本都没有问题。</p>
<p>下份工作的期望，这个就看各自的需求吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这些面试题，我们可以看出一些端倪。</p>
<p>1、面试官更喜欢“刨根问底”，对着一个概念不断的往深处延展，不断深入的问。这类问题会有很大的区分度，第一问第二问第三问难度逐次提高，用于筛选不同的面试者。这也提醒我们某些知识点不光要知道原理，还要知道为什么这么设计，这么设计的好处是什么。</p>
<p>2、问题范围更全面化，特别是二面时，问题不再局限于iOS端，而是更通用的计算机方向问题，这个需要我们平常多积累；还有就是开始重视个人软技能，学习能力和上进心。</p>
<p>3、围绕简历，还记得上面说过写简历时要吹牛逼吗。在面试的时候一定要把他们成为自己真正掌握的知识。</p>
<p>4、注重软技能，这个比前面几条作用稍微小些，但是如果被问到了，而我们也有很好的贴合点，那绝对就是加分项。我的一次经历是，当我向面试官说自己有写博客的习惯，他问我是否知道medium，我说知道，还翻译过几篇里面的文章，接着说了些我理解的国内外博客平台的现状分析。这种情况就属于加分项了。</p>
<p>另外面试是一次考察自己知识掌握程度的考核，考的好能提升自己自信心，考的不好可以帮助我们定位自身问题，不管怎么说都是不亏的。面试还可以帮助我们了解市场行情，薪资待遇，自身竞争力，流行技术栈等一系列情况。所以真的建议即使不考虑换工作，每年固定时间也可以出去面试几次。</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200719185749.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-19T09:32:57.000Z" title="2020-07-19T09:32:57.000Z">2020-07-19</time><span class="level-item">26 分钟 读完 (大约 3897 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/19/interview-multithreading/">iOS面试篇-多线程</a></h1><div class="content"><p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200719183858.png" alt=""></p>
<p>iOS面试中多线程绝对是最重要的知识点之一，它在日常开发中会被广泛使用，而且多线程是有很多区分度很高的题目可供考察的。这篇文章会梳理下多线程和GCD相关的概念和几个典型问题。因为GCD相关的API用OC看着更直管一些，所以这期实例就都用OC语言书写。</p>
<h2 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h2><p>在面对一些我们常见的概念时，我们常有种这个东西我熟的感觉，但是如果没有深入研究它们的概念和区别，还是很容易弄混或者讲不清楚的。所以这里单独抽一节讲下多线程中的概念。</p>
<h3 id="进程，线程，任务，队列"><a href="#进程，线程，任务，队列" class="headerlink" title="进程，线程，任务，队列"></a>进程，线程，任务，队列</h3><p>进程：资源分配的最小单位。在iOS中一个应用的启动就是开启了一个进程。</p>
<p>线程：CPU调度的最小单位。一个进程里会有多个线程。</p>
<p>大家可以思考下，进程和线程为什么是从资源分配和CPU调度层面进行定义的。</p>
<p>任务：每次执行的一段代码，比如下载一张图片，触发一个网络请求。</p>
<p>队列：队列是用来组织任务的，一个队列包含多个任务。</p>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD（Grand Central Dispatch）是异步执行任务的技术之一。开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程执行该任务。这里的线程管理是由系统处理的，我们不必关心线程的创建销毁，这大大方便了我们的开发效率。也可以说GCD是一种简化线程操作的多线程使用技术方案。</p>
<p>安卓没有跟GCD完全相同的一套技术方案的，虽然它可以处理GCD实现的一系列效果。</p>
<h3 id="串行，并行，并发"><a href="#串行，并行，并发" class="headerlink" title="串行，并行，并发"></a>串行，并行，并发</h3><p>GCD的使用都是通过调度队列（Dispatch Queue）的形式进行的，调度队列有以下 几种形式：</p>
<p><strong>串行（serial）</strong>：多任务中某时刻只能有一个任务被运行；</p>
<p><strong>并行（parallel）</strong>：相对于串行，某时刻有多个任务同时被执行，需要多核能力；</p>
<p><strong>并发（concurrent）</strong>：引入时间片和抢占之后才有了并发的说法，某个时间片只有一个任务在执行，执行完时间片后进行资源抢占，到下一个任务去执行，即“微观串行，宏观并发”，所以这种情况下只有一个空闲的某核，多核空闲就又可以实现并行运行了；</p>
<p>我们常用的调度队列有以下几种：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.gcd.serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.gcd.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// 全局并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 主队列</span></span><br><span class="line">let mainQueue = DispatchQueue.main</span><br></pre></td></tr></table></figure>

<p>注意GCD创建的是并发队列而不是并行队列。但这里的并发队列是一个相对宽泛的定义，它包含并行的概念，GCD作为一个智能的中心调度系统会根据系统情况判断当前能否使用多核能力分摊多个任务，如果满足的话此时就是在并行的执行队列中的任务。</p>
<h3 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h3><p> <strong>同步</strong>：函数会阻塞当前线程直到任务完成返回才能进行其它操作；</p>
<p> <strong>异步</strong>：在任务执行完成之前先将函数值返回，不会阻塞当前线程；</p>
<h3 id="串行、并发和同步、异步相互结合能否开启新线程"><a href="#串行、并发和同步、异步相互结合能否开启新线程" class="headerlink" title="串行、并发和同步、异步相互结合能否开启新线程"></a>串行、并发和同步、异步相互结合能否开启新线程</h3><table>
<thead>
<tr>
<th></th>
<th>串行队列</th>
<th>并发队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody><tr>
<td>同步</td>
<td>不开启新线程</td>
<td>不开启新线程</td>
<td>不开启新线程</td>
</tr>
<tr>
<td>异步</td>
<td>开启新线程</td>
<td>开启新线程</td>
<td>不开启新线程</td>
</tr>
</tbody></table>
<h3 id="主线程和主队列"><a href="#主线程和主队列" class="headerlink" title="主线程和主队列"></a>主线程和主队列</h3><p>主线程是一个线程，主队列是指主线程上的任务组织形式。</p>
<p>主队列只会在主线程执行，但主线程上执行的不一定就是主队列，还有可能是别的同步队列。因为前说过，同步操作不会开辟新的线程，所以当你自定义一个同步的串行或者并行队列时都是还在主线程执行。</p>
<p>判断当前是否是主线程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isMainThread = [<span class="built_in">NSThread</span> isMainThread];</span><br></pre></td></tr></table></figure>

<p>判断当前是否在主队列上：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *mainQueueKey = <span class="string">"mainQueueKey"</span>;</span><br><span class="line">dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, &amp;mainQueueKey, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">BOOL</span> isMainQueue = dispatch_get_specific(mainQueueKey));</span><br></pre></td></tr></table></figure>

<p><strong>队列与线程的关系</strong></p>
<p>队列是对任务的描述，它可以包含多个任务，这是应用层的一种描述。线程是系统级的调度单位，它是更底层的描述。一个队列（并行队列）的多个任务可能会被分配到多个线程执行。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><strong>1、分析下面代码的执行逻辑</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    [<span class="keyword">self</span> syncMainTask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)syncMainTask &#123;</span><br><span class="line">    dispatch_queue_main_t mainQueue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(mainQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"main queue task"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会输出<code>task1</code>，然后发生死锁，导致crash。</p>
<p><strong>追加问题一：为什么会死锁？死锁就会导致crash？</strong></p>
<p>我们先分析crash的情况，正常死锁应该就是卡死的情况，不应该导致carsh。那为什么会carsh呢，看崩溃信息：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200706154838.png" alt=""></p>
<p>是一个<code>EXC_BAD_INSTRUCTION</code>类型的crash，执行了一个出错的命令。</p>
<p>然后看<code>__DISPATCH_WAIT_FOR_QUEUE__</code>的调用栈信息：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200706155152.png" alt=""></p>
<p>右侧汇编代码给出了更详细的crash信息：<code>BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread</code>。</p>
<p>在当前线程已经拥有的队列中执行<code>dispatch_sync</code>同步操作会导致crash。</p>
<p>在<code>libdispatch</code>的源码中我们可以找到该函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__DISPATCH_WAIT_FOR_QUEUE__(<span class="keyword">dispatch_sync_context_t</span> dsc, <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = _dispatch_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们知道了，这个carsh是<code>libdispatch</code>内部抛出的，当它检测到可能发生死锁时，就直接触发崩溃，事实上它不能完全判断出所有死锁的情况。</p>
<p>我们分析这里为什么会发生死锁。首先<code>syncMainTask</code>就是在主队列中的，我们在主队列先添加<code>dispatch_sync</code>然后再添加其内部的block。主队列FIFO，只有sync执行完了才会执行内部的block，而此时是一个同步队列，block执行完才会退出sync，所以导致了死锁。</p>
<p>对于死锁的解释我也查了好几篇文章，有些说法其实是经不起推敲的，这个解释是我认为相对合理的。</p>
<p>附一篇参考文章：<a href="https://juejin.im/post/5b4d945ef265da0f9c6797f0">GCD死锁</a></p>
<p><strong>引出问题二：什么情况下会发生死锁？</strong></p>
<p>GCD中发生死锁需要满足两个条件：</p>
<ul>
<li>同步执行串行队列</li>
<li>执行sync的队列和block所在队列为同一个队列</li>
</ul>
<p><strong>引出问题三：如何避免死锁？这段代码应该如何修改？</strong></p>
<p>根据上面提到的条件，我们可以将任务异步执行，或者换成一个并发队列。另外将block放到一个非主队列里执行也是可以的。</p>
<p><strong>2、分析一下代码执行结果</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"a = %d"</span>, a);</span><br></pre></td></tr></table></figure>

<p>首先该段代码会编译不过，编译器检测到变量<code>a</code>被block截获，并尝试修改就报以下错误：</p>
<p><code>Variable is not assignable (missing __block type specifier)</code>。如果我们要在block里对外界变量重新复制，需要添加<code>__block</code>的声明：<code>__block int a = 0;</code></p>
<p>我们分析这段代码，在开始while之后加入一个异步任务，再之后呢，这个是不确定了，可能是执行<code>a++</code>也可能是因不满足退出条件再次执行加入异步任务，直到满足<code>a&lt;2</code>才会退出while循环。那输出结果也就是不确定了，因为可能在判断跳出循环和输出结果的时候另外的线程又执行了一次<code>a++</code>。</p>
<p>再扩展下，如果将那个并发队列改成主队列，执行逻辑还是一样的吗？</p>
<p>首先主队列是不会开启新线程的，主队列上的异步操作执行时机是等别的任务都执行完了，再来执行添加的<code>a++</code>。显然在while循环里，主队列既有任务还未执行完毕，所以就不会执行<code>a++</code>，也就导致while循环不会退出，形成死循环。</p>
<h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><h3 id="什么是线程安全，为什么UI操作必须在主线程执行"><a href="#什么是线程安全，为什么UI操作必须在主线程执行" class="headerlink" title="什么是线程安全，为什么UI操作必须在主线程执行"></a>什么是线程安全，为什么UI操作必须在主线程执行</h3><p>线程安全：当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。</p>
<p>为什么UI操作必须放到主线程：首先UIKit不是线程安全的，多线程访问会导致UI效果不可预期，所以我们不能使用多个线程去处理UI。那既然要单线程处理UI为什么是在主线程呢，这是因为UIApplication作为程序的起点是在主线程初始化的，所以我们后续的UI操作也都要放到主线程处理。</p>
<p>关于这个问题展开讨论可以参阅这篇文章：<a href="https://juejin.im/post/5c406d97e51d4552475fe178">iOS拾遗——为什么必须在主线程操作UI</a></p>
<p>###开启新的线程有哪些方法 </p>
<p>1、NSThread</p>
<p>2、NSOperationQueue</p>
<p>3、GCD</p>
<p>4、NSObject的<code>performSelectorInBackground</code>方法</p>
<p>5、pthread</p>
<h3 id="多线程任务要实现顺序执行有哪些方法"><a href="#多线程任务要实现顺序执行有哪些方法" class="headerlink" title="多线程任务要实现顺序执行有哪些方法"></a>多线程任务要实现顺序执行有哪些方法</h3><p>1、dispatch_group</p>
<p>2、dispatch_barrier</p>
<p>3、dispatch_semaphore_t</p>
<p>4、NSOperation的addDependency方法</p>
<h3 id="如何实现一个多读单写的功能？"><a href="#如何实现一个多读单写的功能？" class="headerlink" title="如何实现一个多读单写的功能？"></a>如何实现一个多读单写的功能？</h3><p>多读单写的意思就是可以有多个线程同时参与读取数据，但是写数据时不能有读操作的参与切只有一个线程在写数据。</p>
<p>我们写一个示例程序，看下在不做限制的多读多写程序中会发生什么。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">self</span>.count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 并发队列</span></span><br><span class="line"><span class="keyword">self</span>.concurrentQueue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> read];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> write];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读写操作</span></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"read---- %d"</span>, <span class="keyword">self</span>.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">    <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"write---- %d"</span>, <span class="keyword">self</span>.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出内容</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.612175</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709312</span>] read---- <span class="number">0</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.612273</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709311</span>] read---- <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.612230</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709314</span>] write---- <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.612866</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709312</span>] write---- <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.612986</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709311</span>] write---- <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.612919</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709314</span>] read---- <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.613252</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709312</span>] read---- <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.613346</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709314</span>] write---- <span class="number">4</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03.613423</span>+<span class="number">0800</span> GCD_OC[<span class="number">76121</span>:<span class="number">1709311</span>] read---- <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>每次运行的输出结果都会不一样，根据这个输出内容，我们可以看到在还没有执行到输出write—-1的时候，就已经执行了read—-1，在write—- 3之后 read的结果却是2。这绝对是我们所不期望的。其实在程序设计中我们是不应该设计出多读多写这种行为，因为这个结果是不可控。</p>
<p>解决方案之一是对读写操作都加上锁做成单独单写，这样是没问题但有些浪费性能，正常写操作确定之后结果就确定了，读的操作可以多线程同时进行，而不需要等别的线程读完它才能读，所以有了多读单写的需求。</p>
<p>解决多读单写常见有两种方案，第一种是使用读写锁<code>pthread_rwlock_t</code>。</p>
<p>读写锁具有一些几个特性：</p>
<ul>
<li>同一时间，只能有一个线程进行写的操作</li>
<li>同一时间，允许有多个线程进行读的操作。</li>
<li>同一时间，不允许既有写的操作，又有读的操作。</li>
</ul>
<p>这跟我们的多读单写需求完美吻合，也可以说读写锁的设计就是为了实现这一需求的。它的实现方式如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行读写操作之前需要定义一个读写锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;_lock,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 读写操作</span></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"read---- %d"</span>, <span class="keyword">self</span>.count);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    _count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"write---- %d"</span>, <span class="keyword">self</span>.count);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出内容</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.363875</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722472</span>] read---- <span class="number">0</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.363875</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722471</span>] read---- <span class="number">0</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.364195</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722469</span>] write---- <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.364325</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722472</span>] write---- <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.364450</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722470</span>] read---- <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.364597</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722471</span>] write---- <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.366490</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722469</span>] read---- <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.366703</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722472</span>] write---- <span class="number">4</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29.366892</span>+<span class="number">0800</span> GCD_OC[<span class="number">77172</span>:<span class="number">1722489</span>] read---- <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>我们查看输出日志，所以的读操作结果都是最近一次写操作所赋的值，这是符合我们预期的。</p>
<p>还有一种实现多读单写的方案是使用GCD中的栅栏函数<code>dispatch_barrier</code>。栅栏函数的目的就是保证在同一队列中它之前的操作全部执行完毕再执行后面的操作。为了保证写操作的互斥行，我们要对写操作执行「栅栏」：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们定义一个用于读写的并发对列</span></span><br><span class="line"><span class="keyword">self</span>.rwQueue = dispatch_queue_create(<span class="string">"com.rw.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.rwQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read---- %d"</span>, <span class="keyword">self</span>.count);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.rwQueue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write---- %d"</span>, <span class="keyword">self</span>.count);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个输出结果跟读写锁实现是一样的，也是符合预期的。</p>
<p>这里多说几句，这里的读和写分别使用<code>sync</code>和<code>async</code>。读操作要用同步是为了阻塞线程尽快返回结果，不用担心无法实现多读，因为我们使用了并发队列，是可以实现多读的。至于写操作使用异步的栅栏函数，是为了写时不阻塞线程，通过栅栏函数实现单写。如果我们将读写都改成sync或者async，由于栅栏函数的机制是会顺序先读后写。如果反过来，读操作异步，写操作同步也是可以达到多读单写的目的的，但读的时候不立即返回结果，网上有人说只能使用异步方式，防止发生死锁，这个说法其实不对，因为同步队列是不会发生死锁的。</p>
<h3 id="用GCD如何实现一个控制最大并发数且执行任务FIFO的功能？"><a href="#用GCD如何实现一个控制最大并发数且执行任务FIFO的功能？" class="headerlink" title="用GCD如何实现一个控制最大并发数且执行任务FIFO的功能？"></a>用GCD如何实现一个控制最大并发数且执行任务FIFO的功能？</h3><p>这个相对简单，通过信号量实现并发数的控制，通过并发队列实现任务的FIFO的执行</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxConcurrent = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(maxConcurrent);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="comment">// task</span></span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200719185749.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-30T03:28:09.000Z" title="2020-06-30T03:28:09.000Z">2020-06-30</time><span class="level-item">39 分钟 读完 (大约 5819 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/30/interview-network/">iOS面试篇</a></h1><div class="content"><p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200630104145.png" alt=""></p>
<p>计算机网络是计算机科学与技术专业的必修课，也是移动端，前端，后端都会涉及到的知识点，同时它也是iOS面试中大概率会出现的问题。所以准备面试的话，网络相关的知识点一定不能错过。这里总结了一些我认为有用的和最近面试遇到的网络相关知识点。</p>
<p>去年写过一篇<a href="https://zhangferry.com/2019/08/31/diagram_tcpip_concepts/">《图解TCP/IP》总结</a>的文章，也可以对着看下。</p>
<h3 id="计算机网络是如何分层的"><a href="#计算机网络是如何分层的" class="headerlink" title="计算机网络是如何分层的"></a>计算机网络是如何分层的</h3><p>网络有两种分层模型，一种是ISO（国际标准化组织）制定的OSI（Open System Interconnect）模型，它将网络分为七层。一种是TCP/IP的四层网络模型。OSI是一种学术上的国际标准，理想概念，TCP/IP是事实上的国际标准，被广泛应用于现实生活中。两者的关系可以看这个图：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629174612.png" alt=""></p>
<p>注：也有说五层模型的，它跟四层模型的区别就是，在OSI模型中的数据链路层和物理层，前者将其作为两层，后者将其合并为一层称为网络接口层。一般作为面试题的话都是需要讲出OSI七层模型的。</p>
<p>各个层的含义以及它们之间的关系可以看这张图：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629174637.png" alt=""></p>
<h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><h4 id="http协议特性"><a href="#http协议特性" class="headerlink" title="http协议特性"></a>http协议特性</h4><ul>
<li>HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无状态：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。</li>
</ul>
<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><ul>
<li><p>GET：请求获取Request-URI标识的资源，请求参数附加在url上，明文展示。</p>
</li>
<li><p>POST：在Request-URI所标识的资源后附加新的数据，常用于修改服务器资源或者提交资源到服务器。POST请求体是放到body中的，可以指定编码方式，更加安全。</p>
</li>
<li><p>HEAD：请求获取由Request-URI所标识的资源的响应消息报头。</p>
</li>
<li><p>PUT：请求服务器存储一个资源，并用Request-URI作为其标识。</p>
</li>
<li><p>DELETE：请求服务器删除Request-URI所标识的资源。</p>
</li>
<li><p>TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断。</p>
</li>
<li><p>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求。</p>
</li>
</ul>
<h4 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h4><p>以该链接为例：<a href="https://zhangferry.com/2019/08/31/diagram_tcpip_concepts/">https://zhangferry.com/2019/08/31/diagram_tcpip_concepts/</a></p>
<p>在Chrome查看其请求的Headers信息。</p>
<p><strong>General</strong></p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200630103717.png" alt=""></p>
<p>这里标记了请求的URL，请求方法为GET。状态码为304，代表文件未修改，可以直接使用缓存的文件。远程地址为185.199.111.153:443，此IP为Github 服务器地址，是因为我的博客是部署在GitHub上的。</p>
<p>除了304还有别的状态码，分别是：</p>
<ul>
<li><code>200 OK</code> 客户端请求成功</li>
<li><code>301 Moved Permanently</code> 请求永久重定向</li>
<li><code>302 Moved Temporarily</code> 请求临时重定向</li>
<li><code>304 Not Modified</code> 文件未修改，可以直接使用缓存的文件。</li>
<li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li>
<li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li>
<li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>
<li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li>
</ul>
<p><strong>Response Headers</strong>：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629174317.png" alt=""></p>
<p>content-encoding：用于指定压缩算法</p>
<p>content-length：资源的大小，以十进制字节数表示。</p>
<p>content-type：指示资源的媒体类型。图中所示内容类型为html的文本类型，文字编码方式为utf-8</p>
<p>last-modified：上次内容修改的日期，为6月8号</p>
<p>status：304 文件未修改状态码</p>
<p>注：其中content-type在响应头中代表，需要解析的格式。在请求头中代表上传到服务器的内容格式。</p>
<p><strong>Request Headers</strong>：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629174421.png" alt=""></p>
<p>:method：GET请求</p>
<p>:path：url路径</p>
<p>:scheme：https请求</p>
<p>accept：通知服务器可以返回的数据类型。</p>
<p>accept-encoding：编码算法，通常是压缩算法，可用于发送回的资源</p>
<p>accept-language：通知服务器预期发送回的语言类型。这是一个提示，并不一定由用户完全控制:服务器应该始终注意不要覆盖用户的显式选择(比如从下拉列表中选择语言)。</p>
<p>cookie：浏览器cookie</p>
<p>user-agent：用户代理，标记系统和浏览器内核</p>
<p>更多请求头的字段含义可以参考这里：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">HTTP headers</a></p>
<h3 id="TCP三次握手和四次挥手的过程以及为什么要有三次和四次"><a href="#TCP三次握手和四次挥手的过程以及为什么要有三次和四次" class="headerlink" title="TCP三次握手和四次挥手的过程以及为什么要有三次和四次"></a>TCP三次握手和四次挥手的过程以及为什么要有三次和四次</h3><p>在了解TCP握手之前我们先看下TCP的报文样式：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629175217.png" alt=""></p>
<p>其中控制位（Control Flag）标记着握手阶段的各个状态。</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629175356.png" alt=""></p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>示意图如下：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200630103422.png" alt=""></p>
<p>三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送3个数据包。</p>
<p>1、第一次握手（SYN=1, seq=x）</p>
<p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p>
<p>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</p>
<p>2、第二次握手（SYN=1, ACK=1, seq=y, ACKnum=x+1）</p>
<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</p>
<p>3、第三次握手（ACK=1, ACKnum=y+1）</p>
<p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p>
<p>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</p>
<p><strong>问题一：为什么需要三次握手呢？</strong></p>
<p>在谢希仁著的《计算机网络》里说，『为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误』。怎么理解呢，我们假设一种情况，有一个建立连接的第一次握手的报文段因为滞留到网络中过了较长时间才发送到服务端。这时服务器是要做ACK应答的，如果只有两次握手就代表连接建立，那服务器此时就要等待客户端发送建立连接之后的数据。而这只是一个因滞留而废弃的请求，是不是白白浪费了很多服务器资源。</p>
<p>从另一个角度看这个问题，TCP是全双工的通信模式，需要保证两端都已经建立可靠有效的连接。在三次握手过程中，我们可以确认的状态是：</p>
<p>第一次握手：服务器确认自己接收OK，服务端确认客户端发送OK。</p>
<p>第二次握手：客户端确认自己发送OK，客户端确认自己接收OK，客户端确认服务器发送OK，客户端确认服务器接收OK。</p>
<p>第三次握手：服务器确认自己发送OK，服务器确认客户端接收OK。</p>
<p>只有握手三次才能达到全双工的目的：确认自己和对方都能够接收和发送消息。</p>
<h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>示意图如下：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200630103444.png" alt=""></p>
<p>四次挥手表示要发送四个包，挥手的目的是断开连接。</p>
<p>1、第一次挥手（FIN=1, seq=x）</p>
<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>
<p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p>
<p>2、第二次挥手（ACK=1，ACKnum=x+1）</p>
<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>
<p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p>
<p>3、第三次挥手（FIN=1，seq=y）</p>
<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p>
<p>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</p>
<p>4、第四次挥手（ACK=1，ACKnum=y+1）</p>
<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p>
<p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p>
<p><strong>问题一：为什么挥手需要四次呢？为什么不能将ACK和FIN报文一起发送？</strong></p>
<p>当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端『你发的FIN我收到了』。只有等到服务端所有的报文都发送完了，才能发FIN报文，所以要将ACK和FIN分开发送，这就导致需要四次挥手。</p>
<p><strong>问题二：为什么TIMED_WAIT之后要等2MSL才进入CLOSED状态？</strong></p>
<p>MSL是TCP报文的最大生命周期，因为TIME_WAIT持续在2MSL就可以保证在两个传输方向上的尚未接收到或者迟到的报文段已经消失，同时也是在理论上保证最后一个报文可靠到达。假设最后一个ACK丢失，那么服务器会再重发一个FIN，这是虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK。</p>
<p>###HTTPS的流程</p>
<p>HTTPS = HTTP + TLS/SSL，它的建立可以用以下示意图表示：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629162110.png" alt=""></p>
<p>1、客户端首次请求服务器，告诉服务器自己支持的协议版本，支持的加密算法及压缩算法，并生成一个随机数（client random）告知服务器。</p>
<p>2、服务器确认双方使用的加密方法，并返回给客户端证书以及一个服务器生成的随机数（server random）</p>
<p>3、客户端收到证书后，首先验证证书的有效性，然后生成一个新的随机数（premaster secret），并使用数字证书中的公钥，加密这个随机数，发送给服务器。</p>
<p>4、服务器接收到加密后的随机数后，使用私钥进行解密，获取这个随机数（premaster secret</p>
<p>5、服务器和客户端根据约定的加密方法，使用前面的三个随机数（client random, server random, premaster secret），生成『对话密钥』（session key），用来加密接下来的整个对话过程（对称加密）。</p>
<p>有一篇由浅入深介绍HTTPS的文章可以阅读一下：<a href="https://juejin.im/post/5b0274ac6fb9a07aaa118f49">看图学HTTPS</a></p>
<p><strong>问题一：为什么握手过程需要三个随机数，而且安全性只取决于第三个随机数？</strong></p>
<p>前两个随机数是明文传输，存在被拦截的风险，第三个随机数是通过证书公钥加密的，只有它是经过加密的，所以它保证了整个流程的安全性。前两个随机数的目的是为了保证最终对话密钥的『更加随机性』。</p>
<p><strong>问题二：Charles如何实现HTTPS的拦截？</strong></p>
<p>Charles要实现对https的拦截，需要在客户端安装Charles的证书并信任它，然后Charles扮演中间人，在客户端面前充当服务器，在服务器面前充当客户端。</p>
<p><strong>问题三：为什么有些HTTPS请求（例如微信）抓包结果仍是加密的，如何实现的？</strong></p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200630100226.png" alt=""></p>
<p>我在聊天过程中并没有抓到会话的请求，在小程序启动的时候到是抓到了一个加密内容。我手动触发该链接会下载一个加密文件，我猜测这种加密是内容层面的加密，它的解密是由客户端完成的，而不是在HTTPS建立过程完成的。</p>
<p>另外在研究这个问题的过程中，又发现了一些有趣的问题：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200630101209.png" alt=""></p>
<p>1、图中所示的三个https请求分别对应三个不同类型的图标，它们分别代表什么意思呢？</p>
<p>感谢<a href="https://juejin.im/user/5efae3665188252e6f1515e0">iOS憨憨</a>的回答。 第一个图标含义是HTTP/2.0，第二个图标含义是HTTP/1.1，第三个图标加锁是因为我用charles只抓取了443端口的请求，该请求端口为5228，所以不可访问。</p>
<p>2、第三个请求<code>https://mtalk.google.com:5228</code>图标和请求内容都加了锁，这个加锁是在https之上又加了一层锁吗？</p>
<p>这些问题暂时没有确切的答案，希望了解的小伙伴告知一下哈。</p>
<h3 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h3><p>DNS（Domain name system）域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户通过域名访问到对应的服务器（IP地址）。具体的解析流程是这样的：</p>
<p>1、浏览器中输入想要访问的网站域名，操作系统会检查本地hosts文件是否有这个网址的映射关系，如果有就调用这个IP地址映射，完成域名解析。没有的话就走第二步。</p>
<p>2、客户端回向本地DNS服务器发起查询，如果本地DNS服务器收到请求，并可以在本地配置区域资源中查到该域名，就将对应结果返回为给客户端。如果没有就走第三步。</p>
<p>3、根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629170959.png" alt=""></p>
<p>其中递归查询和迭代查询可以用如下两图表示。</p>
<h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><p>如图所示，递归查询是由DNS服务器一级一级查询传递的。</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629171133.png" alt=""></p>
<h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p>如果所示，迭代查询是找到指定DNS服务器，由客户端发起查询。</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629171228.png" alt=""></p>
<h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>DNS劫持发生在DNS服务器上，当客户端请求解析域名时将其导向错误的服务器（IP）地址。</p>
<p>常见的解决办法是使用自己的解析服务器或者是将域名以IP地址的方式发出去以绕过DNS解析。</p>
<h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><p>HTTP 是无状态协议，说明它不能以状态来区分和管理请求和响应。也就是说，服务器单从网络连接上无从知道客户身份。</p>
<p>可是怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<ul>
<li><p>Cookie：Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在<strong>本地机器</strong>上存储的一小段文本，并随着每次请求发送到服务器。<strong>Cookie技术通过请求和响应报文中写入Cookie信息来控制客户端的状态。</strong></p>
</li>
<li><p>Session：Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。当有用户请求创建一个session时，服务器会先检查这个客户端里是否已经包含了一个Session标识（session id），如果有就通过session id把session检索出来。如果没有就创建一个对应此Session的session id。这个session id会在本次响应中返回给客户端。</p>
</li>
</ul>
<p>两者有以下区别：</p>
<p>1、存储位置：Cookie存放在客户端上，Session数据存放在服务器上。</p>
<p>2、Session 的运行依赖 session id，而 session id 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie ，同时 Session 也会失效</p>
<p>3、安全性：Cookie存在浏览器中，可能会被一些程序复制，篡改；而Session存在服务器相对安全很多。</p>
<p>4、性能：Session会在一定时间内保存在服务器上，当访问增多，会对服务器造成一定的压力。考虑到减轻服务器压力，应当使用Cookie</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN（Content Delivery Network），根本作用是将网站的内容发布到最接近用户的网络『边缘』，以提高用户访问速度。概括的来说：CDN = 镜像（Mirror） + 缓存（Cache） + 整体负载均衡（GSLB）。</p>
<p>目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。</p>
<h4 id="CDN工作流程"><a href="#CDN工作流程" class="headerlink" title="CDN工作流程"></a>CDN工作流程</h4><p>一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是<a href="http://www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。">www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。</a></p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629201214.png" alt=""></p>
<p>参考：<a href="https://juejin.im/post/59ba146c6fb9a00a4636d8b6">深入理解Http请求、DNS劫持与解析</a></p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>socket位于应用层和传输层之间：</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629183059.png" alt=""></p>
<p>它的作用是为了应用层能够更方便的将数据经由传输层来传输。所以它的本质就是对TCP/IP的封装，然后应用程序直接调用socket API即可进行通信。上文中说的三次握手和四次挥手即是通过socket完成的。</p>
<p>我们可以从iOS中网络库分层找到<code>BSD Sockets</code>，它是位于<code>CFNetwork</code>之下。在<code>CFNetwork</code>中还有一个<code>CFSocket</code>，推测是对<code>BSD Sockets</code>的封装。</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200629184557.png" alt=""></p>
<h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><p><a href="https://webrtc.org/">WebRTC</a>是一个可以用在视频聊天，音频聊天或P2P文件分享等Web App中的 API。借助WebRTC，你可以在基于开放标准的应用程序中添加实时通信功能。它支持在同级之间发送视频，语音和通用数据，从而使开发人员能够构建功能强大的语音和视频通信解决方案。该技术可在所有现代浏览器以及所有主要平台的本机客户端上使用。WebRTC项目是<a href="https://webrtc.googlesource.com/src/">开源的，</a>并得到Apple，Google，Microsoft和Mozilla等的支持。</p>
<h3 id="如果某一请求只在某一地特定时刻失败率较高，会有哪些原因"><a href="#如果某一请求只在某一地特定时刻失败率较高，会有哪些原因" class="headerlink" title="如果某一请求只在某一地特定时刻失败率较高，会有哪些原因"></a>如果某一请求只在某一地特定时刻失败率较高，会有哪些原因</h3><p>这个是某公司二面时的问题，是一个开放性问题，我总结了以下几点可能：</p>
<p>1、该时刻请求量过大</p>
<p>2、该地的网络节点较不稳定</p>
<p>3、用户行为习惯，比如该时刻为上班高峰期，或者某个群体的特定习惯</p>
<p>如果有对网络方面比较熟悉的小伙伴也可以补充。</p>
<p><img src="https://gitee.com/zhangferry/Images/raw/master/gitee/20200719185749.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-05-31T14:00:34.000Z" title="2020-05-31T14:00:34.000Z">2020-05-31</time><span class="level-item">37 分钟 读完 (大约 5524 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/31/swift_advance_2/">Swift进阶黄金之路（二）</a></h1><div class="content"><p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/1726adc6747571fc.png" alt="image-20200511230812677"></p>
<p><a href="https://zhangferry.com/2020/05/10/swift_advance_1/">Swift进阶黄金之路（一）</a></p>
<p>上期遗留一个问题：为什么 <code>rethrows</code> 一般用在参数中含有可以 <code>throws</code> 的方法的高阶函数中。</p>
<p>我们可以结合Swift的官方文档对<code>rethrows</code>再做一遍回顾：</p>
<blockquote>
<p>A function or method can be declared with the <code>rethrows</code> keyword to indicate that it throws an error only if one of its function parameters throws an error. These functions and methods are known as <em>rethrowing functions</em> and <em>rethrowing methods</em>. Rethrowing functions and methods must have at least one throwing function parameter.</p>
</blockquote>
<p>返回<code>rethrows</code>的函数要求至少有一个可抛出异常的函数式参数，而有以函数作为参数的函数就叫做高阶函数。</p>
<p>这期分两方面介绍Swift：特性修饰词和一些重要的Swift概念。</p>
<h2 id="特性修饰词"><a href="#特性修饰词" class="headerlink" title="特性修饰词"></a><strong>特性修饰词</strong></h2><p>在Swift语法中有很多<code>@</code>符号，这些<code>@</code>符号在Swift4之前的版本大多是兼容OC的特性，Swift4及之后则出现越来越多搭配<code>@</code>符号的新特性。以<code>@</code>开头的修饰词，在官网中叫<code>Attributes</code>，在SwiftGG的翻译中叫<a href="https://www.cnswift.org/attributes">特性</a>，我并没有找到这一类被<code>@</code>修饰的符号的统称，就暂且叫他们<code>特性修饰词</code>吧，如果有清楚的小伙伴可以告知我。</p>
<p>从Swift5的发布来看（<code>@dynamicCallable</code>,<code>@State</code>），之后将会有更多的特性修饰词出现，在他们出来之前，我们有必要先了解下现有的一些特性修饰词以及它们的作用。</p>
<p>参考：<a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html">Swift Attributes</a></p>
<h3 id="available"><a href="#available" class="headerlink" title="@available"></a>@available</h3><p><code>@available</code>： 可用来标识计算属性、函数、类、协议、结构体、枚举等类型的生命周期。（依赖于特定的平台版本 或 Swift 版本）。它的后面一般跟至少两个参数，参数之间以逗号隔开。其中第一个参数是固定的，代表着平台和语言，可选值有以下这几个：</p>
<ul>
<li><code>iOS</code></li>
<li><code>iOSApplicationExtension</code></li>
<li><code>macOS</code></li>
<li><code>macOSApplicationExtension</code></li>
<li><code>watchOS</code></li>
<li><code>watchOSApplicationExtension</code></li>
<li><code>tvOS</code></li>
<li><code>tvOSApplicationExtension</code></li>
<li><code>swift</code></li>
</ul>
<p>可以使用<code>*</code>指代支持所有这些平台。</p>
<p>有一个我们常用的例子，当需要关闭<code>ScrollView</code>的自动调整<code>inset</code>功能时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定该方法仅在iOS11及以上的系统设置</span></span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</span><br><span class="line">  scrollView.contentInsetAdjustmentBehavior = .never</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  automaticallyAdjustsScrollViewInsets = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种用法是放在函数、结构体、枚举、类或者协议的前面，表示当前类型仅适用于某一平台：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjustDarkMode</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DarkModeConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DarkModeTheme</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本和平台的限定可以写多个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.15</span>, iOS <span class="number">13</span>, tvOS <span class="number">13</span>, watchOS <span class="number">6</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">applying</span><span class="params">(<span class="number">_</span> difference: CollectionDifference&lt;Element&gt;)</span></span> -&gt; <span class="type">ArraySlice</span>&lt;<span class="type">Element</span>&gt;?</span><br></pre></td></tr></table></figure>

<p><strong>注意：作为条件语句的<code>available</code>前面是<code>#</code>，作为标记位时是<code>@</code></strong></p>
<p>刚才说了，available后面参数至少要有两个，后面的可选参数这些：</p>
<ul>
<li><p><code>deprecated</code>：从指定平台标记为过期，可以指定版本号</p>
</li>
<li><p><code>obsoleted=版本号</code>：从指定平台某个版本开始废弃（注意弃用的区别，<code>deprecated</code>是还可以继续使用，只不过是不推荐了，<code>obsoleted</code>是调用就会编译错误）该声明</p>
</li>
<li><p><code>message=信息内容</code>：给出一些附加信息</p>
</li>
<li><p><code>unavailable</code>：指定平台上是无效的</p>
</li>
<li><p><code>renamed=新名字</code>：重命名声明</p>
</li>
</ul>
<p>我们看几个例子，这个是Array里<code>flatMap</code>的函数说明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(swift, deprecated: <span class="number">4.1</span>, renamed: <span class="string">"compactMap(_:)"</span>, message: <span class="string">"Please use compactMap(_:) for the case where closure returns an optional value"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>]</span><br></pre></td></tr></table></figure>

<p>它的含义是针对swift语言，该方式在swift4.1版本之后标记为过期，对应该函数的新名字为<code>compactMap(_:)</code>，如果我们在4.1之上的版本使用该函数会收到编译器的警告，即<code>⚠️Please use compactMap(_:) for the case where closure returns an optional value</code>。</p>
<p>在Realm库里，有一个销毁<code>NotificationToken</code>的方法，被标记为<code>unavailable</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RLMNotificationToken</span> </span>&#123;</span><br><span class="line">    <span class="meta">@available</span>(*, unavailable, renamed: <span class="string">"invalidate()"</span>)</span><br><span class="line">    <span class="meta">@nonobjc</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">stop</span><span class="params">()</span></span> &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记为<code>unavailable</code>就不会被编译器联想到。这个主要是为升级用户的迁移做准备，从可用<code>stop()</code>的版本升上了，会红色报错，提示该方法不可用。因为有<code>renamed</code>，编译器会推荐你用<code>invalidate()</code>，点击<code>fix</code>就直接切换了。所以这两个标记参数常一起出现。</p>
<h3 id="discardableResult"><a href="#discardableResult" class="headerlink" title="@discardableResult"></a>@discardableResult</h3><p>带返回的函数如果没有处理返回值会被编译器警告⚠️。但有时我们就是不需要返回值的，这个时候我们可以让编译器忽略警告，就是在方法名前用<code>@discardableResult</code>声明一下。可以参考Alamofire中<code>request</code>的写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">    method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    headers: HTTPHeaders? = <span class="literal">nil</span>)</span></span></span><br><span class="line">    -&gt; <span class="type">DataRequest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">SessionManager</span>.<span class="keyword">default</span>.request(</span><br><span class="line">        url,</span><br><span class="line">        method: method,</span><br><span class="line">        parameters: parameters,</span><br><span class="line">        encoding: encoding,</span><br><span class="line">        headers: headers</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inlinable"><a href="#inlinable" class="headerlink" title="@inlinable"></a>@inlinable</h3><p>这个关键词是可内联的声明，它来源于C语言中的<code>inline</code>。C中一般用于函数前，做内联函数，它的目的是防止当某一函数多次调用造成函数栈溢出的情况。因为声明为内联函数，会在编译时将该段函数调用用具体实现代替，这么做可以省去函数调用的时间。</p>
<p>内联函数常出现在系统库中，OC中的runtim中就有大量的<code>inline</code>使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ASSERT</span>(obj);</span><br><span class="line">    <span class="type">ASSERT</span>(!obj-&gt;isTaggedPointer());</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    <span class="type">ASSERT</span>(!dest  ||  dest == <span class="type">EMPTY_POOL_PLACEHOLDER</span>  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift中的<code>@inlinable</code>和C中的<code>inline</code>基本相同，它在标准库的定义中也广泛出现，可用于方法，计算属性，下标，便利构造方法或者deinit方法中。</p>
<p>例如Swift对<code>Array</code>中<code>map</code>函数的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@inlinable <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>其实Array中声明的大部分函数前面都加了<code>@inlinable</code>，当应用某一处调用该方法时，编译器会将调用处用具体实现代码替换。</p>
<p><strong>需要注意内联声明不能用于标记为<code>private</code>或者<code>fileprivate</code>的地方。</strong></p>
<p>这很好理解，对私有方法的内联是没有意义的。内联的好处是运行时更快，因为它省略了从标准库调用<code>map</code>实现的步骤。但这个快也是有代价的，因为是编译时做替换，这增加了编译的开销，会相应的延长编译时间。</p>
<p>内联更多的是用于系统库的特性，目前我了解的Swift三方库中仅有<a href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a>使用了<code>@inlinable</code>这个特性。</p>
<h3 id="warn-unqualified-access"><a href="#warn-unqualified-access" class="headerlink" title="@warn_unqualified_access"></a>@warn_unqualified_access</h3><p>通过命名我们可以推断出其大概含义：对“不合规”的访问进行警告。这是为了解决对于相同名称的函数，不同访问对象可能产生歧义的问题。</p>
<p>比如说，Swift 标准库中<code>Array</code>和<code>Sequence</code>均实现了<code>min()</code>方法，而系统库中也定义了<code>min(::)</code>，对于可能存在的二义性问题，我们可以借助于<code>@warn_unqualified_access</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Self</span>.<span class="title">Element</span> : <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  @warn_unqualified_access</span><br><span class="line">  @inlinable <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Self</span>.<span class="title">Element</span> : <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  @warn_unqualified_access</span><br><span class="line">  @inlinable <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Element</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个特性声明会由编译器在可能存在二义性的场景中对我们发出警告。这里有一个场景可以便于理解它的含义，我们自定义一个求<code>Array</code>中最小值的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">minValue</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会收到编译器的警告：<code>Use of &#39;min&#39; treated as a reference to instance method in protocol &#39;Sequence&#39;, Use &#39;self.&#39; to silence this warning</code>。它告诉我们编译器推断我们当前使用的是Sequence中的<code>min()</code>，这与我们的想法是违背的。因为有这个<code>@warn_unqualified_access</code>限定，我们能及时的发现问题，并解决问题：<code>self.min()</code>。</p>
<h3 id="objc"><a href="#objc" class="headerlink" title="@objc"></a>@objc</h3><p>把这个特性用到任何可以在 Objective-C 中表示的声明上——例如，非内嵌类，协议，非泛型枚举（原始值类型只能是整数），类和协议的属性、方法（包括 setter 和 getter ），初始化器，反初始化器，下标。 objc 特性告诉编译器，这个声明在 Objective-C 代码中是可用的。</p>
<p>用 objc 特性标记的类必须继承自一个 Objective-C 中定义的类。如果你把 objc 用到类或协议中，它会隐式地应用于该类或协议中 Objective-C 兼容的成员上。如果一个类继承自另一个带 objc 特性标记或 Objective-C 中定义的类，编译器也会隐式地给这个类添加 objc 特性。标记为 objc 特性的协议不能继承自非 objc 特性的协议。</p>
<p>@objc还有一个用处是当你想在OC的代码中暴露一个不同的名字时，可以用这个特性，它可以用于类，函数，枚举，枚举成员，协议，getter，setter等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当在OC代码中访问enabled的getter方法时，是通过isEnabled</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="meta">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="comment">// Return the appropriate value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一特性还可以用于解决潜在的命名冲突问题，因为Swift有命名空间，常常不带前缀声明，而OC没有命名空间是需要带的，当在OC代码中引用Swift库，为了防止潜在的命名冲突，可以选择一个带前缀的名字供OC代码使用。</p>
<p><a href="https://github.com/danielgindi/Charts">Charts</a>作为一个在OC和Swift中都很常用的图标库，是需要较好的同时兼容两种语言的使用的，所以也可以看到里面有大量通过<code>@objc</code>标记对OC调用时的重命名代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>(<span class="type">ChartAnimator</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animator</span>: <span class="title">NSObject</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span>(<span class="type">ChartComponentBase</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentBase</span>: <span class="title">NSObject</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="objcMembers"><a href="#objcMembers" class="headerlink" title="@objcMembers"></a>@objcMembers</h3><p>因为Swift中定义的方法默认是不能被OC调用的，除非我们手动添加@objc标识。但如果一个类的方法属性较多，这样会很麻烦，于是有了这样一个标识符<code>@objcMembers</code>，它可以让整个类的属性方法都隐式添加<code>@objc</code>，不光如此对于类的子类、扩展、子类的扩展都也隐式的添加@objc，当然对于OC不支持的类型，仍然无法被OC调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>Members</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; &#125;             <span class="comment">// implicitly @objc</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)   <span class="comment">// not @objc, because tuple returns</span></span><br><span class="line">      <span class="comment">// aren't representable in Objective-C</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">baz</span><span class="params">()</span></span> &#123; &#125;   <span class="comment">// implicitly @objc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span> : <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">wibble</span><span class="params">()</span></span> &#123; &#125;   <span class="comment">// implicitly @objc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MySubClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">wobble</span><span class="params">()</span></span> &#123; &#125;   <span class="comment">// implicitly @objc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.im/post/5cb6dccde51d456e5a0728db">Swift3、4中的@objc、@objcMembers和dynamic</a></p>
<h3 id="testable"><a href="#testable" class="headerlink" title="@testable"></a>@testable</h3><p><code>@testable</code>是用于测试模块访问主target的一个关键词。</p>
<p>因为测试模块和主工程是两个不同的target，在swift中，每个target代表着不同的module，不同module之间访问代码需要public和open级别的关键词支撑。但是主工程并不是对外模块，为了测试修改访问权限是不应该的，所以有了<code>@testable</code>关键词。使用如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时测试模块就可以访问那些标记为internal或者public级别的类和成员了。</p>
<h3 id="frozen-和-unknown-default"><a href="#frozen-和-unknown-default" class="headerlink" title="@frozen 和@unknown default"></a>@frozen 和@unknown default</h3><p>frozen意为冻结，是为Swift5的ABI稳定准备的一个字段，意味向编译器保证之后不会做出改变。为什么需要这么做以及这么做有什么好处，他们和ABI稳定是息息相关的，内容有点多就不放这里了，之后会单独出一篇文章介绍，这里只介绍这两个字段的含义。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@frozen <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ComparisonResult</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> orderedAscending = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> orderedSame = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> orderedDescending = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@frozen <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AVPlayerItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Status</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> unknown = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> readyToPlay = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> failed = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ComparisonResult</code>这个枚举值被标记为<code>@frozen</code>即使保证之后该枚举值不会再变。注意到<code>String</code>作为结构体也被标记为<code>@frozen</code>，意为String结构体的属性及属性顺序将不再变化。其实我们常用的类型像<code>Int</code>、<code>Float</code>、<code>Array</code>、<code>Dictionary</code>、<code>Set</code>等都已被“冻结”。需要说明的是冻结仅针对<code>struct</code>和<code>enum</code>这种值类型，因为他们在编译器就确定好了内存布局。对于class类型，不存在是否冻结的概念，可以想下为什么。</p>
<p>对于没有标记为frozen的枚举<code>AVPlayerItem.Status</code>，则认为该枚举值在之后的系统版本中可能变化。</p>
<p>对于可能变化的枚举，我们在列出所有case的时候还需要加上对<code>@unknown default</code>的判断，这一步会有编译器检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> currentItem.status &#123;</span><br><span class="line">    <span class="keyword">case</span> .readyToPlay:</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">case</span> .failed:</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">case</span> .unknown:</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    @unknown <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"not supported"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="State、-Binding、-ObservedObject、-EnvironmentObject"><a href="#State、-Binding、-ObservedObject、-EnvironmentObject" class="headerlink" title="@State、@Binding、@ObservedObject、@EnvironmentObject"></a>@State、@Binding、@ObservedObject、@EnvironmentObject</h3><p>这几个是SwiftUI中出现的特性修饰词，因为我对SwiftUI的了解不多，这里就不做解释了。附一篇文章供大家了解。</p>
<p><a href="https://juejin.im/post/5d625c01f265da03cd0a8a58">[译]理解 SwiftUI 里的属性装饰器@State, @Binding, @ObservedObject, @EnvironmentObject</a></p>
<h2 id="几个重要关键词"><a href="#几个重要关键词" class="headerlink" title="几个重要关键词"></a><strong>几个重要关键词</strong></h2><h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h3><p>lazy是懒加载的关键词，当我们仅需要在使用时进行初始化操作就可以选用该关键词。举个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Avatar</span> </span>&#123;</span><br><span class="line">  <span class="built_in">lazy</span> <span class="keyword">var</span> smallImage: <span class="type">UIImage</span> = <span class="keyword">self</span>.largeImage.resizedTo(<span class="type">Avatar</span>.defaultSmallSize)</span><br><span class="line">  <span class="keyword">var</span> largeImage: <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(largeImage: <span class="type">UIImage</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.largeImage = largeImage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于smallImage，我们声明了lazy，如果我们不去调用它是不会走后面的图片缩放计算的。但是如果没有lazy，因为是初始化方法，它会直接计算出smallImage的值。所以lazy很好的避免的不必要的计算。</p>
<p>另一个常用lazy的地方是对于UI属性的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> dayLabel: <span class="type">UILabel</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> label = <span class="type">UILabel</span>()</span><br><span class="line">   label.text = <span class="keyword">self</span>.todayText()</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>这里使用的是一个闭包，当调用该属性时，执行闭包里面的内容，返回具体的label，完成初始化。</p>
<p>使用lazy你可能会发现它只能通过var初始而不能通过let，这是由 <code>lazy</code> 的具体实现细节决定的：它在没有值的情况下以某种方式被初始化，然后在被访问时改变自己的值，这就要求该属性是可变的。</p>
<p>另外我们可以在Sequences中使用lazy，在讲解它之前我们先看一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Computing next value of \(x)"</span>)</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = <span class="type">Array</span>(<span class="number">0</span>..&lt;<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> incArray = array.<span class="built_in">map</span>(increment)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result:"</span>)</span><br><span class="line"><span class="built_in">print</span>(incArray[<span class="number">0</span>], incArray[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>在执行<code>print(&quot;Result:&quot;)</code>之前，<code>Computing next value of ...</code>会被执行1000次，但实际上我们只需要0和4这两个index对应的值。</p>
<p>上面说了序列也可以使用lazy，使用的方式是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = <span class="type">Array</span>(<span class="number">0</span>..&lt;<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> incArray = array.<span class="built_in">lazy</span>.<span class="built_in">map</span>(increment)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result:"</span>)</span><br><span class="line"><span class="built_in">print</span>(incArray[<span class="number">0</span>], incArray[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// 1 5</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>print(&quot;Result:&quot;)</code>之前，并不会打印任何东西，只打印了我们用到的1和5。就是说这里的lazy可以延迟到我们取值时才去计算map里的结果。</p>
<p>我们看下这个lazy的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@inlinable <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">lazy</span>: <span class="type">LazySequence</span>&lt;<span class="type">Array</span>&lt;<span class="type">Element</span>&gt;&gt; &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>

<p>它返回一个<code>LazySequence</code>的结构体，这个结构体里面包含了<code>Array</code>，而<code>map</code>的计算在<code>LazySequence</code>里又重新定义了一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns a `LazyMapSequence` over this `Sequence`.  The elements of</span></span><br><span class="line"><span class="comment">/// the result are computed lazily, each time they are read, by</span></span><br><span class="line"><span class="comment">/// calling `transform` function on a base element.</span></span><br><span class="line">@inlinable <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(Base.Element)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">LazyMapSequence</span>&lt;<span class="type">Base</span>, <span class="type">U</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这里完成了lazy序列的实现。<code>LazySequence</code>类型的lazy只能被用于map、flatMap、compactMap这样的高阶函数中。</p>
<p><strong>参考</strong>： <a href="https://swift.gg/2016/03/25/being-lazy/">“懒”点儿好</a></p>
<p><strong>纠错</strong>：参考文章中说：”这些类型（LazySequence）只能被用在 <code>map</code>，<code>flatMap</code>，<code>filter</code>这样的高阶函数中” 其实是没有filter的，因为filter是过滤函数，它需要完整遍历一遍序列才能完成过滤操作，是无法懒加载的，而且我查了<code>LazySequence</code>的定义，确实是没有<code>filter</code>函数的。</p>
<h3 id="unowned-weak"><a href="#unowned-weak" class="headerlink" title="unowned weak"></a>unowned weak</h3><p>Swift开发过程中我们会经常跟闭包打交道，而用到闭包就不可避免的遇到循环引用问题。在Swift处理循环引用可以使用<code>unowned</code>和<code>weak</code>这两个关键词。看下面两个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span> (name: <span class="type">String</span> ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(name) is deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span> </span>&#123;</span><br><span class="line">   <span class="comment">// weak 修饰词</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> owner: <span class="type">Dog</span>?</span><br><span class="line">    <span class="keyword">init</span>(owner: <span class="type">Dog</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.owner = owner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"bone is deinitialized"</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lucky: <span class="type">Dog</span>? = <span class="type">Dog</span>(name: <span class="string">"Lucky"</span>)</span><br><span class="line"><span class="keyword">var</span> bone: <span class="type">Bone</span>? = <span class="type">Bone</span>(owner: lucky!)</span><br><span class="line">lucky =  <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Lucky is deinitialized</span></span><br></pre></td></tr></table></figure>

<p>这里Dog和Bone是相互引用的关系，如果没有<code>weak var owner: Dog?</code>这里的weak声明，将不会打印<code>Lucky is deinitialized</code>。还有一种解决循环应用的方式是把<code>weak</code>替换为<code>unowned</code>关键词。</p>
<ul>
<li>weak相当于oc里面的weak，弱引用，不会增加循环计数。主体对象释放时被weak修饰的属性也会被释放，所以weak修饰对象就是optional。</li>
<li>unowned相当于oc里面的<code>unsafe_unretained</code>，它不会增加引用计数，即使它的引用对象释放了，它仍然会保持对被已经释放了的对象的一个 “无效的” 引用，它不能是 Optional 值，也不会被指向 <code>nil</code>。如果此时为无效引用，再去尝试访问它就会crash。</li>
</ul>
<p>这两者还有一个更常用的地方是在闭包里面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> someClosure: () -&gt; <span class="type">Void</span> = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 被weak修饰后self为optional，这里是判断self非空的操作                                </span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; retrun &#125;</span><br><span class="line">    <span class="keyword">self</span>.doSomethings()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果是<code>unowned</code>修饰self的话，就不需要用guard做解包操作了。但是我们不能为了省略解包的操作就用<code>unowned</code>，也不能为了安全起见全部<code>weak</code>，弄清楚两者的适用场景非常重要。</p>
<p>根据苹果的建议：</p>
<blockquote>
<p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>
</blockquote>
<p>当闭包和它捕获的实例总是相互引用，并且总是同时释放时，即相同的生命周期，我们应该用unowned，除此之外的场景就用weak。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/1726adc72b8ad049.png" alt="img">img</p>
<p>参考：<a href="https://swifter.tips/retain-cycle/">内存管理，WEAK 和 UNOWNED</a></p>
<p><a href="https://swift.gg/2017/05/16/unowned-or-weak-lifetime-and-performance/">Unowned 还是 Weak？生命周期和性能对比</a></p>
<h3 id="KeyPath"><a href="#KeyPath" class="headerlink" title="KeyPath"></a>KeyPath</h3><p>KeyPath是键值路径，最开始是用于处理KVC和KVO问题，后来又做了更广泛的扩展。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVC问题，支持struct、class</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user1 = <span class="type">User</span>()</span><br><span class="line">user1.name = <span class="string">"ferry"</span></span><br><span class="line">user1.age = <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用KVC取值</span></span><br><span class="line"><span class="keyword">let</span> path: <span class="type">KeyPath</span> = \<span class="type">User</span>.name</span><br><span class="line">user1[keyPath: path] = <span class="string">"zhang"</span></span><br><span class="line"><span class="keyword">let</span> name = user1[keyPath: path]</span><br><span class="line"><span class="built_in">print</span>(name) <span class="comment">//zhang</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO的实现还是仅限于继承自NSObject的类型</span></span><br><span class="line"><span class="comment">// playItem为AVPlayerItem对象</span></span><br><span class="line">playItem.observe(\.status, changeHandler: &#123; (<span class="number">_</span>, change) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">/* code */</span>    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个KeyPath的定义是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyKeyPath</span> : <span class="title">Hashable</span>, <span class="title">_AppendKeyPath</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A partially type-erased key path, from a concrete root type to any</span></span><br><span class="line"><span class="comment">/// resulting value type.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartialKeyPath</span>&lt;<span class="title">Root</span>&gt; : <span class="title">AnyKeyPath</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A key path from a specific root type to a specific resulting value type.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyPath</span>&lt;<span class="title">Root</span>, <span class="title">Value</span>&gt; : <span class="title">PartialKeyPath</span>&lt;<span class="title">Root</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个<code>KeyPath</code>需要指定两个类型，根类型和对应的结果类型。对应上面示例中的path：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path: <span class="type">KeyPath</span>&lt;<span class="type">User</span>, <span class="type">String</span>&gt; = \<span class="type">User</span>.name</span><br></pre></td></tr></table></figure>

<p>根类型就是User，结果类型就是String。也可以不指定，因为编译器可以从<code>\User.name</code>推断出来。那为什么叫根类型的？可以注意到KeyPath遵循一个协议<code>_AppendKeyPath</code>，它里面定义了很多<code>append</code>的方法，KeyPath是多层可以追加的，就是如果属性是自定义的Address类型，形如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> country: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> path: <span class="type">KeyPath</span>&lt;<span class="type">User</span>, <span class="type">String</span>&gt; = \<span class="type">User</span>.address.country</span><br></pre></td></tr></table></figure>

<p>这里根类型为<code>User</code>，次级类型是<code>Address</code>，结果类型是<code>String</code>。所以<code>path</code>的类型依然是<code>KeyPath</code>。</p>
<p>明白了这些我们可以用KeyPath做一些扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sorted</span>&lt;T: Comparable&gt;<span class="params">(by keyPath: KeyPath&lt;Element, T&gt;)</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> sorted &#123; a, b <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> a[keyPath: keyPath] &lt; b[keyPath: keyPath]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// users is Array&lt;User&gt;</span></span><br><span class="line"><span class="keyword">let</span> newUsers = users.sorted(by: \.age)</span><br></pre></td></tr></table></figure>

<p>这个自定义<code>sorted</code>函数实现了通过传入keyPath进行升序排列功能。</p>
<p>参考：<a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">The power of key paths in Swift</a></p>
<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p><code>some</code>是Swift5.1新增的特性。它的用法就是修饰在一个 protocol 前面，默认场景下 protocol 是没有具体类型信息的，但是用 <code>some</code> 修饰后，编译器会让 protocol 的实例类型对外透明。</p>
<p>可以通过一个例子理解这段话的含义，当我们尝试定义一个遵循<code>Equatable</code>协议的value时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Protocol 'Equatable' can only be used as a generic constraint because it has Self or associated type requirements</span></span><br><span class="line"><span class="keyword">var</span> value: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器提示我们<code>Equatable</code>只能被用来做泛型的约束，它不是一个具体的类型，这里我们需要使用一个遵循<code>Equatable</code>的具体类型（Int）进行定义。但有时我们并不想指定具体的类型，这时就可以在协议名前加上<code>some</code>，让编译器自己去推断value的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value: some <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SwiftUI里some随处可见：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>some</code>就是因为<code>View</code>是一个协议，而不是具体类型。</p>
<p>当我们尝试欺骗编译器，每次随机返回不同的<code>Equatable</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value: some <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">Bool</span>.random() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聪明的编译器是会发现的，并警告我们<code>Function declares an opaque return type, but the return statements in its body do not have matching underlying types</code>。</p>
<p>参考：<a href="https://onevcat.com/2019/06/swift-ui-firstlook/">SwiftUI 的一些初步探索 (一)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/IMG_2555.jpg" alt="IMG_2555"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-05-22T03:28:09.000Z" title="2020-05-22T03:28:09.000Z">2020-05-22</time><span class="level-item">28 分钟 读完 (大约 4241 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/22/ios_code_checker/">如何通过静态分析提高iOS代码质量</a></h1><div class="content"><p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17235171e5857002-20200524072010074.png" alt=""><br>随着项目的扩大，依靠人工codereview来保证项目的质量，越来越不现实，这时就有必要借助于一种自动化的代码审查工具：<strong>程序静态分析</strong>。</p>
<p>程序静态分析（Program Static Analysis）是指在不运行代码的方式下，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。（来自百度百科）</p>
<p>词法分析，语法分析等工作是由编译器进行的，所以对iOS项目为了完成静态分析，我们需要借助于编译器。对于OC语言的静态分析可以完全通过<a href="http://clang.llvm.org/">Clang</a>，对于Swift的静态分析除了Clange还需要借助于<a href="http://www.jpsim.com/uncovering-sourcekit">SourceKit</a>。</p>
<p>Swift语言对应的静态分析工具是SwiftLint，OC语言对应的静态分析工具有Infer和OCLitn。以下会是对各个静态分析工具的安装和使用做一个介绍。</p>
<h2 id="SwiftLint"><a href="#SwiftLint" class="headerlink" title="SwiftLint"></a>SwiftLint</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/172350fedc7e6aa2-20200524072022825.png" alt=""><br>对于Swift项目的静态分析可以使用<a href="https://github.com/realm/SwiftLint">SwiftLint</a>。SwiftLint 是一个用于强制检查 Swift 代码风格和规定的一个工具。它的实现是 Hook 了 Clang 和 SourceKit 从而能够使用 <a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">AST</a> 来表示源代码文件的更多精确结果。Clange我们了解了，那SourceKit是干什么用的？</p>
<p>SourceKit包含在<a href="https://github.com/apple/swift/tree/master/tools/SourceKit">Swift</a>项目的主仓库，它是一套工具集，支持Swift的大多数源代码操作特性：源代码解析、语法突出显示、排版、自动完成、跨语言头生成等工作。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装有两种方式，任选其一：</p>
<p><strong>方式一：通过Homebrew</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install swiftlint</span><br></pre></td></tr></table></figure>

<p>这种是全局安装，各个应用都可以使用。</p>
<p><strong>方式二：通过CocoaPods</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SwiftLint&#39;, :configurations &#x3D;&gt; [&#39;Debug&#39;]</span><br></pre></td></tr></table></figure>

<p>这种方式相当于把SwiftLint作为一个三方库集成进了项目，因为它只是调试工具，所以我们应该将其指定为仅Debug环境下生效。</p>
<h3 id="集成进Xcode"><a href="#集成进Xcode" class="headerlink" title="集成进Xcode"></a>集成进Xcode</h3><p>我们需要在项目中的<code>Build Phases</code>，添加一个<code>Run Script Phase</code>。如果是通过homebrew安装的，你的脚本应该是这样的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if which swiftlint &gt;/dev/null; then</span><br><span class="line">  swiftlint</span><br><span class="line">else</span><br><span class="line">  echo "warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>如果是通过cocoapods安装的，你得脚本应该是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint"</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17234ecc122be19a-20200524072035061.png" alt=""></p>
<h3 id="运行SwiftLint"><a href="#运行SwiftLint" class="headerlink" title="运行SwiftLint"></a>运行SwiftLint</h3><p>键入<code>CMD + B</code>编译项目，在编译完后会运行我们刚才加入的脚本，之后我们就能看到项目中大片的警告信息。有时候build信息并不能填入项目代码中，我们可以在编译的log日志里查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17234ecc11c4f792-20200524071349318.png" alt=""></p>
<h3 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h3><p>SwiftLint规则太多了，如果我们不想执行某一规则，或者想要滤掉对Pods库的分析，我们可以对SwfitLint进行配置。</p>
<p>在项目根目录新建一个<code>.swiftlint.yml</code>文件，然后填入如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disabled_rules:</span> <span class="comment"># rule identifiers to exclude from running</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">colon</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">trailing_whitespace</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">vertical_whitespace</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">function_body_length</span></span><br><span class="line"><span class="attr">opt_in_rules:</span> <span class="comment"># some rules are only opt-in</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">empty_count</span></span><br><span class="line">  <span class="comment"># Find all the available rules by running:</span></span><br><span class="line">  <span class="comment"># swiftlint rules</span></span><br><span class="line"><span class="attr">included:</span> <span class="comment"># paths to include during linting. `--path` is ignored if present.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Source</span></span><br><span class="line"><span class="attr">excluded:</span> <span class="comment"># paths to ignore during linting. Takes precedence over `included`.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Carthage</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Pods</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Source/ExcludedFolder</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Source/ExcludedFile.swift</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Source/*/ExcludedFile.swift</span> <span class="comment"># Exclude files with a wildcard</span></span><br><span class="line"><span class="attr">analyzer_rules:</span> <span class="comment"># Rules run by `swiftlint analyze` (experimental)</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">explicit_self</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># configurable rules can be customized from this configuration file</span></span><br><span class="line"><span class="comment"># binary rules can set their severity level</span></span><br><span class="line"><span class="attr">force_cast:</span> <span class="string">warning</span> <span class="comment"># implicitly</span></span><br><span class="line"><span class="attr">force_try:</span></span><br><span class="line"><span class="attr">  severity:</span> <span class="string">warning</span> <span class="comment"># explicitly</span></span><br><span class="line"><span class="comment"># rules that have both warning and error levels, can set just the warning level</span></span><br><span class="line"><span class="comment"># implicitly</span></span><br><span class="line"><span class="attr">line_length:</span> <span class="number">110</span></span><br><span class="line"><span class="comment"># they can set both implicitly with an array</span></span><br><span class="line"><span class="attr">type_body_length:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">300</span> <span class="comment"># warning</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">400</span> <span class="comment"># error</span></span><br><span class="line"><span class="comment"># or they can set both explicitly</span></span><br><span class="line"><span class="attr">file_length:</span></span><br><span class="line"><span class="attr">  warning:</span> <span class="number">500</span></span><br><span class="line"><span class="attr">  error:</span> <span class="number">1200</span></span><br><span class="line"><span class="comment"># naming rules can set warnings/errors for min_length and max_length</span></span><br><span class="line"><span class="comment"># additionally they can set excluded names</span></span><br><span class="line"><span class="attr">type_name:</span></span><br><span class="line"><span class="attr">  min_length:</span> <span class="number">4</span> <span class="comment"># only warning</span></span><br><span class="line"><span class="attr">  max_length:</span> <span class="comment"># warning and error</span></span><br><span class="line"><span class="attr">    warning:</span> <span class="number">40</span></span><br><span class="line"><span class="attr">    error:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">  excluded:</span> <span class="string">iPhone</span> <span class="comment"># excluded via string</span></span><br><span class="line"><span class="attr">  allowed_symbols:</span> <span class="string">["_"]</span> <span class="comment"># these are allowed in type names</span></span><br><span class="line"><span class="attr">identifier_name:</span></span><br><span class="line"><span class="attr">  min_length:</span> <span class="comment"># only min_length</span></span><br><span class="line"><span class="attr">    error:</span> <span class="number">4</span> <span class="comment"># only error</span></span><br><span class="line"><span class="attr">  excluded:</span> <span class="comment"># excluded via string array</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">id</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">URL</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">GlobalAPIKey</span></span><br><span class="line"><span class="attr">reporter:</span> <span class="string">"xcode"</span> <span class="comment"># reporter type (xcode, json, csv, checkstyle, junit, html, emoji, sonarqube, markdown)</span></span><br></pre></td></tr></table></figure>

<p>一条rules提示如下，其对应的rules名就是<code>function_body_length</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! Function Body Length Violation: Function body should span 40 lines or less excluding comments and whitespace: currently spans 43 lines (function_body_length)</span><br></pre></td></tr></table></figure>

<p><code>disabled_rules</code>下填入我们不想遵循的规则。</p>
<p><code>excluded</code>设置我们想跳过检查的目录，Carthage、Pod、SubModule这些一般可以过滤掉。</p>
<p>其他的一些像是文件长度（file_length），类型名长度（type_name），我们可以通过设置具体的数值来调节。</p>
<p>另外SwiftLint也支持自定义规则，我们可以根据自己的需求，定义自己的<code>rule</code>。</p>
<h3 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h3><p>如果我们想将此次分析生成一份报告，也是可以的（该命令是通过homebrew安装的swiftlint）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reporter type (xcode, json, csv, checkstyle, junit, html, emoji, sonarqube, markdown)</span></span><br><span class="line">$ swiftlint lint --reporter html &gt; swiftlint.html</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17234ecffbd58df9-20200524071402318.png" alt=""></p>
<h2 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h2><p>xcodebuild是xcode内置的编译命令，我们可以用它来编译打包我们的iOS项目，接下来介绍的Infer和OCLint都是基于xcodebuild的编译产物进行分析的，所以有必要简单介绍一下它。</p>
<p>一般编译一个项目，我们需要指定项目名，configuration，scheme，sdk等信息以下是几个简单的命令及说明。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不带pod的项目，target名为TargetName，在Debug下，指定模拟器sdk环境进行编译</span></span><br><span class="line">xcodebuild -target TargetName -configuration Debug -sdk iphonesimulator</span><br><span class="line"><span class="meta">#</span><span class="bash"> 带pod的项目，workspace名为TargetName.xcworkspace，在Release下，scheme为TargetName，指定真机环境进行编译。不指定模拟器环境会验证证书</span></span><br><span class="line">xcodebuild -workspace WorkspaceName.xcworkspace -scheme SchemeName Release</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清楚项目的编译产物</span></span><br><span class="line">xcodebuild -workspace WorkspaceName.xcworkspace -scheme SchemeName Release clean</span><br></pre></td></tr></table></figure>

<p><strong>之后对xcodebuild命令的使用都需要将这些参数替换为自己项目的参数。</strong></p>
<h2 id="Infer"><a href="#Infer" class="headerlink" title="Infer"></a>Infer</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17235114be547093-20200524071413231.png" alt=""><br><a href="https://infer.liaohuqiu.net/">Infer</a>是Facebook开发的针对C、OC、Java语言的静态分析工具，它同时支持对iOS和Android应用的分析。对于Facebook内部的应用像是 Messenger、Instagram 和其他一些应用均是有它进行静态分析的。它主要检测隐含的问题，主要包括以下几条：</p>
<ul>
<li>资源泄露，内存泄露</li>
<li>变量和参数的非空检测</li>
<li>循环引用</li>
<li>过早的nil操作</li>
</ul>
<p>暂不支持自定义规则。</p>
<h3 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install infer</span><br></pre></td></tr></table></figure>


<p>运行infer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> projectDir</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳过对Pods的分析</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> infer run --skip-analysis-in-path Pods -- xcodebuild -workspace <span class="string">"Project.xcworkspace"</span> -scheme <span class="string">"Scheme"</span> -configuration Debug -sdk iphonesimulator</span></span><br></pre></td></tr></table></figure>

<p>我们会得到一个<code>infer-out</code>的文件夹，里面是各种代码分析的文件，有txt，json等文件格式，当这样不方便查看，我们可以将其转成html格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ infer explore --html</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17234ecf28954fee-20200524071427211.png" alt=""></p>
<p>点击trace，我们会看到该问题代码的上下文。</p>
<p>因为Infer默认是增量编译，只会分析变动的代码，如果我们想整体编译的话，需要clean一下项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace <span class="string">"Project.xcworkspace"</span> -scheme <span class="string">"Scheme"</span> -configuration Debug -sdk iphonesimulator clean</span></span><br></pre></td></tr></table></figure>

<p>再次运行Infer去编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ infer run --skip-analysis-in-path Pods -- xcodebuild -workspace <span class="string">"Project.xcworkspace"</span> -scheme <span class="string">"Scheme"</span> -configuration Debug -sdk iphonesimulator</span><br></pre></td></tr></table></figure>

<h3 id="Infer的大致原理"><a href="#Infer的大致原理" class="headerlink" title="Infer的大致原理"></a>Infer的大致原理</h3><p>Infer的静态分析主要分两个阶段：</p>
<p><strong>1、捕获阶段</strong></p>
<p>Infer 捕获编译命令，将文件翻译成 Infer 内部的中间语言。</p>
<p>这种翻译和编译类似，Infer 从编译过程获取信息，并进行翻译。这就是我们调用 Infer 时带上一个编译命令的原因了，比如: <code>infer -- clang -c file.c</code>, <code>infer -- javac File.java</code>。结果就是文件照常编译，同时被 Infer 翻译成中间语言，留作第二阶段处理。特别注意的就是，如果没有文件被编译，那么也没有任何文件会被分析。</p>
<p>Infer 把中间文件存储在结果文件夹中，一般来说，这个文件夹会在运行 <code>infer</code> 的目录下创建，命名是 <code>infer-out/</code>。</p>
<p><strong>2、分析阶段</strong></p>
<p>在分析阶段，Infer 分析 <code>infer-out/</code> 下的所有文件。分析时，会单独分析每个方法和函数。</p>
<p>在分析一个函数的时候，如果发现错误，将会停止分析，但这不影响其他函数的继续分析。</p>
<p>所以你在检查问题的时候，修复输出的错误之后，需要继续运行 Infer 进行检查，知道确认所有问题都已经修复。</p>
<p>错误除了会显示在标准输出之外，还会输出到文件 <code>infer-out/bug.txt</code> 中，我们过滤这些问题，仅显示最有可能存在的。</p>
<p>在结果文件夹中（<code>infer-out</code>），同时还有一个 csv 文件 <code>report.csv</code>，这里包含了所有 Infer 产生的信息，包括：错误，警告和信息。</p>
<h2 id="OCLint"><a href="#OCLint" class="headerlink" title="OCLint"></a>OCLint</h2><p><a href="http://oclint.org/">OCLint</a>是基于<a href="http://clang.llvm.org/docs/LibTooling.html">Clange Tooling</a>编写的库，它支持扩展，检测的范围比Infer要大。不光是隐藏bug，一些代码规范性的问题，例如命名和函数复杂度也均在检测范围之内。</p>
<h4 id="安装OCLint"><a href="#安装OCLint" class="headerlink" title="安装OCLint"></a>安装OCLint</h4><p>OCLint一般通过Homebrew安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew tap oclint/formulae   </span><br><span class="line">$ brew install oclint</span><br></pre></td></tr></table></figure>

<p>通过Hombrew安装的版本为0.13。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ oclint --version</span><br><span class="line">LLVM (http://llvm.org/):</span><br><span class="line">  LLVM version 5.0.0svn-r313528</span><br><span class="line">  Optimized build.</span><br><span class="line">  Default target: x86_64-apple-darwin19.0.0</span><br><span class="line">  Host CPU: skylake</span><br><span class="line"></span><br><span class="line">OCLint (http://oclint.org/):</span><br><span class="line">  OCLint version 0.13.</span><br><span class="line">  Built Sep 18 2017 (08:58:40).</span><br></pre></td></tr></table></figure>

<p>我分别用Xcode11在两个项目上运行过OCLint，一个实例项目可以正常运行，另一个复杂的项目却运行失败，报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 error generated</span><br><span class="line">1 error generated</span><br><span class="line">...</span><br><span class="line">oclint: error: cannot open report output file ..../onlintReport.html</span><br></pre></td></tr></table></figure>

<p>我并不清楚原因，如果你想试试0.13能否使用的话，直接跳到安装xcpretty。如果你也遇到了这个问题，可以回来安装oclint0.15版本。</p>
<h4 id="OCLint0-15"><a href="#OCLint0-15" class="headerlink" title="OCLint0.15"></a>OCLint0.15</h4><p>我在<a href="https://github.com/oclint/oclint/issues/547">oclint issuse #547</a>这里找到了这个问题和对应的解决方案。</p>
<p>我们需要更新oclint至0.15版本。brew上的最新版本是0.13，github上的最新版本是0.15。我下载github上的release0.15版本，但是这个包并不是编译过的，不清楚是不是官方自己搞错了，只能手动编译了。因为编译要下载llvm和clange，这两个包较大，所以我将编译过后的包直接传到了这里<a href="https://github.com/zhangferry/CodeChecker">CodeChecker</a>。</p>
<p>如果不关心编译过程，可以下载编译好的包，跳到设置环境变量那一步。</p>
<p><strong>编译OCLint</strong></p>
<p>1、安装<a href="https://cmake.org/">CMake</a>和<a href="https://ninja-build.org/">Ninja</a>这两个编译工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install cmake ninja</span><br></pre></td></tr></table></figure>

<p>2、clone OCLint项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/oclint/oclint</span><br></pre></td></tr></table></figure>

<p>3、进入oclint-scripts目录，执行make命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./make</span><br></pre></td></tr></table></figure>

<p>成功之后会出现build文件夹，里面有个oclint-release就是编译成功的oclint工具。</p>
<p><strong>设置oclint工具的环境变量</strong></p>
<p>设置环境变量的目的是为了我们能够快捷访问。然后我们需要配置PATH环境变量，注意OCLint_PATH的路径为你存放oclint-release的路径。将其添加到<code>.zshrc</code>，或者<code>.bash_profile</code>文件末尾:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OCLint_PATH=/Users/zhangferry/oclint/build/oclint-release</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$OCLint_PATH</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>执行<code>source .zshrc</code>，刷新环境变量，然后验证oclint是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ oclint --version</span><br><span class="line">OCLint (http://oclint.org/):</span><br><span class="line">OCLint version 0.15.</span><br><span class="line">Built May 19 2020 (11:48:49).</span><br></pre></td></tr></table></figure>

<p>出现这个介绍就说明我们已经完成了安装。</p>
<h3 id="安装xcpretty"><a href="#安装xcpretty" class="headerlink" title="安装xcpretty"></a>安装xcpretty</h3><p>xcpretty是一个格式化xcodebuild输出内容的脚本工具，oclint的解析依赖于它的输出。它的安装方式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gem install xcpretty</span></span><br></pre></td></tr></table></figure>

<h3 id="OCLint的使用"><a href="#OCLint的使用" class="headerlink" title="OCLint的使用"></a>OCLint的使用</h3><p>在使用OCLint之前还需要一些准备工作，需要将编译项<code>COMPILER_INDEX_STORE_ENABLE</code>设置为NO。</p>
<ul>
<li>将 Project 和 Targets 中 Building Settings 下的 <code>COMPILER_INDEX_STORE_ENABLE</code> 设置为 <strong>NO</strong></li>
<li>在 podfile 中 <strong>target ‘target’ do 前面</strong>添加下面的脚本，将各个pod的编译配置也改为此选项</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span></span><br><span class="line">      target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">          config.build_settings[<span class="string">'COMPILER_INDEX_STORE_ENABLE'</span>] = <span class="string">"NO"</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>1、进入项目根目录，运行如下脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace ProjectName.xcworkspace -scheme ProjectScheme -configuration Debug -sdk iphonesimulator | xcpretty -r json-compilation-database -o compile_commands.json</span></span><br></pre></td></tr></table></figure>

<p>会将xcodebuild编译过程中的一些信息记录成一个文件<code>compile_commands.json</code>，如果我们在项目根目录看到了该文件，且里面是有内容的，证明我们完成了第一步。</p>
<p>2、我们将这个json文件转成方便查看的html，过滤掉对Pods文件的分析，为了防止行数上限，我们加上行数的限制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> oclint-json-compilation-database -e Pods -- -report-type html -o oclintReport.html -rc LONG_LINE=9999 -max-priority-1=9999 -max-priority-2=9999 -max-priority-3=9999</span></span><br></pre></td></tr></table></figure>

<p>最终会产生一个<code>oclintReport.html</code>文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17234f0bd08b57c8-20200524071439420.png" alt=""></p>
<p>OCLint支持自定义规则，因为其本身规则已经很丰富了，自定义规则的需求应该很小，也就没有尝试。</p>
<p><strong>封装脚本</strong></p>
<p>OCLint跟Infer一样都是通过运行几个脚本语言进行执行的，我们可以将这几个命令封装成一个脚本文件，以OCLint为例，Infer也类似：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mark sure you had install the oclint and xcpretty</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> You need to replace these values with your own project configuration</span></span><br><span class="line">workspace_name="WorkSpaceName.xcworkspace"</span><br><span class="line">scheme_name="SchemeName"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> remove <span class="built_in">history</span></span></span><br><span class="line">rm compile_commands.json</span><br><span class="line">rm oclint_result.xml</span><br><span class="line"><span class="meta">#</span><span class="bash"> clean project</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -sdk iphonesimulator means run simulator</span></span><br><span class="line">xcodebuild -workspace $workspace_name -scheme $scheme_name -configuration Debug -sdk iphonesimulator clean || (echo "command failed"; exit 1);</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> compile_commands.json</span></span><br><span class="line">xcodebuild -workspace $workspace_name -scheme $scheme_name -configuration Debug -sdk iphonesimulator \</span><br><span class="line">| xcpretty -r json-compilation-database -o compile_commands.json \</span><br><span class="line">|| (echo "command failed"; exit 1);</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> report html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you can run `oclint -<span class="built_in">help</span>` to see all USAGE</span></span><br><span class="line">oclint-json-compilation-database -e Pods -- -report-type html -o oclintReport.html \</span><br><span class="line">-disable-rule ShortVariableName \</span><br><span class="line">-rc LONG_LINE=1000 \</span><br><span class="line">|| (echo "command failed"; exit 1);</span><br><span class="line"></span><br><span class="line">open -a "/Applications/Safari.app" oclintReport.html</span><br></pre></td></tr></table></figure>

<p><code>oclint-json-compilation-database</code>命令的几个参数说明：</p>
<p><code>-e</code><br> 需要忽略分析的文件，这些文件的警告不会出现在报告中</p>
<p><code>-rc</code><br> 需要覆盖的规则的阀值，这里可以自定义项目的阀值，<a href="]http://docs.oclint.org/en/stable/howto/thresholds.html#mccabe76">默认阀值</a></p>
<p><code>-enable-rule</code><br> 支持的规则，默认是oclint提供的都支持，可以组合-disable-rule来过滤掉一些规则<br> <a href="http://docs.oclint.org/en/stable/rules/index.html">规则列表</a></p>
<p><code>-disable-rule</code><br> 需要忽略的规则，根据项目需求设置</p>
<h4 id="在Xcode中使用OCLint"><a href="#在Xcode中使用OCLint" class="headerlink" title="在Xcode中使用OCLint"></a>在Xcode中使用OCLint</h4><p>因为OCLint提供了xcode格式的输出样式，所以我们可以将它作为一个脚本放在Xcode中。</p>
<p>1、在项目的 TARGETS 下面，点击下方的 “+” ，选择 cross-platform 下面的 Aggregate。输入名字，这里命名为 OCLint</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17234eccc856021e-20200524071454807.png" alt="new_target"></p>
<p>2、选中该Target，进入Build Phases，添加Run Script，写入下面脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Type a script or drag a script file from your workspace to insert its path.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内置变量</span></span><br><span class="line">cd $&#123;SRCROOT&#125;</span><br><span class="line">xcodebuild clean </span><br><span class="line">xcodebuild | xcpretty -r json-compilation-database</span><br><span class="line">oclint-json-compilation-database -e Pods -- -report-type xcode</span><br></pre></td></tr></table></figure>

<p>可以看出该脚本跟上面的脚本一样，只不过 将<code>oclint-json-compilation-database</code>命令的<code>-report-type</code>由<code>html</code>改为了<code>xcode</code>。而OCLint作为一个target本身就运行在特定的环境下，所以xcodebuild可以省去配置参数。</p>
<p>3、通过<code>CMD + B</code>我们编译一下项目，执行脚本任务，会得到能够定位到代码的warning信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/17234eccc81f9502-20200524071506685.png" alt="xcode_warning"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是对这几种静态分析方案的对比，我们可以根据需求选择适合自己的静态分析方案。</p>
<table>
<thead>
<tr>
<th></th>
<th>SwiftLint</th>
<th>Infer</th>
<th>OCLint</th>
</tr>
</thead>
<tbody><tr>
<td>支持语言</td>
<td>Swift</td>
<td>C、C++、OC、Java</td>
<td>C、C++、OC</td>
</tr>
<tr>
<td>易用性</td>
<td>简单</td>
<td>较简单</td>
<td>较简单</td>
</tr>
<tr>
<td>能否集成进Xcode</td>
<td>可以</td>
<td>不能集成进xcode</td>
<td>可以</td>
</tr>
<tr>
<td>自带规则丰富度</td>
<td>较多，包含代码规范</td>
<td>相对较少，主要检测潜在问题</td>
<td>较多，包含代码规范</td>
</tr>
<tr>
<td>规则扩展性</td>
<td>可以</td>
<td>不可以</td>
<td>可以</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ce9f477f265da1b7c60f4fe#heading-1">OCLint 实现 Code Review - 给你的代码提提质量</a></p>
<p><a href="http://docs.oclint.org/en/stable/guide/xcode.html">Using OCLint in Xcode</a></p>
<p><a href="https://infer.liaohuqiu.net/docs/infer-workflow.html">Infer 的工作机制</a></p>
<p><a href="https://github.com/CYBoys/Blogs/blob/master/LLVM_Clang/LLVM%20%26%20Clang%20%E5%85%A5%E9%97%A8.md">LLVM &amp; Clang 入门</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-05-09T16:00:34.000Z" title="2020-05-09T16:00:34.000Z">2020-05-10</time><span class="level-item">41 分钟 读完 (大约 6075 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/10/swift_advance_1/">Swift进阶黄金之路</a></h1><div class="content"><p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/image-20200511230812677.png" alt="image-20200511230812677"></p>
<p><a href="https://zhangferry.com/2020/05/31/swift_advance_2/">Swift进阶黄金之路（二）</a></p>
<p>这篇是对<a href="https://juejin.im/post/5e96f898e51d4546c27bcf81">一文鉴定是Swift的王者，还是青铜</a>文章中问题的解答。这些问题仅仅是表层概念，属于知识点，在我看来即使都很清楚也并不能代表上了王者，如果非要用段位类比的话，黄金还是合理的😄。</p>
<p>Swift是一门上手容易，但是精通较难的语言。即使下面这些内容都不清楚也不妨碍你开发业务需求，但是了解之后它能够帮助我们写出更加Swifty的代码。</p></div><a class="article-more button is-small size-small" href="/2020/05/10/swift_advance_1/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-05T14:39:34.000Z" title="2020-04-05T14:39:34.000Z">2020-04-05</time><span class="level-item">33 分钟 读完 (大约 5018 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/05/ios_photo_format_compare/">iOS开发图片格式选择</a></h1><div class="content"><p><img src="https://cdn.jsdelivr.net/gh/zhangferry/Images/blog/1714d8ba5edf9f51.png" alt=""></p>
<h2 id="图片是如何显示的"><a href="#图片是如何显示的" class="headerlink" title="图片是如何显示的"></a>图片是如何显示的</h2><p>在讲解如何选择图片格式之前，我感觉有必要先了解下，图片是如何展示的。如果我们要展示一张图片，一般步骤是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Assets.xcassets中的图片，不需要后缀</span></span><br><span class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"icon"</span>)</span><br><span class="line"><span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(frame: rect)</span><br><span class="line">imageView.image = image</span><br><span class="line">view.addSubview(imageView)</span><br></pre></td></tr></table></figure>

<p>运行程序，我们就可以在指定位置看到这个icon。看似简单的代码背后隐藏了很多细节工作。一张图片的展示，从代码执行到展示出来大致经历了这些步骤：</p></div><a class="article-more button is-small size-small" href="/2020/04/05/ios_photo_format_compare/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-03-28T05:11:27.000Z" title="2020-03-28T05:11:27.000Z">2020-03-28</time><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">15 分钟 读完 (大约 2196 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/28/interview_kuaishou/">快手iOS面经</a></h1><div class="content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>过完年来北京之后，有准备看看机会，也是想了解下市场行情。简历没有投太多，只定向投了头条教育部门、抖音、快手、阿里，这些公司。头条和阿里的简历都没过，肯定是亮点太少吧。只有快手简历过了，快手是三轮技术面+一轮HR面，前两轮技术都比较顺利，到第三轮却栽了，很痛心o(╥﹏╥)o。目前就不考虑换工作了，等下半年再说了，接下来的时间再好好精炼一下。</p>
<p>快手是视频面试，不支持周末，但是可以选择晚上时间，我这几次都是定在了晚上九点。视频面试是通过牛客网进行的，以下是我还记得下来的各轮面试题，对于一些iOS基础知识就不做解答了。</p></div><a class="article-more button is-small size-small" href="/2020/03/28/interview_kuaishou/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-23T05:28:09.000Z" title="2020-02-23T05:28:09.000Z">2020-02-23</time><span class="level-item">14 分钟 读完 (大约 2081 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/23/runtime_objc_class/">Runtime内存模型探究</a></h1><div class="content"><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/laptop-2838917_1280.jpg" alt=""></p>
<blockquote>
<p>Objective-C是一种通用、高级、面向对象的编程语言。它扩展了标准的ANSI C编程语言，将Smalltalk式的消息传递机制加入到ANSI C中。</p>
</blockquote>
<p>可以这么理解，Objective-C = C + Runtime，Runtime是将C语言具有面向对象功能的推动剂，是iOS开发中的核心概念。我们可以在苹果开源的 <a href="https://opensource.apple.com/tarballs/objc4/">runtime</a>（当前的最新版本objc4-779.1.tar.gz）中可以发现一些 Objective-C 对象模型的实现细节。</p></div><a class="article-more button is-small size-small" href="/2020/02/23/runtime_objc_class/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-01T03:28:09.000Z" title="2020-02-01T03:28:09.000Z">2020-02-01</time><span class="level-item">9 分钟 读完 (大约 1315 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/01/vscode_python/">VSCode配置Python版本</a></h1><div class="content"><p>刚学习Python没多久，对VSCode也不是很熟悉，在一次解问题的过程中，加深了对这两者的印象，于是记录一下。</p>
<p>环境：Mac OS 10.15，VSCode 1.41.1</p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>我在尝试用VSCode写python爬虫，遇到一个问题<code>ImportError: No module named requests</code>。</p>
<p>通过问题描述很容易知道问题，这是因为导入了<code>requests</code>库，但是VSCode却没有找到这个库。</p></div><a class="article-more button is-small size-small" href="/2020/02/01/vscode_python/#more">阅读更多</a></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/7/">7</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/avatar.png" alt="zhangferry"></figure><p class="title is-size-4 is-block line-height-inherit">zhangferry</p><p class="is-size-6 is-block">iOS开发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zhangferry" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zhangferry"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/2947186387/profile"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="https://zhangferry.com/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="http://colin1994.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Colin</span></span><span class="level-right"><span class="level-item tag">colin1994.github.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="http://www.evenvi.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Evenvi</span></span><span class="level-right"><span class="level-item tag">www.evenvi.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-24T00:11:27.000Z">2020-07-24</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/24/interview_summary_202006/">iOS面试总结（2020年6月）</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-19T09:32:57.000Z">2020-07-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/19/interview-multithreading/">iOS面试篇-多线程</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-30T03:28:09.000Z">2020-06-30</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/30/interview-network/">iOS面试篇</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-31T14:00:34.000Z">2020-05-31</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/31/swift_advance_2/">Swift进阶黄金之路（二）</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-22T03:28:09.000Z">2020-05-22</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/22/ios_code_checker/">如何通过静态分析提高iOS代码质量</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/06/"><span class="level-start"><span class="level-item">六月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/12/"><span class="level-start"><span class="level-item">十二月 2016</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/10/"><span class="level-start"><span class="level-item">十月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/09/"><span class="level-start"><span class="level-item">九月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/08/"><span class="level-start"><span class="level-item">八月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ANCS/"><span class="tag">ANCS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AVPlayer/"><span class="tag">AVPlayer</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cocoapods/"><span class="tag">Cocoapods</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DFU/"><span class="tag">DFU</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hybrid/"><span class="tag">Hybrid</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Notification/"><span class="tag">Notification</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UI/"><span class="tag">UI</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag is-grey-lightest">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E5%AE%A2/"><span class="tag">博客</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E4%BD%9C/"><span class="tag">工作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8B%9B%E8%81%98/"><span class="tag">招聘</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"><span class="tag">敏捷开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%88%E6%8A%A5/"><span class="tag">月报</span><span class="tag is-grey-lightest">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%AC%E5%9C%B0%E5%8C%96/"><span class="tag">本地化</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB/"><span class="tag">生活</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"><span class="tag">程序员</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%93%9D%E7%89%99/"><span class="tag">蓝牙</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%85%E8%AF%BB/"><span class="tag">阅读</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"><span class="tag">静态分析</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"><span class="tag">黑苹果</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo_2.svg" alt="zhangferry" height="28"></a><p class="size-small"><span>&copy; 2020 zhangferry</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://zhangferry.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>