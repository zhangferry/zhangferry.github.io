{"pages":[{"title":"","text":"zhangferry.github.io个人技术站点","link":"/README.html"},{"title":"About Me","text":"基本信息姓名：张飞 出生：1993年 教育：河南科技大学 计算机科学与技术 邮箱：zhangferry11@gmail.com 微信：zoogfly 掘金：zhangferry 公众号：iOS成长之路 成长，突破，进阶，这是我们每个iOS开发者，每个程序员都需要经历的阶段。目前我正走在突破和进阶的路上，公众号主要分享自己对编程知识的理解和在工作中的一些感悟，希望有你陪伴的成长之路上我们共同成长。 工作经历2018年3月~至今北京乐信圣文有限公司 Peace，KJV Bible，BitColor等产品主程 Swift + RxSwift 2017年1月~2018年3月北京奇思文化传媒有限公司 开发高清影视，可见VR产品 AVPlayer + IJKPlayer 2015年7月~2017年1月北京玖为科技有限公司 关爱手环客户端，KT03空气探测器客户端主程 OC + Bluetooth","link":"/about/index.html"},{"title":"All categories","text":"","link":"/categories/index.html"},{"title":"link","text":"link: name: ibiremeinfo: 伽蓝之堂—— 一只魔法师的工坊url: https://blog.ibireme.com/avatar: name: Colininfo: 嗨，我是余龙泽，一名 iOS 开发者，就职于美图。url: http://colin1994.github.io/avatar:","link":"/link/index.html"},{"title":"project","text":"","link":"/project/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"All tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2018年七月","text":"虽然一直都有想要保持写日记的习惯，但是对于我这种上班时间不稳定切偏晚，经常11点12点才能离开公司的人，就更难了。但如果不写点什么，总感觉这段时间就丢失了，往会看的时候会产生一种失落感。于是找到一种折中的方案，索性把时间跨度拉大一点，一个月写一篇总结。东西就放在简书上，会和博客同步。不管产出的东西多少，希望这个习惯能尽可能长的保持下去。 关于工作七月份一直在维护冥想类的新产品Peace，七月份上的线，一周一个版本，目前是1.3了。从最开始的数据不理想，到分析投放数据，开会讨论找问题，对比竞品，找到问题，指定解决方案，快速迭代，产品在越来越好，数据也在越来越好。我也在这个过程中全程目睹了一个新产品的发展历程，这种体验可以说是一件很棒的事了。但是这段时间也是最忙的一段时期，一周一版一点也不轻松。排期排到周五，就不管多晚周五那天（甚至是已经周六）都要发版的，最晚的一次是战斗到夜里一点。随后老大也调整了策略，多留出一天时间，进行codereview，排期不再那么满，但是快速迭代的节奏还是要一直保持的。说下最近的能力问题，项目中磨练了很多，踩了很多坑，也总结掌握了一些经验，但并不能感觉到自己已经达到了何种地步。都是碎片化的知识点，知识面不系统，也没法找到一个系统的东西去参考，说自己掌握了那些还差那些。直到遇到了技能图谱这个东西，代表个人能力的技能树。于是参考网上的iOS技能图谱，自己做了一个图谱。瞬间思路也清晰了，以后的博客内容，学习内容就可以根据这个东西来了。 关于生活生活方面，园区正在组织篮球赛，我作为篮球队的一员在比赛的一个月之前，就已经开始训练了，一周一次两小时的训练。体育这个东西一直以来也是我心心念的小梦想，怎么说呢，虽然不是运动员，但运动本身总能给我带来不一样的，超出我自身限制的体验。我以前总幻想可能这就是兴趣吧，我喜欢这个，但成熟之后，想法就变成了，体育没那么简单，作为一个爱好就够了。当运动员的梦想渐行渐远时，去年和今年的两场半程马拉松，又把这个心结给勾了出来，两场比赛都完赛时，那种巨大的满足感，只有两个字可以形容，贼舒服！话题拉回来，渐渐的也迎来了篮球联赛的正式比赛，小组赛6进2，我们打了两场，一胜一负。我当了一场主力，虽然表现一般，只为球队贡献了6分，但也算是战斗到最后一刻。很荣幸啦，那种奔跑如风的感觉，观众为自己加油喝彩的感觉，不管结果怎样，我都享受到了比赛了。 关于自己去了趟天津，见自己高中时的死党，大家，一起吃饭喝酒，谈论工作，结婚，房价。想起高中时，我们几个因为食堂没有座位蹲在一起吃饭场景，恍若隔日啊。和女朋友去了趟十渡，玩了标志性的玻璃栈道，高山漂流，抗日英雄纪念馆，十渡风景也很美。其中高山漂流一路冲下来，身上湿了一大半，遇到一个小朋友，说“你们怕水吗？”我还没弄明白怎么回事就说了句“不怕啊”，他就跟妈妈一起开始向我俩泼水了。这熊孩子，跟我刚！当自己放下顾忌，肆无忌惮地疯玩时，这才是真正的快乐吧。关于自身的成长，感觉自己自律性还是差一些，坏习惯多一些，我能感觉到坏习惯对我形成的阻力，但是要完全克服或者完全抹掉还是需要相当一段时间努力的。我也在排除一些对自己产生干扰的外界因素，卸载了手机里让我耗费时间的王者荣耀，刺激战场，头条系产品。当拿起手机发现没什么可玩时，我能感受到自己时间是富余的。就这些吧，希望自己能一直遵从内心，成为那个让自己满意的人。","link":"/2018/08/06/201807-summary/"},{"title":"七院第二天（11月4号）","text":"订饭五点半起床。医生嘱咐手术完第二天需要喝米油（小米粥虑掉小米），还有喝萝卜水。一般来说术后6小时宜服用一些排气类食物，如萝卜汤，帮助因麻醉而停止蠕动的胃肠道保持运作，以肠道排气作为可以进食的标志。 送完这两样东西，我们就在外面等着了。因为这个是整个医院的手术室，大大小小的手术都从这里进入。一上午有陆续五个人先后进入手术室，还有一名孕妈妈，没多久她被推出来要转到别的病房。病床从旁边经过，我看到母亲安静的闭着眼睛，小宝宝被裹的严严实实的只漏一个小脑袋，被放在母亲腿间，后面一群家人跟着病床，多么美好的画面啊！ 中午监护室大夫打电话说爸爸需要喝小米粥，因为不再是米油，就让我高兴了一下。 视频通话下午5点到了探视时间，有一间专门的小小的探视房间，里面有两部电话，两台电视。可以通过这里接通各个病床上面的监视器，看到病人的情况，然后通过电话跟病人对讲。我看到前面两个人的通话场景，一个清晰，一个稍微模糊一点，还跑到了画面清晰的那一对排着。离手术完成已经19个小时了，非常想看看爸爸现在的情况。满怀期待地接通电话之后，大夫说，张中线床头摄像坏了，等会通过护士手机进行视频。 通过护士手机接通视频，看爸爸状态还可以，我问他感觉怎么样，他说，还好。虽然是“还好”但听他声音沙哑，不免还有些担心，不敢跟他讲太多话。问旁边大夫声音沙哑问题，他说全麻手术喉部插管引起的肿胀，需要一段时间的恢复。晚上吃饭还需要喝萝卜水。挂完电话就给爸爸准备萝卜水去了。 把跟爸爸通话的情况拍上照片发给亲戚们，告诉他们恢复的挺好。 开始水滴筹三姨给我打电话催我赶紧弄水滴筹。一开始我是有些抵触这个事情的，因为手术费手术费凑齐了，还有感觉水滴筹这个事情有点抹不开面子。但是想到重症监护室每天一万多的花费，下个月4万的信用卡，再之后的无菌监护室5天，继续住院10天，还有后期每周一次检查，抗排异药要吃好几年，这些都是很大一笔花费。现在筹钱不管多难都比以后为钱发愁好。想通了这些我联系了一个附近水滴筹的对接人，跟他说明了情况，也问了一些他们那边关于审核，筹款，提现的手续。然后就开始了朋友圈里水滴筹。 发出去后我还恍恍惚惚的，很快就会被大家注意到，不知道即将到来的是什么，我甚至都不敢看手机。5分钟后大学室友那几个小伙子联系到我，他们五个齐刷刷的给我打钱，并祝福我爸早日康复。那会回复都回复不过来，被他们的行为感动的不行。真的，我们609无论做什么事都是齐齐整整的，毕业前这样，毕业后也是这样，很多次聚会我们的团结都让其他同学们羡慕，我们是我一辈子的好兄弟。 可能这段时间确实太累了，将近两天基本没怎么休息过，一直在顶着各种压力前进，那么一瞬间因为室友的关怀而放下压力的时候，竟不自觉哭了出来。 再过了一会张弛给我打电话说，你急用钱先借你1万，我刚买完房手头不是很宽裕，如果不够再开口。张弛是高中同学，大学各忙各的基本没怎么交流过，毕业之后又几年了，有事情还惦记着我，真的很感动。 然后再去看水滴筹上面的筹款情况，亲戚，公司领导，同事，同学，朋友都有帮助并留下祝福的话。我翻看着，感觉到一股一股的能量不断注入体内。我会好好加油的，伴着大家的祝福，一定会顺利度过这道难关。 然后跟女朋友打电话，跟她说水滴筹的事情，她表示很理解，还说之前也想过这个事，但感觉我爱面子不会同意。她也很心疼我，看我这样还数落我，你每天工作时间那么长，家里的事还就你一个人扛，工作几年攒的钱全搭进去了，你多大能耐啊。我理解她，因为本来今年许诺她买房结婚的，因为我爸的事肯定也耽误了。其实这一圈最对不起的就是她。她可能也感觉话说重了，又反过来安慰我照顾好自己，照顾好我爸。 不知从什么时候开始，无论发生什么事情，我都不再埋怨，而只是去想怎么处理好它。命运是太不公平了，把一个完整的家破坏的零零碎碎，母亲病故，父亲大病需要治疗，弟弟结婚几年还一事无成，所有的事情都需要我一人承担。之前我也会恨的用拳头砸墙，但是现在不会了，我知道这是我应该做的，我感觉自己可以做到，然后就去做了。","link":"/2019/11/04/2019_11_4/"},{"title":"七院第三天（11月5号）","text":"手术完成就是渡过了最大的难关，其他时间爸爸都是在重症监护室由专门护工照顾的。实际也不需要那么多人手，先后送走了三姨姨父，弟弟，还有两位叔叔，就我自己留在医院。平常需要买什么吃的，里面护士直接给我打电话，我买好送过来。 这天早上是鸡蛋小米粥，已经不需要萝卜水了，中午要吃肉丝面。听到爸爸要吃肉丝面很开心，因为这是除了小米粥鸡蛋之外第一个非常规食物。但是可能是我没考虑周到，面太长了，汤也有点少，他吃的不方便，只吃了两口。之后根据护士交代给他买了一包口香糖。 再晚些时候护士打电话说他想看书。因为里面不让玩手机，也没什么娱乐措施，除了睡觉吃饭没别的事，很容易无聊。附近就一家卖教辅资料的书店，在一堆小学生读物中，我挑了本《中外名人故事》。 下午探视时状态好很多，声音也不再那么沙哑了。感觉状态越来越好了。 三姨一直在家盼着，说你爸有什么情况随时汇报，姥爷每天上午打来一次电话询问情况，大姨，三姨，小姨也都经常打电话过来。 我这几天还是因为睡眠问题，状态不佳，特别是到了下午。困得不行就坐在台阶，往腿上一趴睡着了，但20分钟就醒了，那石板台阶是真的硬。 在监护室外面一直待到晚上十点钟，见里面一直没有消息，就回到了附近租的房子准备休息。洗个澡，躺下睡觉，这可能是近几年来睡得最香的一个晚上了。","link":"/2019/11/05/2019_11_5/"},{"title":"关于996ICU的一些看法","text":"这个项目在有7k多star的时候我就看到有人推了，当时也就是看看而已，了解了这个标识的意思，并没有点进去，更没有star。再之后随着越来越多的star和关注量，公众号、社区、论坛，但凡有程序员的角落，大家都在争先传播着“996ICU”这个概念，每一次转发、star都是对996这种工作制的无声抵抗。 刚才看了一眼star已经12w+，马上就要超过react，这足以说明忍受着996的程序员是多么大的一个群体。我这里不想跟大部分人一样，痛斥996，歌颂这种行为，我想说些不一样的东西。 从自己经历出发吧，2015年刚出来工作的时候是996，当时我并没有不情愿或者觉得累，因为我很清楚自己就是个菜鸟，996可以让自己有更多的时间用来学习东西，提升技术。这种工作节奏持续了大半年，这段时间的感受也是即充实又满足的。后来公司业绩好转，改成大小周，再几个月后又改成双休。当然最开始享受双休的那几天还是很爽的，后来就慢慢习惯了，996前后我的工作状态并没有什么变化。 再后来进了现在的公司，人事告诉我大小周，那时我已经保持了将近一年的双休节奏，稍微犹豫了那么一会，但考虑到公司不错的发展前景，我还是答应进来了。从双休切换到大小周之后，我才意识到双休是多么爽的一件事。。。真的深刻体会到得到了就习以为常，失去了才懂的珍惜的感受。 在我进来不到半年的时间，公司运行的大小周调整为975，因为晚上7点公司提供晚餐，其实开发这边都是吃完饭休息一会再继续回去工作，大约也是9点走，可以说是995。 得知双休之后，我的学习状态也高涨起来了，规划着两天的自由时间可以做很多事情了，睡懒觉、打游戏、学一些自己感兴趣的东西、跑步。然而实际情况却是开始双休之后的很长一段时间里，我完成度最高的是睡懒觉、打游戏，对于学习，健身基本没怎么执行。有那么几个周末我深深地体会到舒适区只要进入，是很难挣脱出来。周末的早上醒来就感觉自己是被封印在床上了一样，除了刷手机什么都不想做，哪都不想去，早上喝水，中午叫外卖，晚上再来一份外卖，一天结束了。 同时我又是一个反省意识很强的人，在虚度了一个周末之后心里就会非常自责。一个被荒废的周末还不如忙碌一天的工作给我带来的满足感，我甚至产生了想要回到996的状态，以此来约束自律性很差的自己。 再后来也就是最近一段时间，为了达成近两个月的OKR，我“如愿以偿”地又回到了996的模式。因为早有准备，多上一天班并没有让我感觉失去多少自由。公司也考虑大家劳逸结合的情况，搭建了台球，乒乓球，Switch游戏机这种娱乐措施。周六加班，也就是做一些修修补补的任务，中午吃完饭会打一会台球，乒乓球，或者玩一会农药，回来继续工作。有时候会感觉周六加班更像是换了一个地方过周末。 但其实我也不是完全接受996的，它解决了我的时间配比问题，但也会给我引起其他不便。比如我想和女朋友周末出去就近玩一下，北京以内还好，如果想出北京就会时间安排不过来。当然还有其他的不便，要知道休息两天和休息一天可是相差一倍呢。 那回到这个话题，996这个制度是否OK呢？ 如果你自律性很强，有很多想法想要实现，也有较好的时间规划，那多一些自己的私人时间是再好不过的了，996对你的确不能让你发挥更大的作用。如果你自律性很差，也没考虑过多出来的时间用来干嘛（玩和睡除外），那我建议你可以先好好想想双休之后你会做什么，双休对你来说生活品质是提高了还是降低了。当然如果你认为自己就是不想加班，只想过平淡恬静的生活，上班对你来说就是为了赚钱，这种想法也没错。因为不是每个程序员都热爱着这份工作，能从中获取到乐趣的，那就换份轻松点的工作呗。我下面讨论的内容对这类人群也是不适用的，你们可以看到这就结束了。 说些不那么中听的话，如果你自律性差，公司的996相当于帮你加了一道屏障，这个时间段它帮你隔开舒适区，迫使你投入到工作中。而我公司也有不少，没有加班任务，时不时也会主动来公司加班的人。那最理想的情况其实就是，公司相信员工，不强制加班，大家想休息了，该休息了就休息，保证把工作效率提上去。员工呢，同时为自己和公司负责，没完成工作，学习新东西，就可以来公司主动加班。 之所以说他理想，是因为很多公司不信任员工，很多员工也没有那种对自己和公司强烈的责任感。所以互联网行业出现这么多的996不是单纯公司的问题，一些程序员也负有一定的责任。 再说一些特殊情况，如果是无良公司，不考虑员工效率问题，各种强制加班，搞996，那我也是坚决反对的。 996ICU项目里有提《劳动法》，标准工时一周最高为48小时，而996是72小时，超标不少；以及超时薪资应为平日工资的150%。这让我想到了大二寒假在电子厂打工的经历，标标准准的按照劳动法来的，基本都是按时薪算的。为什么同样是受劳务合同保护，不同的行业却有着不同的处理方式呢？ 我认为一个重要的原因是，电子厂流水线上的那是标准的工人，计时或者计件，可以清清楚楚的搞清楚。而程序员呢，智力劳动，没法准确的衡量一个人的工作价值。你加班两小时，是因为水平问题还是别的原因，如果是自己原因的话，公司需要付钱吗，这个说不清的。所以是否要按照劳动法付给雇员加班费，存在很多不确定因素，这个是不现实也是不合理的。 我们很多人其实心理也明白，去给996ICU点一个star并不会让自己摆脱996现状。但我们还是那样做了，这其中有一点抗争精神，但抗争之后我希望大家能够更清楚的看待996这个问题。 我更希望996这个含义可以适当拓宽一点，包含我们工作及工作以外提升自我的时间。如果公司要求996，分出一些时间做自己的事情，保证工作学习的82配比。如果不要求996，那就尽可能合理分配时间，保证每周有72小时是投入到这个行业里来的。在这段时间里你可以用来提升自我，或者是听我给你们吹水🙃","link":"/2019/03/31/996-ICU/"},{"title":"可能被忽略的UIButton细节","text":"关于System Button 看一个简单的例子： 12button.setTitle(\"Title\", for: .normal)button.setImage(UIImage(named: \"icon\"), for: .normal) buttonType分别设置为system和custom，仅做如上设置，显示效果对比（上面的custom，下面的是system） ![button_normal](https://ws4.sinaimg.cn/large/006tKfTcgy1ftcrof65cij305x00xa9u.jpg) ![button_system](https://ws1.sinaimg.cn/large/006tKfTcgy1ftcrokww28j305x010q2r.jpg) system Button显示出蓝色其实是tintColor的效果，关于tintColor的说法是： This property has no default effect for buttons with type custom. For custom buttons, you must implement any behavior related to tintColor yourself. 在custom类型的button中设置tintColor是不生效的，需要自定义样式。在system类型的button里有一个默认蓝色的tintColor，当然我们可以修改它为其他颜色，会对image和title同时生效。 另外可以发现image不是原始图片，而是被填充为tintColor的颜色。这是因为system类型下button的image被默认以alwaysTemplate类型渲染的，如果想要显示原始图片可以做如下操作： 12let image = UIImage(named: \"icon\")?.withRenderingMode(.alwaysOriginal)button.setImage(image, for: .normal) 关于触摸反馈 看一个常见的代码： 12345let button = UIButton()//默认样式custombutton.setTitle(\"Title\", for: .normal)button.setTitleColor(UIColor.blue, for: .normal)button.backgroundColor = UIColor.redview.addSubview(button) 以上是的button的常见写法。遗憾的是这种写法，不会带触摸反馈效果。那如果我们想加触摸反馈，需要如何处理： 1、仅文字的触摸反馈12345678//system:let button = UIButton(type: .system)button.setTitleColor(UIColor.blue, for: .normal)//自动添加反馈效果button.setTitleColor(UIColor.green, for: .highlighted)//会和系统效果叠加，不可控，不建议写//customlet button = UIButton(type: .custom)button.setTitleColor(UIColor.blue, for: .normal)button.setTitleColor(UIColor.green, for: .highlighted)//自定义反馈样式 2、带图片和文字的触摸反馈1234button.setTitle(\"Title\", for: .normal)button.setImage(UIImage(named: \"icon\"), for: .normal)//system:会同时对图片文字添加反馈效果//custom:默认仅对图片有触摸反馈 3、带背景图的按钮123button.setBackgroundImage(UIImage(named: \"background\"), for: .normal)//system是按钮整体反馈//custom是仅背景图片反馈，title，image无反馈 4、关闭触摸反馈12345button.isUserInteractionEnabled = false//custome，system均会关闭触摸反馈button.adjustsImageWhenHighlighted = false//custom:会关闭image，backgroundImage的反馈//system:此设置无效 5、showsTouchWhenHighlighted这个属性是系统提供的一种highlighted样式，点击时按钮高亮。但是效果确实有点丑丑的，基本不用这种效果 其他特性全局修改UIButton的样式可以：12let gobalBtn = UIButton.appearance()//所有继承UIView的类都可以使用这个方法gobalBtn.setTitle(\"Good\", for: .normal)//会将所有button的title改为Good setAttributedTitle方法这个方法可以将button的title以富文本的形式进行设置，支持对不同state的设置。需要注意它和setTitle的优先级 123456789//用attributed方式设置button的title和titleColorlet string = \"Title\"let attributed = NSMutableAttributedString(string: string)let range = NSMakeRange(0, string.count)attributed.addAttributes([NSAttributedStringKey.foregroundColor : UIColor.green], range: range)button.setAttributedTitle(attributed, for: .normal)//此时用setTitle重新设置title样式，不会生效，attributed优先级大于直接设置button.setTitle(\"Next Button\", for: .normal)button.setTitleColor(UIColor.blue, for: .normal)","link":"/2018/07/17/UIButton-detail/"},{"title":"处理ANCS设备连接绑定问题","text":"ANCS（Apple Notification Center Service，苹果通知中心）的目的是提供给蓝牙外设一种简单、方便的获取iOS设备通知信息的方式。使得蓝牙手环，手表可以接收到来自iPhone的来电、短信及QQ、微信等应用的通知消息。 如果你已经能够连接普通蓝牙，初次面对ANCS设备可能会有以下问题： 问题一：遵循ANCS协议的的设备会直接和系统相连，即使杀掉应用，连接还是存在的。而如果蓝牙设备处于连接状态，它不会被扫描到，怎么再次连接呢？ 在Core Bluetooth framework里提供了两个方法，用于获取已连接的设备 //通过传入的peripherals.identifier返回与系统连接的已知设备数组 - (NSArray&lt;CBPeripheral *&gt; *)retrievePeripheralsWithIdentifiers:(NSArray&lt;NSUUID *&gt; *)identifiers; //通过传入设备的serviceID返回已连接的设备数组 - (NSArray&lt;CBPeripheral *&gt; *)retrieveConnectedPeripheralsWithServices:(NSArray&lt;CBUUID *&gt; *)serviceUUIDs;我们就可以通过这两个方法，获取已连接设备，并建立重连。参考代码： NSArray *peripherals = [central retrieveConnectedPeripheralsWithServices:@[serviceUUID]]; if (peripherals.count &gt; 0) { CBPeripheral *peripheral = [peripherals firstObject]; peripheral.delegate = self; self.peripheral = peripheral;//**关键**需要转存外设值，才能发起连接 [central connectPeripheral:self.peripheral options:nil]; } else { [central scanForPeripheralsWithServices:@[serviceUUID] options:nil]; }根据不同的使用情况，可能会有不同的扫描，连接的逻辑，苹果提供了一个流程图： 问题二：有绑定和解除功能，如何处理两者的关系 首先我们要知道，不能通过代码，断开ANCS设备与系统之间的连接，那么如果我们想解除设备的绑定，只能控制设备与APP之间的断开。 ###绑定再回看上面提到的苹果提供的两个获取已连接设备的方法，一个是通过serviceUUID，它可以返回同一类型的设备列表；一个是通过设备UUID，它在一定情况下就是唯一的（如果设备名唯一，这里可以使用设备名），返回的是唯一设备。那么我们就可以利用UUID的唯一性，作为绑定的标示，存到NSUserDefault里面，对于未绑定的设备通过serviceUUID去获取设备列表。参考代码： 12345678910111213NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults];NSString *uuidString = [userDefault objectForKey:RWBLE_BANDIDENTIFI_ID]; NSArray *peripherals;if (uuidString) { //通过uuid获取连接设备 NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString]; peripherals = [self.centralManager retrievePeripheralsWithIdentifiers:@[uuid]];}else{ //通过serviceUUID获取连接设备 peripherals = [self.centralManager retrieveConnectedPeripheralsWithServices:@[[CBUUID UUIDWithString:ST_SERVICE_UUID]]];}/* peripherals connect code */ ###解绑不能使ANCS设备与系统连接断开，那么我们就在程序里销毁这个外设对象，这样APP与蓝牙设备的连接通讯就不存在了，造成了一种断开的感觉。参考代码： 12345678//解绑设备- (void)unbindDevice{ [self disconnect];//通知app，设备已经断开 NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults]; [userDefault removeObjectForKey:RWBLE_BANDIDENTIFI_ID];//销毁uuid self.peripheral = nil;} 这么写看似已经解决问题了，但是会出现一种情况：解绑了设备，杀掉应用，再次进入设备还是能连上。why?因为虽然没有了UUID，但进入程序会通过serviceUUID再次获取连接。 这时可以在扫面做一个判断，是否刚解绑过设备。可以是个BOOL值，绑定和初始绑定为NO，解绑操作改为YES。如果刚解绑过设备，就直接返回不做后面的扫描操作，这样就解决了上面的问题。这个比较简单，就不列具体代码了。 参考文档：Best Practices for Interacting with a Remote Peripheral Device","link":"/2016/10/14/ancs-bind/"},{"title":"蓝牙固件升级","text":"###升级介绍 蓝牙固件升级是使用手机给固件进行更新，以达到修复bug，完善功能的作用。升级的大概流程是：首先，当手环的固件需要升级时，由嵌入式开发人员提供新的固件，由服务器管理人员将固件放到服务器上，此时，用户打开手机APP的时候会检测到服务器有更新，请求更新手环固件，确认更新后，手机会从服务器下载固件。下载完毕后，APP会读取固件内容，并根据升级协议将内容传到手环里，完成升级。 DFU = Device Firmware Update （设备固件更新） OTA = Over The Air （空中升级） ###升级流程各个蓝牙设备不尽相同，以下是我测试设备的升级流程：######OTA下载固件从云端下载的固件为.bin后缀的文件，文件名会有一定的格式，含有固件版本号和文件CRC32校验值。######数据分块规定一个数据块大小比如2048字节，然后把升级数据进行分块，不够的就剩余多少作为一块。蓝牙一次发送的数据量是有限的，所以每次发送20字节的数据。这个数据要遵循升级数据格式，带指令头和校验和，下载包的数据只是这20字节中的一部分。所有包内数据都携带在每条升级数据指令中。######升级过程 连接设备，发送升级请求。 待蓝牙确认之后，开始发送数据头告知蓝牙此次发送的数据量和CRC校验。 开始发送升级数据。（每条数据之间间隔20ms为了蓝牙能够方便处理） 待一个块发送完就发送块结束命令 蓝牙确认发送下一个块，返回错误则终止此次升级 发完所有数据之后发送升级完成 蓝牙确认则升级完成，返回错误则升级失败 ######流程图###总结蓝牙升级最复杂的就在升级过程，大量的数据与蓝牙交互，这时最好记录发送到升级数据的那一部分，可以给用户展示升级的进程。","link":"/2016/03/10/bluetooth-ota-upgrade/"},{"title":"基于Hexo搭建自己的博客小屋","text":"作为一名技术人员没有属于自己的博客，就像是喜欢LOL的玩家却没有一款炫酷的皮肤一样，这不叫真爱。虽然现在是微博的时代，讲究方便阅读，易传播，但是对于博客来说，特别是技术博客，专业性永远都是第一位的。我们需要用大大的篇幅去阐述自己对技术的理解并将其分享给其他人，所以无论社交软件如何发展，我们都需要博客。下面就跟着我一块搭建属于自己的博客小屋吧。 搭建环境已经安装Git的Mac电脑，这个默认都能满足，所以就不详细介绍了。 创建github page首先注册github账号，然后在repository选项卡里New一个新的仓库来存储我们的网站 然后命名为username.github.io。 安装Hexo在安装Hexo之前我们需要安装nvm和Node.js。 Hexo是目前很流行的博客管理框架，基于Node.js nvm是Node.js的版本管理工具 而Node.js是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 不太理解和想要深入了解各软件作用的同学可以自行google，接下来我们开始安装这些东西（确实挺多的）。 1、通过curl方式安装node版本管理工具nvm curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash其他方式的安装可以自行google。 2、配置环境变量完成之后nvm就被安装在了~/.nvm下，接下来配置环境变量在~/目录下看是否有.zshrc,.bash_profile,或者.profile,如果没有就新建一个.profile文件。注意：.开头的文件是隐藏文件，在终端查看的时候使用命令ls -a,然后打开对应的配置文件在最后一行加上： export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm这一步的目的是每次新打开一个bash，nvm都会被自动添加到环境变量中。3、验证nvm安装在命令行输入nvm看到如下信息： Node Version Manager Note: &lt;version&gt; refers to any version-like string nvm understands. This includes: - full or partial version numbers, starting with an optional &quot;v&quot; (0.10, v0.1.2, v1) - default (built-in) aliases: node, stable, unstable, iojs, system - custom aliases you define with `nvm alias foo` Usage: nvm help Show this message nvm --version Print out the latest released version of nvm nvm install [-s] &lt;version&gt; Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available --reinstall-packages-from=&lt;version&gt; When installing, reinstall packages installed in &lt;node|iojs|node version number&gt; nvm uninstall &lt;version&gt; Uninstall a version nvm use [--silent] &lt;version&gt; Modify PATH to use &lt;version&gt;. Uses .nvmrc if available nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available nvm run [--silent] &lt;version&gt; [&lt;args&gt;] Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available nvm current Display currently activated version nvm ls List installed versions nvm ls &lt;version&gt; List versions matching a given description (usually `~/.nvm`)那么恭喜你！nvm安装成功了。这一步在我看来是最容易出错的。 4、安装node.js如果上面的步骤完成了，node.js的安装就简单多了，直接： nvm install node这个指令是安装最新版node安装成功后可以使用nvm ls查看当前node版本号 5、安装Hexo安装Hexo也比较简单 sudo npm install hexo-cli -g配置Hexo站点完成所需组建的安装，接下来就要建立本地站点，配置站点了。 1、本地新建博客目录目录可以自由选择，我选择在主目录下： ~$ mkdir username.github.io ~$ cd username.github.io ~$ hexo init username.github.io2、配置站点 在站点下有一个_config.yml，这里我们可以进行一些对博客的配置 language: en #语言设置 theme: next #主题设置，因为下面将使用next主题 deploy: type: git repo: https://github.com/username/username.github.io.git这里的repo就是我们新建仓库的git地址，之后发布的时候就会将内容发布到这个地址下。更多设置可以查看更多Hexo配置 3、配置主题 我使用的是目前最受欢迎的一款Hexo主题Next使用它的话，我们需要先把它clone到本地 $ cd username.github.io $ git clone https://github.com/iissnan/hexo-theme-next themes/next在theme文件夹内也有一个_config.yml文件，这里是用来配置主题的，详细设置 新建、发布博客经过上面的努力终于可以开心的写博客了，Hexo博客是基于Markdown格式编译的，所以，我们需要了解常用的Markdown语法，不了解Markdown的可以点这里参考Markdown，以下命令均在博客站点目录操作 1、新建 hexo new &quot;my blog&quot;文件生成在username/source/_posts/my-blog.md，打开文件，利用markdown语法将内容写到里面。 2、编译 hexo generate //可以简写为hexo g这一步的作用是将刚才的markdown语法的博客内容编译成html语言。编译之后生成public文件夹，里面放的是生成的html文件。之后同步到github上的就是这个文件夹的内容。 3、** 开启本地服务** hexo server //可以简写hexo s这个命令的作用是开启本地服务。之后会有下面两条语句生成 INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.我们就可以访问 http://localhos:4000/预览博客内容了。 4、部署 hexo deploy //可以简写为 hexo d部署的作用就是将博客内容发布到网络。执行完成之后我们就可以访问http://username.github.io了，当你能够看到自己写的内容呈现在自己眼前的时候有没有很激动呢。哈哈 5、清楚public内容 hexo clean 这个命令用在当我们更改source内部的资源路径之后，执行此命令可以重新编译生成public文件夹。 好了，讲解到此结束，下一篇讲解如何发布博客到指定域名。这个是我的博客http://zhangferry.tk，欢迎访问","link":"/2016/12/20/build-blog-by-hexo/"},{"title":"为博客设一个自定义域名","text":"现在越来越多的人悬着使用githubpage搭建自己的个人博客，但是github提供的默认的域名是这种形式：username.github.io，是个二级域名，这对于很多人来说可能感觉不是很酷。那么我们今天就来做一件比较酷的事情，为站点自定义一个域名。 目录 0、准备工作1、域名申请2、为站点添加CNAME3、在DNSPOD配置域名解析4、修改DNS5、验证结果 准备工作 一个完整的github page博客项目。 名词解释：DNS：网域名称系统。你可以把它想象成一张域名和IP地址映射的数据表。DNS解析：就是通过我们输入的网址（域名）查找到对应的主机（IP地址）CNAME重定向：username.github.io和username.tk是两个域名，添加CNAME文件选择首选域，使其指向同一主机。DNS原理&gt;&gt; 申请域名有很多网站都有域名购买服务，我使用的是Freenom。常见的域名注册网站还有万网、腾讯云、GoDaady（狗爹）。我选择Freenom的最主要原因就是：免费+顶级域名。对，你没有听错就是免费的顶级域名，一开始就认为注册域名肯定要花费不少moneyd的人是不是感觉赚到了😉。进入该网站注册成功之后，选择Register a New Domain进行域名申请检验。它可以提供免费的顶级域名有：tk，ml，ga，cf，gq 选择你喜欢的域名，进入选购界面 在Period里面可以选择使用时间，最多是一年的免费使用，顶级域名耶，已经很大的优惠了。当然如果你是土豪这都无所谓了。 为站点添加CNAME文件在Hexo的本地站点里，进入source文件，新建文件CNAME，注意没有后缀，打开文件填入刚申请的域名 zhangferry.tk 保存。然后发布站点，这时CNAME文件就被发布到了github上对应的站点仓库中 CNAME文件的作用：CNAME是一个别名记录，它允许你将多个名字映射到同一台计算机。比如刚才添加的CNAME文件，会被github自动识别，当我们输入zhangferry.github.io和输入zhangferry.tk时，它将指向同一个ip地址，展示同样的内容。 在DNSPOD中配置域名解析注册DNSPOS账号，进入管理控制台 点击添加域名，输入我们刚刚申请的域名。确定之后就是进行添加记录 添加记录的每一项，系统都会提示代表意思，这里主要解释记录类型 A记录：地址记录，用来指定域名的IP地址 CNAME记录：如果需要将域名指向另一个域名，再由另一个域名提供IP地址，就需要添加CNAME记录 NS记录：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录 上面的NS记录是系统默认添加的。 A记录就是指向对应IP地址，这里的192.30.252.153和192.30.252.154是github的服务器IP地址。CNAME记录这里可填可不填，因为A记录已经将zhangferry.tk和zhangferry.github.io的域名统一为一个IP地址了。有一种情况就是为了提高访问速度，要区分国内国外不同用户使用不同的网站进行重定向需要添加对应的CNAME记录。 修改域名DNS再回到刚才的域名申请网站，点Services-&gt;My Domains-&gt;Manage Domain-&gt;Management Tools-&gt;Nameservers 将f1g1ns1.dnspod.net和f1g1ns2.dnspod.net填入到Nameserver1和Nameserver中，点击Change Nameservers保存操作。注意到刚填的域名服务就是对应NS记录的记录值。完成之后稍等片刻，DNSPod会有如下提示，否则就按照提示进行检验哪一步出了问题。 验证结果之后需要等待全球递归DNS服务器刷新（最多72小时）在命令行执行：$ dig zhangferry.tk，出现以下结果说明配置成功，主要IP地址的对应。 参考Hexo博客系列：域名和DNS为你的Github Pages博客绑定一个免费顶级域名吧","link":"/2017/01/05/custom-domain-blog/"},{"title":"iOS获取来电和短信发送状态","text":"获取电话状态在我想要了解iOS获取来电状态时，经常被这是不是允许的，是不是要调用私有库等问题困扰。费了好大劲终于解决了上面问题，你可以获取系统提供的电话相关状态，而且它不属于私有库。为了需要这方面资料的人查阅时少走弯路，我把这些东西写下来，废话少说，上代码。 如何获取电话状态首先要导入CoreTelephony框架：@import CoreTelephony; 然后声明一个CTCallCenter变量： @interface ViewController () { CTCallCenter *center_; //为了避免形成retain cycle而声明的一个变量，指向接收通话中心对象 } @end然后监听电话状态： - (void) aboutCall{ //获取电话接入信息 callCenter.callEventHandler = ^(CTCall *call){ if ([call.callState isEqualToString:CTCallStateDisconnected]){ NSLog(@&quot;Call has been disconnected&quot;); }else if ([call.callState isEqualToString:CTCallStateConnected]){ NSLog(@&quot;Call has just been connected&quot;); }else if([call.callState isEqualToString:CTCallStateIncoming]){ NSLog(@&quot;Call is incoming&quot;); }else if ([call.callState isEqualToString:CTCallStateDialing]){ NSLog(@&quot;call is dialing&quot;); }else{ NSLog(@&quot;Nothing is done&quot;); } }; }还可以获取运营商信息： - (void)getCarrierInfo{ // 获取运营商信息 CTTelephonyNetworkInfo *info = [[CTTelephonyNetworkInfo alloc] init]; CTCarrier *carrier = info.subscriberCellularProvider; NSLog(@&quot;carrier:%@&quot;, [carrier description]); // 如果运营商变化将更新运营商输出 info.subscriberCellularProviderDidUpdateNotifier = ^(CTCarrier *carrier) { NSLog(@&quot;carrier:%@&quot;, [carrier description]); }; // 输出手机的数据业务信息 NSLog(@&quot;Radio Access Technology:%@&quot;, info.currentRadioAccessTechnology); } 当然这样在真机进行测试，以下为输出信息： 2015-12-29 16:34:14.525 RWBLEManagerDemo[1489:543655] carrier:CTCarrier (0x134e065c0) { Carrier name: [中国移动] Mobile Country Code: [460] Mobile Network Code:[07] ISO Country Code:[cn] Allows VOIP? [YES] } 2015-12-29 16:34:14.526 RWBLEManagerDemo[1489:543655] Radio Access Technology:CTRadioAccessTechnologyHSDPA CoreTelephony框架是不是私有库私有框架的目录为：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/PrivateFrameworks/ 可以看出CoreTelephony框架是在frameworks内而不是PrivateFrameworks，所以它是可以放心使用的。网上之所以有说CoreTelephony是私有库，是因为在iOS6的时候是私有框架，后来苹果又给公开了。 获取短信状态关于短信的状态获取，我直接看了#import &lt;MessageUI/MessageUI.h&gt;里面就两个头文件： #import &lt;MessageUI/MFMailComposeViewController.h&gt;#import &lt;MessageUI/MFMessageComposeViewController.h&gt;一个是邮件相关的方法，一个短信相关的方法。进到MFMessageComposeViewController.h有一个枚举值： enum MessageComposeResult { MessageComposeResultCancelled, MessageComposeResultSent, MessageComposeResultFailed };typedef enum MessageComposeResult MessageComposeResult; // available in iPhone 4.0这是表示短信发送状态的值。要使用这个框架发送自己编辑的内容还需要添加代理：MFMessageComposeViewControllerDelegate 代码如下： - (void)showMessageView { if( [MFMessageComposeViewController canSendText] )// 判断设备能不能发送短信 { MFMessageComposeViewController*picker = [[MFMessageComposeViewControlleralloc] init]; // 设置委托 picker.messageComposeDelegate= self; // 默认信息内容 picker.body = @&quot;nihao&quot;; // 默认收件人(可多个) picker.recipients = [NSArray arrayWithObject:@&quot;12345678901&quot;, nil]; [self presentModalViewController:picker animated:YES]; [picker release]; } else { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;提示信息&quot; message:@&quot;该设备不支持短信功能&quot; delegate:self cancelButtonTitle:nil otherButtonTitles:@&quot;确定&quot;, nil]; [alert show]; [alert release]; } } - (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result { switch (result){ case MessageComposeResultCancelled: NSLog(@&quot;取消发送&quot;); break; case MessageComposeResultFailed: NSLog(@&quot;发送失败&quot;); break; case MessageComposeResultSent: NSLog(@&quot;发送成功&quot;); break; default: break; } }对于来短信的通知没有找到，应该是不能获取的。 参考资料 private framework使用http://chenjohney.blog.51cto.com/4132124/1288551 CoreTelephony框架的简单使用http://blog.csdn.net/jymn_chen/article/details/19240903 iOS关于系统短信和电话的调用http://blog.csdn.net/frank_jb/article/details/49815883","link":"/2016/12/12/calling-and-sms-state/"},{"title":"【译】Swift World：设计模式--中介者模式","text":"原文：https://medium.com/swiftworld/swift-world-design-patterns-mediator-e6b3c35d68b0作者：Peng 今天我们讨论一下中介者模式(Mediator)。这次不从抽象定义开始，而是用现实世界中的一个场景来解释它。在一个团队里，有产品经理，开发工程师，质量工程师。当开发完成了某些功能，将代码提交到仓库。相关环节人员，像质量工程师和产品经理需要被通知。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556protocol Collogue { var id: String { get } func send(message: String) func receive(message: String)}class Developer: Collogue { var id: String var qe: QE var pm: PM init(qe: QE, pm: PM) { self.id = \"Developer\" self.qe = qe self.pm = pm } func send(message: String) { qe.receive(message: message) pm.receive(message: message) } func receive(message: String) { print(message) } }class QE: Collogue { var id: String var developer: Developer var pm: PM init(developer: Developer, pm: PM) { self.id = \"QE\" self.developer = developer self.pm = pm } func send(message: String) { developer.receive(message: message) pm.receive(message: message) } func receive(message: String) { print(message) }}class PM: Collogue { var id: String var developer: Developer var qe: QE init(developer: Developer, qe: QE) { self.id = \"PM\" self.developer = developer self.qe = qe } func send(message: String) { developer.receive(message: message) qe.receive(message: message) } func receive(message: String) { print(message) }} 每个角色都需要持有另一个角色的实例，这种连接方式是高耦合的，且很不容易修改。 现在我们需要一个中介者帮助我们简化这个系统。中介者的目的是帮助对象之间相互交流。它让每个对象都是跟自己进行交互而不是其他对象。当前对象不需要持有别的对象，而是持有中介者。这样将解耦系统，它的结构图如下所示： 我们来写一下代码： 12345678910111213141516protocol Mediator { func send(message: String, sender: Colleague)}class TeamMediator: Mediator { var colleagues: [Colleague] = [] func register(colleague: Colleague) { colleagues.append(colleague) } func send(message: String, sender: Colleague) { for colleague in colleagues { if colleague.id != sender.id { colleague.receive(message: message) } } }} 通过持有中介者，那几个角色对象变成了这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protocol Colleague { var id: String { get } var mediator: Mediator { get } func send(message: String) func receive(message: String)}class Developer: Colleague { var id: String var mediator: Mediator init(mediator: Mediator) { self.id = \"Developer\" self.mediator = mediator } func send(message: String) { mediator.send(message: message, sender: self) } func receive(message: String) { print(\"Developer received: \" + message) }}class QE: Colleague { var id: String var mediator: Mediator init(mediator: Mediator) { self.id = \"QE\" self.mediator = mediator } func send(message: String) { mediator.send(message: message, sender: self) } func receive(message: String) { print(\"QE received: \" + message) }}class PM: Colleague { var id: String var mediator: Mediator init(mediator: Mediator) { self.id = \"PM\" self.mediator = mediator } func send(message: String) { mediator.send(message: message, sender: self) } func receive(message: String) { print(\"PM received: \" + message) }} 这样一来，整个结构就变成了下面这样： 让我们用新的方式来使用它： 123456789//usagelet mediator = TeamMediator()let qe = QE(mediator: mediator)let developer = Developer(mediator: mediator)let pm = PM(mediator: mediator)mediator.register(colleague: developer)mediator.register(colleague: qe)mediator.register(colleague: pm)mediator.send(message: \"Hello world!\", sender: developer) 另一个相似的例子就是非常受欢迎的Notification(NSNotification)。你可以在网上找到很多相关的代码。","link":"/2019/08/28/design_pattern_mediator/"},{"title":"艰难的图床优化方案(MWeb+PicGo+Github)","text":"博客写作优化写博客就肯定会遇到插入图片的情况，我之前的做法是先在Boostnote这种Markdown编辑器里面写个草稿，如果有图片就附上图片，然后再粘到简书的web端。当然图片也需要另拖，会生成一个简书的图片链接，相当于把简书作为图床，然后我再把简书排好版的文章发布到自己的博客。。。 当然是很麻烦的方式，这种写法持续了大半年之后，开始寻找更高效的写博客的方式。首先客户端，最终选了MWeb。然后是要解决麻烦的图床问题，因为MWeb内嵌了七牛云图传服务，所以申请了七牛云账号，用了一段时间感觉真是如丝般顺滑。 图床历险记直到我收到了这个： 在七牛云上申请的只是测试域名服务，只有一个月的有效期。如果想继续使用就需要绑定自己的域名，而且这个域名还需要备案。 于是我在腾讯云上注册了两年的zhangferry.com这个域名。填写资料时，我看到系统提示域名要进行备案，备案过程中又发现，要有绑定腾讯云服务才能进行备案。？？我只是要域名并不需要云服务啊。隐约感觉好像被下套了，需要解决的问题一个套一个。我还怀着侥幸的心理看了下腾讯云服务的价格，用不起用不起。。。看到提示说如果不备案域名，三个月后会被回收，有点慌。询问客服之后得知，服务器在国内且没有备案的情况下才会被回收，因为我的博客是搭在Github上的，所以可以不备案，松了一口气，域名保住了。但是，不备案七牛云又不干了，what f。。。 纠结一段时间之后我只能放弃七牛云，寻找其他的图床服务，知乎上有一个总结比较全的文章盘点一下免费好用的图床。原来是有很多免费服务的，感觉找到了解决方案。但是，又是一个但是，图床这个东西，免费就意味着不稳定，万一哪天挂了，图片就都丢了。最后文末有总结：如果打算长期稳定使用请优先选择又拍云或者七牛云，如果是存储并不重要的图片可以使用免费不限大小的SM.MS图床。 再结合我对图床的需求：免费+稳定。SM.MS好像是最接近的方案了，虽然SM.MS知名度不算低，但是我还是有点担心它的稳定性。 再继续找，找到了这个PicGo，一个图床管理工具，顺着PicGo（v2.0.3）我找到了Github作为图床这一方案。Github，对啊，我直接就确认了这种方案。虽然有人说Github图片国内访问会慢一些，但是它肯定能保证数据的稳定性啊。这样图床工具和图床服务都找好了，喜大普奔！ Github图床配置说了很多废话，终于到了这个理想图床的配置阶段了，比较简单。 1、建一个仓库用于存需要上传的图片。这个仓库最好是public的，因为private的仓库，图片链接会带token，这个token又存在过期的问题。 2、获取授权token在Github的Developer setting界面生一个token。记得保存，因为它只会显示一次。 3、配置PicGo根据图示： 4、使用使用也很方便，PicGo有两种方式：屏幕截图截取图片之后，图片会出现在PicGo的待上传列表里面。我们手动点一下会触发上传，上传成功之后，剪贴板会有对应markdown格式的图片文本，直接粘贴可以使用。固定图片我们需要将需要使用的图片拖到PicGo的客户端内手动上传，上传成功之后，会自动复制成markdown文本，可以直接粘贴使用。 终于搞定了，撒花！","link":"/2019/02/20/figure_bed_github/"},{"title":"Git基本操作回顾","text":"作为git最常用的几个命令git status、git add、git commit，我们每天可能都会写个数十遍。但是越是这种我们熟悉的操作，越容易存在一些我们忽略的细节。这篇文章就是用来记录下这些细节，记录我们常用命令中不常用的操作。 在git中编辑过某些文件之后，由于自上次提交后你对它们做了修改，git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 git 时文件的生命周期如下： 回顾完就进入正题 git statusgit status会有以下几种状态 12$ Changes to be committed:$ (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) 表示已经在暂存区，等待添加到工作区。使用git reset命令可以将暂存区的内容移除。 123$ Changes not staged for commit: $ (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)$ (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 有修改, 但是没有被添加到暂存区。使用git add命令可以将文件添加到暂存区，使用git checkout命令可以撤销文件修改。 12$ Untracked files:$ (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) 含有未跟踪文件, 即未纳入版本管理的文件。使用git add可以将文件放入暂存区。 git add添加文件到暂存区 1git add file 添加多个文件到暂存区，空格隔开 1git add file1 file2 使用通配符批量添加documentation目录下的所有txt后缀文件 1git add documentation/*.txt 添加当前目录下的所有git-开头的shell文件 1git add git-*.sh 将修改和以删除的文件添加到暂存区，不包括未被跟踪文件。 1git add -u file git add .和git add -A(即git add –all)区别一.版本导致的差别：1.x版本：（1）.git add -A可以提交未跟踪、修改和删除文件。（2）.git add .可以提交未跟踪和修改文件，但是不处理删除文件。2.x版本：两者功能在提交类型方面是相同的。 二.所在目录不同导致的差异：（1）.git add -A无论在哪个目录执行都会提交相应文件。（2）.git add .只能够提交当前目录或者它后代目录下相应文件。 git commit当我们执行git add命令将文件放到暂存区之后，还需要提交这些暂存到工作区（仓库区），从暂存区-&gt;工作区，的工作就是git commmit来做的。 1234# 提交暂存区到仓库区，message为提交信息git commit -m [message]# 提交可以指定文件git commit [file1] [file2] ... -m [message] 常用的commit扩展命令 123456# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] 以上三条如果不带-m [message]将会在vim的编辑器中添加提交信息。 如果你感觉没有git add,git commit有点麻烦，想直接将修改到工作区，可以用另外一个命令。 12# 会将上次commit之后的变化，直接添加到工作区git commit -a -m [message] git rm1rm file 删除位置：相当于手动右击点删除，只删除了工作区的文件。git status：Changes not staged for commit:恢复：直接用git checkout – file就可以。 1git rm file 它等价于rm file + git add file删除位置：相当于不仅删除了文件，而且还添加到了暂存区。git status：Changes to be committed:。恢复：先git reset，去掉暂存区修改，然后再git checkout – file，恢复文件。 1git rm --cached file 删除位置：从暂存区移除，不删除文件。git status：Changes to be committed:，Untracked files:恢复：git add file","link":"/2018/09/19/git_command/"},{"title":"使用git stash储存和恢复进度","text":"当我们正在当前项目处理一些事情时，有一个需求插进来，使得我们要在别的分支做一些工作。切换分支之前当前任务是需要保存的，但我们并没有完成一个完整的任务，直接commit显得不合适，这时就可以使用git stash命令。stash是储藏的意思，该命令的作用也可以理解为先将当前的修改储藏起来，等我们在其他分支做完必要工作之后可以再回到储藏时的状态。 git stash大致可以分为储存和恢复这两步。 储存储藏当前进度有两条命令： 1git stash 保存当前工作进度，会把暂存区和工作区的改动都保存起来，再次运行git status会发现当前工作区是干净的。 1git stash save &quot;commit message&quot; 是git stash的完整描述，可以为本次保存添加说明。 恢复1git stash list 查看当前保存进度，进度保存可以有多个。 1git stash apply 恢复最近保存的进度，不会删除stash内容 1git stash apply stash@{0} 如果有多个stash，恢复某一个，按时间倒叙排列 1git stash pop 会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。 1git stash drop [stash_id] 删除某一个存储的进度 1git stash clear #删除所有储存进度 删除所有存储进度","link":"/2018/09/04/git_stash/"},{"title":"将黑苹果系统升级至macOS 10.14.4(Mojave)","text":"原有配置操作系统: macOS 10.13.6主板：AORUS MASTER z390CPU: intel core i7-8700显卡：NVIDIA GTX 750内存：Geil 8G * 2硬盘：tigo SSD 240G 如果要升10.14的系统，首先需要确认的是当前显卡是否支持。 可以参照这个表Mojave硬件支持列表（持续更新中） 可以看到GTX 750已经无法驱动了，所以显卡要换。最好换成免驱的，我这里选了RX 560D。 注意事项gtx750是即插即用，而rx560d有专门的供电线，所以更换显卡时一定要注意别忘了插rx560d的供电线。 升级准备不管是装黑苹果还是升级黑苹果都需要有一个启动U盘，它可以在我们系统配置错误无法进入的时候，帮助我们通过U盘进入，然后我们再把配置改回来就行了。 制作启动U盘（大于8G)1、插入U盘2、打开 /Applications/Utilities/Disk Utility（磁盘工具）3、选中U盘4、点击上方 Erase 选项按钮5、你可以修改U盘名称6、Format：选择Mac OS Extended(Journaled)，中文对应：Mac OS扩展(日志)；Scheme：选择GUID Partition Map，中文对应：GUID 分区映射7、点击Erase按钮8、下载UniBeastUniBeast版本要跟系统版本对应，需要注册tonymacx86账号才能下载。9、安装UniBeast，需要把系统需要设置成英文才能进行安装。设置完毕，一路Continue。10、根据提示，选择Installation Type/Bootloader Configuration/Graphics Configuration然后完成，开始Copy系统文件。11、把MultiBeast拖进U盘 翻译自tonymacx86 升级Clover如果想要安装macOS Mojave 10.14，它要求你的Clover Bootloader版本不低于r4515。最新的Clover版本可以在这下载。 升级系统下载好升级程序之后，直接进行安装。会重启两次，之后是较长一段时间的等待（20-30分钟），跟正常macbook升级一样的流程。如果没有意外，那么恭喜你，黑苹果升级成功了。 可能的问题关机无法断电这个问题网上有的说在config文件中的Acpi将FixShutdown选为true，有的说是增加电量修复的efi文件。我都试过，均无效，我看这方面的回答时间都比较久，应该是旧版本的解决方案。新版本只需要将FixShutdown制为false即可。 安装过程卡在最后2分钟或者卡在最开始18分钟在EFI的drivers64UEFI文件中增加OsxAptioFixDrv3-64.efi文件即可。完整的EFI文件，提取码：awxl。 如果因为配置出错无法进入系统在BIOS界面选择U盘启动，即可通过U盘配置的EFI进入系统。然后更改正确设置即可。 重要文件记得备份 Time Machine 免费 Carbon Copy Cloner ￥290.15 Super Duper $27.95 Time Machine因为是苹果自带的功能，而且还免费，比较推荐使用这个。附一份教程 其他问题当然配置黑苹果的机型组合有很多种，可能会遇到各式各样的问题。这里再贴几个可以参考的链接：macOS Mojave 10.14安装中常见的问题及解决方法Hackintosh黑苹果驱动Clover","link":"/2019/05/17/hackintosh_os_update/"},{"title":"一则iOS招聘信息","text":"今天放出一波我司的招聘信息吧，这里只说了iOS的招聘要求。其实还有Android + Unity + 游戏测试等一大波岗位虚位以待，如果有意愿的小伙伴可以私信我哦。 公司介绍乐信圣文（Learnings）是一家全球领先的移动出海应用开发商，致力于未全球用户提供卓越的移动应用。公司成立于2016年2月份，是行业成长最快的企业之一，是Google，Facebook和Apple的全球战略合作伙伴。截至2018年11月，公司产品在全球移动端月活用户超过2000万，累计用户超过3亿；其中70来自欧美地区。 团队规模：150人公司地址：海淀区东升科技园（地铁8号线西小口站） 明星产品-Peace冥想【App Store 2018年11月编辑最爱】【App Stroe 首页《生活解决方案》专题推荐】【App Store 健康健美分类编辑推荐】 “Peace”冥想是一款你的负面情绪排解神器，随时随地帮你在短短5分钟内与自己和解。助眠，减压，它是都市快生活下的一剂良药。 Peace上线不到一年，就表现出了巨大的成长潜力，它的未来将会更加灿烂。 任职要求职位：iOS中高级开发薪资：1530k + 年终奖（16个月薪资）任职要求： 我们期望你有3年以上开发经验，当然如果你能力够强，这条可以忽略。 对数据结构、面向对象、设计模式有一定的认识 具备独立开发一款产品的能力 乐观、主动、具备团队合作精神 福利待遇 双休（非996！） 一日三餐 运动健身（室内台球、乒乓球每周篮球训练） 顶配Macbook Pro + 升降办公桌 零食下午茶 节日福利 不打卡 … 欢迎你的加入有没有心动呢，心动不如行动，有兴趣，有需求的小伙伴赶紧把简历砸过来吧！ 我们有各个技术栈的大牛，可以让你进步更快；我们敢于尝试新技术，一年前就已经使用纯Swift开发项目；我们重视人才，只要你够牛，薪资+年终奖拿到你手软。 来到公司之后，我们将一起经营维护Peace这颗新星产品，一起见证它的成长吧。","link":"/2019/04/12/ios-interview/"},{"title":"快手iOS面经","text":"背景过完年来北京之后，有准备看看机会，也是想了解下市场行情。简历没有投太多，只定向投了头条教育部门、抖音、快手、阿里，这些公司。头条和阿里的简历都没过，肯定是亮点太少吧。只有快手简历过了，快手是三轮技术面+一轮HR面，前两轮技术都比较顺利，到第三轮却栽了，很痛心o(╥﹏╥)o。目前就不考虑换工作了，等下半年再说了，接下来的时间再好好精炼一下。 快手是视频面试，不支持周末，但是可以选择晚上时间，我这几次都是定在了晚上九点。视频面试是通过牛客网进行的，以下是我还记得下来的各轮面试题，对于一些iOS基础知识就不做解答了。 一面1、用递归写一个算法，计算从1到100的和。 12345678910func sum(value: Int) -&gt; Int { if value &lt;= 0 { return 0 } var number = value return value + sum(value: number - 1)}// 计算过程let result = sum(value: 100)print(result) 写完算法之后又围绕着问了几个问题，都是算法基础： 算法的时间复杂度是多少 递归会有什么缺点 不用递归能否实现，复杂度能否降到O(1) 2、property的作用是什么，有哪些关键词，分别是什么含义？ 3、父类的property是如何查找的？ 4、NSArray、NSDictionary应该如何选关键词？ 5、copy和muteCopy有什么区别，深复制和浅复制是什么意思，如何实现深复制？ 6、用runtime做过什么事情？runtime中的方法交换是如何实现的？ 7、讲一下对KVC合KVO的了解，KVC是否会调用setter方法？ 8、__block有什么作用 9、说一下对GCD的了解，它有那些方法，分别是做什么用的？ 10、对二叉树是否了解？ 面试官是想接着问这方面的问题的。我当时说了不了解，然后就没有后续了。 二面1、ARC和MRC的区别，iOS是如何管理引用计数的，什么情况下引用计数加1什么情况引用计数减一？ 2、在MRC下执行[object autorelease]会发生什么，autorelease是如何实现的？ 3、CoreAnimation是如何绘制图像的，动画过程中的frame能否获取到？ 4、谈一下对Runlop的了解？ 5、OC如何实现多继承？ 这个当时没有答好。其实借助于消息转发，protocol和类别都可以间接实现多继承。 6、对设计模式有什么了解，讲一下其中一种是如何使用的。 7、有没有哪个开源库让你用的很舒服，讲一下让你舒服的地方。我这里说了RxSwift中的观察者模式，和响应式编程。然后面试官问，如果要用OC实现一套RxSwift那样的逻辑应该怎么做。我回答的是结合KVO，将一些需要观察的属性，通过KVO进行监听，然后通过block回调出来。 8、一张100*100，RGBA的png图像解压之后占多大内存空间。RGBA &gt; FFFFFFFF &gt; 4字节所以会占用：(100 * 100 * 4) / 1024 = 39KB 9、算法题 题目：给定一个个数字arr，判断数组arr中是否所有的数字都只出现过一次。 这个并没有要求写出来，说是提供思路就行了。我当时给的方案是在便利数组的时候，用一个字典把便利的元素存起来，如果在后面的便利过程中新元素在字典中存在过就说明，有重复数字出现。时间复杂度是O(n)。 当时也问了有没有办法进行优化，我当时想到了将数组转成Set，然后和原数组比较，两个集合的数量是否变化。 10、因为我跟他介绍自己Swift用的多一些，然后问了些Swift跟OC的区别，各自的优缺点。 11、为什么离职，有什么职业规划。 三面1、给定一个Int型数组，用里面的元素组成一个最大数，因为数字可能非常大，用字符串输出。 12输入: [3,30,34,5,9]输出: 9534330 这个是leetcode的179题，难度中等。面试官让先说思路，再去做题。事先说一下这个题我没有做过。当时的思路是用冒泡法进行排序，排序的前提是将较少位数的数字进行循环补齐，例如3和30的比较，变成33和30的比较，34和4的比较变成34和44的比较，然后将结果从大到小整合成字符串输出。 但是做题是却发现没那么简单，位数的补齐对于2位和3位数的比较还需要求位数的最小公倍数，将他们都转成6位数才能比较。在挣扎了5分钟做了就做罢了。 后来再去做这道题，其实这就是一个排序而已，只不过他的规则是按高位优先级更高的原则，而这一点跟字符串的比较保持一致，如果再加一些Swift的高阶函数，就可以写成： 1234567891011func largestNumber(_ nums: [Int]) -&gt; String { let sort = nums.map {\"\\($0)\"}.sorted { (lStr, rStr) -&gt; Bool in return lStr + rStr &gt; rStr + lStr } let result = sort.joined() if result.prefix(1) == \"0\" { return \"0\" } else { return result }} 2、项目中有这么一个方法func findfile(dir: String suffix: String) -&gt; [String] ，可以通过输入文件夹目录，和后缀检索出所需的文件。 例如需要在某个文件中检索txt文件或者mp4文件，那就传入dir和suffix就行了。现在又有一些需求，例如需要检索utf8格式的txt或者h264编码的mp4，也会有一些例如查找最近一周更新过的文件这样的需求，你如何优化这个类，让它满足这些情况？ 我首先想到的是这么多需求不可能一个方法就完成，需要根据不同场景拆出不同的方法，但是这些同属于文件操作，会有一个共同使用的方法就是检索文件。这个方法需要传入文件目录，然后递归的返回当前目录所有文件路径。外部不同场景的调用逻辑就用一个enum完成，不同值对应相同范围的不同种类。 面试官比较关注内部共用的文件检索怎么写，他说子文件如果过多怎么办，如何优化。我有点懵，查找文件至少是要遍历一遍的，子文件过多，这个应该是没法优化的啊。中间卡了一段时间，后来他给了提示说是不是可以用block实现，将文件路径返回出去，由外部决定当前文件是否可用，最终外部的调用类是这个样子。 1234//我的方案//func findDir(_ dir: String) -&gt; [String]//block方案func findDir(_ dir: String, block: ((String) -&gt; Bool)) 我想来确实没毛病，用block返回内容至少不会将该目录的所有文件都由一个对象持有，而前面一堆的铺垫其实也都是为验证block方案的好处。 其实事后想下这个问题没啥难的，这种写法自己也有写过，但当时就是没想起来，可能前面一圈的铺垫给我带偏了吧，说亏也不亏，以后多多努力吧。 总结整体来看，快手的面试题跟我在别处看到的iOS面试题对比要简单些，一面主要是基础知识，二面考察更全面一些，更多让自己谈一些对技术的理解，三面则是更偏实践一些。 算法虽然三轮都有，但相对比较简单，即使写不出来，有思路也是可以的。当然写出来肯定是加分项，所以大家准备面试时，应该都看一下。算法相关的，排序，数组，二叉树，这几类是重点。","link":"/2020/03/28/interview_kuaishou/"},{"title":"iOS中实现JS和OC的交互(Hybrid App)","text":"在项目开发中，我们常常遇到这种情况，一个功能性界面需要分享到其他平台，或者是一个较复杂，原生框架不易实现，需要经常变动的界面，处理这种功能，最优的处理办法就是交给H5来完成了。像这种介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”的应用就被成为Hybrid App。 在iOS端涉及的知识就是JS和OC之间的交互，下面我们逐步学习如何处理这两者交互的问题。##目录 使用JavaScriptCore与JS交互 JavaScriptCore了解 获取JS点击事件（JS调用OC） OC调用JS方法 使用WebViewJavascriptBridge与JS交互 引入WebViewJavascriptBridge JS调用OC OC调用JS ##使用JavaScriptCore与JS交互###JavaScriptCore了解JavaScript和OC交互常用的框架就是这个了，首先我们了解几个概念： JSValue: 代表一个JavaScript实体，一个JSValue可以表示很多JavaScript原始类型例如boolean, integers, doubles，甚至包括对象和函数。 JSContext: 代表JavaScript的运行环境，你需要用JSContext来执行JavaScript代码。所有的JSValue都是捆绑在一个JSContext上的。 JSExport: 这是一个协议，可以用这个协议来将原生对象导出给JavaScript，这样原生对象的属性或方法就成为了JavaScript的属性或方法，非常神奇。JavaScriptCore了解 ###网页内容 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"margin-top: 20px\"&gt; &lt;h2&gt;JavaSript与OC交互&lt;/h2&gt; &lt;input type=\"button\" value=\"Native传值\" onclick=\"Native.call('Native调用')\"&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"button\" value=\"传值测试\" onclick=\"passValue('test')\"&gt; &lt;/div&gt; &lt;script&gt; var alertShow = function(str) { alert(str); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML运行结果： ###获取JS点击事件 我们目的是获取点击方法 第一步导入JavaScriptCore #import &lt;JavaScriptCore/JavaScriptCore.h&gt;第二步加载HTML文件 NSString* path = [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot;]; NSURL* url = [NSURL fileURLWithPath:path]; NSURLRequest* request = [NSURLRequest requestWithURL:url] ; [self.webView loadRequest:request];第三步获取当前页面JSContxt对象 - (void)webViewDidFinishLoad:(UIWebView *)webView { self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; //捕捉异常回调 self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) { context.exception = exceptionValue; NSLog(@&quot;异常信息：%@&quot;, exceptionValue); }; }第四步获取点击事件 有两种添加点击事件的方式 直接调用的函数 1&lt;input type=\"button\" value=\"传值测试\" onclick=\"passValue('test')\"&gt; 如果是第一种情况，比较简单。在代理- (void)webViewDidFinishLoad:(UIWebView *)webView 中加上 123self.context[@\"passValue\"] = ^(NSString *str){ NSLog(@\"%@\",str);}; 如果点击传值按钮，就会调用此block，输出test 第二种：通过native调用的方式 1&lt;input type=\"button\" value=\"Native传值\" onclick=\"Native.call('Native调用')\"&gt; 这种方式需要声明一个JSExport的协议，协议中声明供JS使用的方法： 123456#import &lt;UIKit/UIKit.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@protocol JSObjcDelegate &lt;JSExport&gt;- (void)call:(NSString *)str;@end 然后还要以JSExport协议关联Native方法， 1self.content[@\"Native\"] = self; 在实现文件中实现这个方法 123- (void)call:(NSString *)str{ NSLog(@\"call\");} 此时点击一下Native传值，就会输出Native调用还有一个需要注意的地方是，在JS调用的方法里实现页面跳转时，要回到主线程执行。可以使用GCD方法 123dispatch_async(dispatch_get_main_queue(), ^{ [self.navigationController pushViewController:vc animated:YES];}); 至此，获取JS点击事件的功能就完成了。 ###OC调用JS方法在上面那段HTML里有一个函数alertShow()，是调用弹框并将str值显示出来。那么我们如何调用这个方法呢？第一步、获取这个函数，有两种方法 JSValue *Callback = self.context[@&quot;alertShow&quot;];//第一种方式 JSValue *Callback = [self.context objectForKeyedSubscript:@&quot;alertShow&quot;];//第二种方式第二步、向JS传参 1[Callback callWithArguments:@[@\"OC调用JS方法\"]];//出现一个弹框，`OC调用JS方法` 如果想直接使用JS的方法可以 12NSString *str = @\"alert('OC添加JS提示成功')\";[self.context evaluateScript:str]; ###加载新的URLWebView有一个代理方法，每当需要去加载一个request，就会回调这个方法，让上层决定是否加载。常常一个H5页面会进行不同url之间的跳转，这里截获，进行本地处理。 12345678910111213- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType{ NSString *url = request.URL.absoluteString; NSLog(@\"____%@\",url); if(![self isNetwork]){ //无网情况的一个处理 }else if([url hasSuffix:@\"ios/test\"]){ //do something you want return NO; } return YES;} ##使用WebViewJavascriptBridge与JS交互WebViewJavascriptBridge是一个轻量的用于OC与JS交互的第三方库，使用它可以用CocoaPods导入：pod 'WebViewJavascriptBridge', '~&gt; 5.0'也可以在Github上下载示例工程，将工程文件WebViewJavascriptBridge拖入自己项目中。本节主要介绍使用方法，关于实现原理网上介绍也比较多，感兴趣的同学可以自行了解。 引入WebViewJavascriptBridge 1234567//设置能够进行桥接[WebViewJavascriptBridge enableLogging];//注册handler在Object-C，如果有self.webView.delegate = self。应注释掉，否则注册方法不执行self.bridge = [WebViewJavascriptBridge bridgeForWebView:self.webView];//如果想执行UIWebView的代理方法，需设置[self.bridge setWebViewDelegate:self]; JS调用OCJS调用原生方法getUsername，可以使用如下方式注册。JS需要返回值的可以用responseCallback将返回值传过去 1234[self.bridge registerHandler:@\"getUsername\" handler:^(id data, WVJBResponseCallback responseCallback) { NSLog(@\"%@\",data); responseCallback([self getUsername]);}]; OC调用JSOC调用JS可以使用如下方法实现，如果需要传参，可以写到参数data:里，如果没有参数就传nil 12345//OC调JS的方法[self.bridge callHandler:@\"testJavascriptHandler\" data:nil responseCallback:^(id responseData) { NSLog(@\"ObjC received response: %@\", responseData);}]; 常见的处理JS与OC之间交互的问题，基本就这些了。希望对大家有所帮助，Demo在这里传送门","link":"/2016/08/18/ios-hybrid-app/"},{"title":"《精进》阅后总结","text":"最近刚看完采铜的这本《精进-如何成为一个很厉害的人》，一本很值得推荐的书。这种讲述如何学习，如何自我提升的书很容易一不小心写成空洞的心灵鸡汤。然而我在实际阅读中根本没有这种想法，因为它专业性很强，我感受到的是作者的博学和诚意，还有经常性的好像被点拨了一下的惊喜。没有深入的思考和深厚的学术功底是写不出这种书，推荐大家有机会也仔细地读一读。阅读过程中画了很多自己受启发的观点，也可以说是我读到的这本书中的精华部分，摘录了下来。全书分七个章节，逐一讲述如何成为一个很厉害的人： 时间之尺 林德沃提出的更好地对待时间的十条建议：1、活在当下2、严肃地对待时间3、留意自己拥有的空间并享受它4、反思自己和其他人的时间视角5、从现在出发联结过去6、并不完全沉浸于过去7、指定实现目标的计划8、平衡计划和非计划时间9、视未来存在与当下10、对未来保持积极的态度 需要好好思考一下，如何通过一点一滴的人生增量，完成个人核心竞争力的锻造。 让“远期未来”更加具体，为“近期未来”增加挑战。 把时间花在值得做的事情上。收益指+收益半衰期。 使用时间之尺，审视事件的长期价值，尽可能删减掉非必要事件。 侯世达定律：实际做事花费的时间总比预期要长，即使预期中考虑了侯世达定律。 提升时间使用的“深度”，减少被动式休闲的比例，保持至少一项长期的业余爱好。寻找心中的“巴拿马” 仅仅是好的选择是不够的我们需要的事最好的选择。 一个成熟的人，他的标准来自他的内心。 人不能只为他自己而活。我们必须认知所有的生命都是珍贵的，而我们和所有的生命是结合在一起的。这种认知指引了我们心灵和宇宙的关系。 最近一周，我所做过的最有意义的一件事：____ 永远不要放弃寻找“第三选择”，因为最好的选择，往往来自在更高目标指引下的我们的创造。 婚恋拇指法则：生理上有冲动，精神上受鼓舞，沟通上很流畅。 人生是持续而反复的构造，校正选择，做出建设性的改变。 不管你做了哪个选择，你的某些东西永远不会改变，最终带着你走向目的地的，可能并不是某一个选择，而是那些你不会改变的东西。即刻行动 开始并完成一件事情，比做好它更重要。因为只要开始了，你就有机会把它做得更好。 先把必须要做的小时处理掉，使我们保持积极和从容心态的一剂良方。 “精益创业”有个关键概念叫“最小化可行产品”，它指的是可以使用最少的资源、被最快制作出来的、可执行基本功能的、能被用户使用的实验性产品。创业者应该尽快把最小化可行产品发布出去，然后根据用户使用它的反馈来进行优化，这一过程称为“构建-测量-学习”的循环。 成熟心智的一个特点就是，它能不偏不倚地、公正地对待自己和其他人的意见，既不固步自封也不附和盲从。 多线程工作，首先需要一段专注不受干扰的时间，完成工作中最核心部分的思考。 行动后要及时反思，并梳理这件事情的“反应连”，特别关注其中发生的意外现象。怎样的学习，才能够直面现实 学习，应该以学习者心中的问题未中心，让问题引导着我们去探求答案。 不要只做信息的搬运工，通过解码，深入事物的深层。 伟大的艺术作品，常常有很深厚的内涵和很精巧细微的技法，不论你在哪个或深或浅的层次上解读他，他都能呈现出美妙的意味，但如果你不做一番细心的努力和挖掘，就只能尝到最表层的那一小部分味道。 教育心理学家把在某一领域有专长的人士，分为“常规性专长”和“适应性专长”。 求职分为三个层次：信息、知识和技能、技能是学习的终点，信息和知识是迈向这个终点的路河桥。 利用交替运用意识和潜意识进行创造性思考。向未知的无限逼近 简化思维意味着我们既要简化外界输入的信息，也要简化我们表达出来的信息，更要简化我们一直思考着的信息。 如何过滤没有价值的信息：精选可信赖的信息源、不追逐当下流行或过热的信息、重事实信息，轻观点和评论、定期闭关，屏蔽外界纷扰。 用足够多的资料“喂养”潜意识。 比如整理书柜并更换一种新的图书分类方法，或者改变日常上下班的路线去探索一条从未走过的路线，也可以尝试与不同的同学或同事共进午餐等，这些小变化引起的扰动可能会刺激出我们新的想法。 把思维转化为外显图形，为我们的思考扩展出了一个更大的空间。 现实中的问题，总是牵涉太多的因素，借助矩阵、清单等工具可以完善思考的周密程度。 我知道 我不知道 别人知道 公开区 盲区 别人不知道 隐秘区 未知区 * 为了让思维更好的发散，获得更多的灵感，一是要关掉大脑里评论的空间，而是要适当的引入混乱与随机。 * 一个具有高度可塑性的大脑在良好思维工具的辅助下，在持续不断的行动的打磨中，会强大的超出你的想象。 ## 努力，是一种最需要学习的才能 * 努力不是一场意志力的较量，而是一种需要学习的策略，可以不断学习和优化。 * 在心理学家眼中，“才能”被定义为“自发地重复出现且可悲高效利用的思维、情感或行为模式。” * 以大多数人的努力程度之低，根本轮不到拼天赋。 * 挑战是设计出来的，不断为自己设计“必要的难度”挑战。 * 不痛苦地坚持到底，只有深入下去，才能培养出真正的兴趣。 * 因努力而热爱。 * 把时间投放在一个领域，以尽量高的标准要求自己，培养出非常高的才能。 ## 每一个成功者，都是唯一的 * 创造成功，而不是复制成功。 * 做一个积极的预设判断要优于消极的预设判断。 * 尝试可能会犯错，可能会遭遇失败，但失败是包含信息的，甚至比成功包含的信息量更大。 * 一个自我教育者应该学会定期审视自己的所知和未知，能评估自己所学知识的价值，特别是在实践领域中的价值。 * 在现实世界中思考理论问题，在理论世界中思考现实问题。 * 为大众带来新鲜的见解和启发，形成对公众的影响力。 * 抗拒自己的欲望，或者延迟满足欲望。 * 根据自己的内心需求，而不是外界的认同，作出独立的选择，甚至去做一些酷的事情。 * 如果你找到了一条别人都还没走过的路，只要把这条路走完，你就赢了。","link":"/2018/09/02/jingjin-read-summary/"},{"title":"如何提升Mac下生产效率","text":"工具篇效率神器Alfred可以从Alfred官网下载，免费版没有workflow功能，付费购买Powerpack可以使用。建议大家购买正版，如果想找破解版，网上也有很多，自行搜索。 这有一篇比较详细的Alfred的使用教程，大部分都被涵盖进去了。这里主要介绍几种对开发帮助比较大的workflow插件，官方workflows地址在这里，可以根据需要选择自己喜欢的插件使用。 Youdao其实在开发过程中经常遇到一些与英文打交道的场景，除了系统自带的字典功能，我们常用的就是有道了。直接调起客户端去搜也很方便，但是如果是频繁操作或者是在全屏下操作，还需要跑到有道里面搜一个单词，搜一句话还是会显得麻烦。 这里有一个Youdao的workflow插件。下载地址。安装之后可以通过在Alfred中键入yd {query}调出有道字典，并直接搜索翻译结果。使用Enter复制翻译结果，支持多种语言和句子翻译。 CodeVar生成可用的代码变量，解决你不知道该如何命名一个函数，类型，属性的烦恼。支持小驼峰（xt）、大驼峰（dt）、下划线(xh)、中划线（zh）、常量命名（cl）这几种命名方式。下载地址 Github可以直接在Alfred的输入框搜索github仓库。下载地址 代码片段Snippets。可以将自己常用的代码片段放进去，让后通过快捷键调出Snippets，直接使用代码。 123func test&lt;#Name#&gt;() { &lt;#statements#&gt;} 更多插件Workflow官方插件packal 第一个插件库，好像很久不维护了，很多插件链接都失效了。第二个packal是alfred的一个活跃论坛，比较推荐到这里发现适合你的好东西。另外github，各个博主的推荐文章也有很多，基本你能想到的搜索主题都可以找到对应的workflow插件，这里就不得不佩服社区力量的强大，还有就是这个自定义插件功能做的太棒了。 Dash文档查询，下载地址遇到问题最好的解决方式就是查文档，API描述能消除大部分自己的疑虑，Dash支持几十种语言的文档查询，还支持文档注释，tag功能。 Dash+AlfredDash本身支持很多IDE的插件，其中就包括Alfred插件，可以在Preferences-&gt;Integration中找到Alfred。使用方式如下： 命令和快捷键篇几个常用命令行工具saysay命令可以读出英文 1$ say hello world echoecho是输出命令 12# 输出shell本身的文件名$ echo $0 将一段内容重定向至某一文件 1$ echo \"5.0\" &gt; .swift-version manman命令可以查看某个命令行的详细使用 1$ man echo curlcurl为client url缩写。 123$ curl www.baidu.com #查看网页源码$ curl -i www.baidu.com #显示头文件$ curl -o example.html https://www.example.com #将服务器回应保存成文件 常用终端快捷键 快捷键 含义 Ctrl+a 跳到行首 Ctrl+e 跳到行尾 Ctrl+u 删除光标之前到行首的字符 Ctrl+k 删除光标之前到行尾的字符 Ctrl+w 删除从光标位置前到当前所处单词（Word）的开头 Command+D 垂直分屏 Ctrl+D 关闭垂直分屏 自己动手写一个工具AppleScript编写自动化工具就要选一中脚本语言，这里选择了AppleScript。 这是因为: 它语法简单，并接近自然语言。（没有标点符号） 语法查询十分方便。（系统原生提供语法查询字典） mac自带Script Editor可以实现编写运行并检查语法 mac上主流应用都含有AppleScript的语法支持关于AppleScript这有一份简单的教程。我们摘取其中几点，简要讲下AppleScript的语法。 tell命令123tell application \"Safari\" activateend tell 告诉Safari启动。tell命令可以嵌套使用。 set命令定义变量到剪贴板。 1set myVariables to clipboard AppleScript SuiteAppleScript Suite就是 AppleScript 类（class），及其元素（element）和属性（property）的集合。这个就是OmniFocus在AppleScript上定义的Suite。 脚本字典打开「脚本编辑器」 → 新建一个脚本 → 用快捷键 Command+Shift+O 打开 AppleScript 字典（Dictionary）。这个打开之后就能看到各个应用的Suite，我们可以通过这些说明，来完成功能的使用。 编写脚本有了上面的基础我们来编写一个选中文件夹，然后让iTerm2跳转到指定目录的脚本。 定位文件路径12345678tell application \"Finder\" set pathFile to selection as text --POSIX是mac中的根目录变量 set pathFile to get POSIX path of pathFile --防止目录存在空格跳转不了 set pathFile to quoted form of pathFile set pathFile to \"cd \" &amp; pathFileend tell 现在我们通过tell和set命令已经获取到了cd pathFile这段文本。 在iTerm中输入命令上一步获取到了文本命令，接下来我们需要将这段命令在iTerm中执行。那怎么将上面的文本写入iTerm中呢？ 大致思路为：打开iTerm &gt; 创建窗口 &gt; 写入命令。 接下来就是如何实现这几个步骤，通过查看iTerm的Suite:我们可以找到create window with default profile，write命令。有可能这就是我们需要的也有可能不是，所以有些时候是需要尝试出来的。最终实现上面步骤的代码为： 123456tell application \"iTerm\" create window with default profile tell current session of current window write text pathFile end tellend tell 然后完整代码为： 12345678910111213tell application \"Finder\" -- get selection path set pathFile to selection as text set pathFile to get POSIX path of pathFile -- fix space problem in the directory set pathFile to quoted form of pathFile tell application \"iTerm\" create window with default profile tell current session of current window write text pathFile end tell end tellend tell AppleScript+Alfred上面过程我们编写了脚本，但是怎么方便的使用它呢？可以利用Alfred。在workflow中，我们增加一个Hotkeys。 然后绑定快捷键Command+O，从快捷键脱出一条线，选择Actions &gt; Run Script，选择Language为AS(AppleScript)，粘贴我们刚才写的代码，保存即可。 之后我们可以选中文件夹，触发热键Command+O就能直接在iTerm中定位至改目录了。","link":"/2019/11/02/mac_efficiency_promotion/"},{"title":"iOS开发月报#1|201807","text":"关闭隐式动画1234CATransaction.begin()CATransaction.setDisableActions(true)self.layer.frame = self.boundsCATransaction.commit() AVPlayer出现一直缓存，缓存一段时间之后才开始播放的问题1player.automaticallyWaitsToMinimizeStalling = false//延迟播放，默认开 关于这个属性的一些说明： In versions of iOS prior to iOS 10.0 and versions of OS X prior to 10.12, this property is unavailable, and the behavior of the AVPlayer corresponds to the type of content being played. For streaming content, including HTTP Live Streaming, the AVPlayer acts as if automaticallyWaitsToMinimizeStalling is YES. For file-based content, including file-based content accessed via progressive http download, the AVPlayer acts as if automaticallyWaitsToMinimizeStalling is NO. 大致是说在iOS10之前的客户端，虽然这个参数不可用，但是非流媒体类型的播放这个配置默认为false，所以在iOS10下建议这个属性值为false。 AVPlayer是否正在播放的判断当我们使用KVO监听player.rate来判断player的是否正在播放时，会发现这个值是不准的。其实准确的说是player.rate=1不代表正在播放，player.rate=0是可以代表正在暂停的。所以player.rate=0代表暂停，正在播放的状态可以这样判断： 12345678self.timeObserve = self.player.addPeriodicTimeObserver(forInterval: CMTimeMake(1, 1),queue: DispatchQueue.main,using: {(time) inif self.player.timeControlStatus == AVPlayerTimeControlStatus.playing {//AVPlayerTimeControlStatus为iOS之后的APIself.state = .playing}}) 下载时URLSessionConfiguration的配置使用Alamofire下载时，我们通常需要一个SessionManager配置下载参数： 1234567let configuration = URLSessionConfiguration.defaultconfiguration.timeoutIntervalForRequest = 50//50s超时/** 最大同时下载数 ---- iOS对于同一个IP服务器的并发最大默认为4，OS X为6 */configuration.httpMaximumConnectionsPerHost = 4/** A Boolean value that indicates whether TCP connections should be kept open when the app moves to the background. */configuration.shouldUseExtendedBackgroundIdleMode = true//为true支持后台下载manager = Alamofire.SessionManager(configuration: configuration) 不要存储沙盒绝对地址当我们向沙盒写入数据时，将该绝对路径保存下来，下次再打开该地址并不会获取到我们存入的数据。原因如下： iOS8之后，苹果添加的新特性，将每次打开app内的沙盒［唯一编码路径］（红框部分）重新生成，并保持上一次的沙盒文件（Documents、Library、tmp）移到新生成的文件内，旧文件删除，就是说，你保存的文件都在，只不过每次打开后，都会有一个新的绝对路径。所以存储路径应该存相对路径： 123//这两个都代表document的相对路径let rootPath = NSHomeDirectory() + \"/Documents/\"let rootPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first childViewController的viewDidAppear方法调用如果一个ViewController中嵌套了多个childViewController。当宿主VC（我们暂且这么称呼它）调用viewDidAppear等方法时，其中的childViewController都会默认调用对应方法。如果我们不想childViewController调用该方法可以重写该VC的属性： 123override var shouldAutomaticallyForwardAppearanceMethods: Bool {return false} 图片切换渐入渐出的方法通过UIImageView展示图片和layer.contents展示图片都可以使用以下方法： 12345let transition = CATransition()transition.duration = 0.5transition.type = kCATransitionFadeself.view.layer.add(transition, forKey: \"layer.contents\")self.view.layer.contents = image.cgImage//适用于imageView cell移出视图，移入视图的方法12345678//TableViewCelloverride func prepareForReuse() {super.prepareForReuse()//使用重用池的cell,显示过的cell移至可视范围}//TableViewfunc tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) {//cell移出视图时调用} tableview,collectionView数据reload之后的操作我们如果要想实现在reload之后弹出alertView，或者滚动到特定一行，可能会直接写： 12tableView.reloadData()tableView.scrollToRow(at: indexPath, at: .middle, animated: true) 看似没问题，但是滚动没起作用，因为reloadData是立即返回的，不会等tableview刷新完成。解决办法就是需要等reload完成之后再做我们需要的操作，reload是否完成有几种方式监听： 12345678910111213//collectionViewcollectionView.performBatchUpdates(nil) { (finished) in //reload完成}//tableView方法只有iOS11可用tableView.performBatchUpdates(nil) { (finished) in //reload完成}//替代func beginUpdates()，func endUpdates()//tableView等reload完成还可以使用tableView.reloadData()DispatchQueue.main.async { //reload完成}","link":"/2018/08/02/monthly_1/"},{"title":"iOS开发月报#10|201904","text":"这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。欢迎推荐内容，可以前往zhangferry/iOSMonthlyReport提交issue。 Tips关于分享中的一些问题微博 多媒体内容的缩略图，即thumbnialData的大小应小于32K。否则会导致分享失败 微博分享的AppStore下载链接无法打开，这是因为微博屏蔽了指向AppStore的链接。一个可行的做法的将微博的下载链接增加一个引导页，提醒用户通过Safari打开。 微信 多媒体缩略图不能超过64K。 微信分享从6.7.2之后无法获知是否真的分享成功。这个是官方的调整，旨在减少“强制分享至不同群”等滥用分享能力。 facebook关于facebook分享的采坑可以查看这篇文章，基本也都是我遇到的问题。iOS Facebook 分享中的坑 Twitter相同内容分享两次之后再分享将失败。 SWIFT_VERSION ‘5.0’ is unsupported, supported versions are: 3.0, 4.0, 4.2. (in target ‘SwiftyJSON’)这个问题是多人写作开发引起的，有一个同事将SwiftJSON的版本升级至4.3.0，使其支持Swift5.0，但是Swift5.0跟Swift4.0+不兼容，导致出现上面的错误提示。 修复方式，手动指定SwiftJSON版本，使其低于或者等于4.2.0。 1pod 'SwiftyJSON', '~&gt; 4.2.0' Encountered an unknown error (Unable to find a specification for FrameworkA depended upon by FrameworkBFrameworkA和FrameworkB都是私有的Cocoapods库，在制作FrameworkA时引用了FrameworkB，如果执行pod spec lint就会出现如上的提示，到时lint无法通过。 这是因为lint在对引用库验证时，默认只验证官网的仓库，我们需要手动添加验证源才能通过，方法是： 1pod spec lint --sources=git@bitbucket.org:company/privateRepo.git,https://github.com/CocoaPods/Specs --allow-warnings Tabbar的初始化会立即调用viewDidLoad方法正常当我们初始一个UIViewController的时候，总是先执行init方法，执行完之后才会调用viewDidLoad方法。但是如果是UITabbarViewController的初始化则不同，它会在执行init方法的时候立即调用viewDidLoad。 来自Stack Overflow的解释： 123UITabBarControllers call loadView inside [super init] method, which causes the call to viewDidLoad. So the viewDidLoad method will be called before init has finished its job.If you have some thing to setup in viewDidLoad you should perhaps do it inside init method after the call to [super init]. AppleScript打印换行当我使用AppleScript编辑一段脚本时，有一个需求是打印一段换行的文本，试了很多方案，包括\\n,\\r, ASCII码等都不行，脚本执行时会忽略\\符合自动换行，分开执行输入内容。 最后在不断尝试中找到了一种方案，直接敲出换行，如下，在变量_input后拼接一个换行符： 12tell note1 to append text \"[*]\" &amp; _input &amp; \"\" 由于第三方SDK使用了用于定位的功能，导致收到苹果的隐私警告邮件后来定位的到的原因是Facebook相关的几个库均使用了CoreLocation，也就是说Facebook有偷偷使用用户地理位置权限的嫌疑。当然联系他们提供不带此功能的SDK也不显示，后来在react的issuse中也发现了对于此问题的讨论。#20879 解决方案如下，即增加对应的隐私条款选项： 违反Guideline2.3.1被打回在一次小版本提交时，遇到了这个违反Guideline2.3.1被打回的问题，也是第一次遇到。原因描述是含有模糊代码，选择器错误或者误导审核的功能。实际排查中我们并未猜想到哪里可能导致这些问题。 后来通过邮件跟审核人员沟通，得到如下回复：问题又好了？猜想可能是苹果审核的问题，他们也是会犯错误的。 后来在网上查过这种问题的处理情况，从资料时间来看，可以确定这个是最近一年才出现过的问题。处理方法是，首先是应该跟审核人员联系，让他们告知是哪里的问题；然后再根据情况进行修改。 推荐阅读作为面试官，哪类 iOS 开发更容易被你青睐？来自老司机团队的文章，正在找工作的你肯定能从中有所收获。 再贴一个我司的招聘信息，有意愿的小伙伴赶紧简历投过来。 用户端智能的应用实践bang写的关于应用功能优化的几个点，根据用户的特征推荐金额，根据用户使用习惯调整push的时间，有些方案不一定能够为我们所用但是解决问题的思路还是挺不错的。 谈Linux，Windows,和Mac王垠的博客其实已经被删除了，这个是网络留存的快照文件。牛B的人总是能留下牛B的话，这是王垠关于Linux、Windows和Mac的看法。 Swift语言的设计错误123let shoppingList = [\"Eggs\", \"Milk\"]//这么写应不应该报错？shoppingList[0] = \"Salad\" 关于以上问题的讨论。当前Swift是不允许对let生命的数字修改内部元素的。在王垠看来这是一个低级的错误，具体为什么这么定义“不对”，可以看文章讨论。 音视频GithubiOS-Source-ProbeiOS源码探求系列，是iOS相关源码的分析合集。 AutoInch优雅的iPhone全尺寸/等比例精准适配工具，可以通过设置一个屏幕的尺寸值，而自动配置其他尺寸值。支持代码和xib两种方式。 SwiftTips作者总结的Swift使用中的一些小技巧，和喵神的《100 个 Swift 必备 tips》有异曲同工之妙。作为一名刚入门的Swifter，这两个资料都是非常推荐看一看的。 ZFPlayer非常全面的一款iOS播放器，支持AVPlayer和ijkplayer两种播放模块。项目包含主流的视频播放场景，抖音、微博短视频等样式。如果是对视频功能有需求的小伙伴非常建议看一看。","link":"/2019/04/30/monthly_10/"},{"title":"iOS开发月报#11|201905","text":"这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。欢迎推荐内容，可以前往zhangferry/iOSMonthlyReport提交issue。 Tips对UISearchBar样式的修改1、完成一次搜索之后，调用 1searchBar.resignFirstResponder() 隐藏键盘，会将searchBar的取消按钮默认置为disEnable。如果我们需要此时能够监听取消按钮的点击状态，需要恢复其可用状态: 123if let cancelButton = searchBar.value(forKey: &quot;cancelButton&quot;) as? UIButton cancelButton.isEnabled = true} 2、修改取消按钮的文案 12//修改searchbar的取消按钮文案searchBar.setValue(\"delete\", forKey: \"cancelButtonText\") 3、更改取消按钮文案样式 12UIBarButtonItem.appearance(whenContainedInInstancesOf: [UISearchBar.self]) .setTitleTextAttributes([NSAttributedString.Key.font: UIFont.systemFont(ofSize: 15)], for: .normal) 4、更改searchBar文本框文字样式 12UITextField.appearance(whenContainedInInstancesOf: [UISearchBar.self]) .defaultTextAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 15)] 上传IAP时出现TCP 443问题具体错误为： Communication error. Please use diagnostic mode to check connectivity. You need to have outbound access to TCP port 443. 这是由于代理问题引起的上传错误，上传IAP至App Store Connect不需要代理，关掉代理继续上传就可以了。 上传IAP时出现：WARNING ITMS-90176完整错误为： WARNING ITMS-90176: “Unrecognized Locale - The locale names used in localization directories at ( “Payload/sandbox.app/AccountKitStrings.bundle/Resources/cb_IQ.lproj” ) are invalid. iTunes supports BCP47 but not the UN M.49 specification. Refer to the Language and Locale Designations guide at https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPInternational/LanguageandLocaleIDs/LanguageandLocaleIDs.html for more information on naming your language-specific directories.” 该错误是由Xcode9不再兼容cb_IQ.lproj这个格式，所以只要一出AccountKitStrings.bundle中的cb_IQ.lproj文件即可。 推荐阅读Core Image 之自定义 Filter~非常详细的介绍Core Image中Filter(滤镜)涉及的概念和使用方法。作者是美图的iOS开发工程师，博客多讲解图像处理相关知识，是iOS图像领域的大牛，推荐关注。 iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，OpenCV等对于刚接触iOS图形相关框架的小白，有一些图形框架在字面上和功能上非常容易混淆。这里旨在总结一下各种框架，区分它们的概念和功能，以作日后进一步细分学习的指引。 Swift 5 字符串插值之美Swift5除了ABI稳定并没有带来很多语法上的变化，你如果以为Swift5只有ABI稳定那你就错了，它还带来了一个很强的特性—字符串插值。一开始我还以为它是一个小特性，但是当我把它和AttributedStrings, sql联系到一块时，我才发现他的强大之处！ 还有一篇将字符串插值应用到AttributedStrings上的文章: StringInterpolation in Swift 5 — AttributedStrings 如何选择开源许可证关于几种常见开源许可证的区别： GithubPython-100-DaysPython - 100天从新手到大师。作为一线移动端开发，或多或少都有着一个全栈的目标，而作为后端语言的Python无疑是最佳选择。一个star数多达3w+的Python教学项目，这足以说明Python的受欢迎程度，这份教程的受欢迎程度。 markdown-weixin一个在线将 Markdown 转换为微信公众帐号文章格式的工具。http://md.qikqiak.com/ AssetsExtractor『Assets提取工具』是一款OSX平台上用于将Assets.car或xxx.app中打包的png图片、pdf等资源重新提取出来的开发者工具。Assets.car常见于iOS/Mac/Unity等开发中的资源打包。 awesome-ios-bluetooth一个收集开发iOS蓝牙功能资料的仓库。从入门必读、蓝牙升级、ANCS、调试工具都有介绍。目前该库由我维护，大家有什么蓝牙相关的问题可以提issue给我。 firefox-ios火狐浏览器的iOS开源库，由Swift4.2编写。是一个优秀的可供参考学习的开源项目。","link":"/2019/06/03/monthly_11/"},{"title":"iOS开发月报#5|201811","text":"大事件11月27号，苹果AppStore下架包括拼多多、搜狗地图、讯飞阅读和悦跑圈在内的共718个App。据称下架原因是触发了AppStroe审核指南的2.5.2条例，即使用了热更新技术。去年6月份，苹果层因热更新下架数万款App。 Tips图片渲染开销我们知道，解压后的图片是由无数像素数据组成。每个像素点通常包括红、绿、蓝和 alpha 数据，每个值都是 8 位（0–255），因此一个像素通常会占用 4 个字节（32 bit per pixel。少数专业的 app 可能会用更大的空间来表示色深，消耗的内存会相应线性增加）。 下面我们来计算一些通常的图片开销： 普通图片大小，如 500 * 600 * 32bpp = 1MB跟 iPhone X 屏幕一样大的：1125 * 2436 * 32bpp = 10MB即刻中允许最大的图片，总像素不超过1500w：15000000 * 32bpp = 57MB有了大致的概念，以后看到一张图能简单预估，大概会吃掉多少内存。 关于iOS开发证书在钥匙串没有秘钥的问题当前现象 只需要将证书拖到登录，即可生成秘钥 APP内切换语言APP内切换语言有一种比较简单的实现方式，实现步骤是：1、存储语言状态2、刷新KeyWindow.rootViewController3、刷新Bundle4、切换语言对应的更新操作实现过程： 123456789101112131415161718192021222324252627282930313233//1、切换语言，AppleLanguages对应内容是数组，语言符合可以通过Bundle.main.localizations查看//切换至繁体中文，存储状态UserDefaults.standard.set([\"zh-Hant\"], forKey: \"AppleLanguages\")//2、刷新keyWindow，createRootViewController为创建rootViewController的方法UIApplication.shared.keyWindow?.rootViewController = Application.shared.createRootViewController()//3、更换bundle//在切换语言的时候，我们需要执行一下，Bundle的exchangeBundle方法extension Bundle { static func getLocalizedBundle() -&gt; Bundle { if let languages = UserDefaults.standard.object(forKey: \"AppleLanguages\") as? [String], let lan = languages.first, let path = Bundle.main.path(forResource: lan, ofType: \"lproj\"), let bundle = Bundle.init(path: path){ return bundle } else { return Bundle.main } } static func exchangeBundle(){ //替换Bundle.main为自定义的BundleLocal object_setClass(Bundle.main, BundleLocal.self) }}class BundleLocal: Bundle { override func localizedString(forKey key: String, value: String?, table tableName: String?) -&gt; String { return Bundle.getLocalizedBundle().localizedString(forKey: key, value: value, table: tableName) }}//4、其他更新操作，如接口，UI界面 测试内购时长当我们测试内购时，需要考虑内购到期的情况。比如我测试购买了一个月的服务，那么购买到期的情况呢，不能傻傻地等一个月时间吧？其实苹果给出了不同内购时长在Debug情况下对应的测试时间。 AVPlayer进入前台自动播放在我们不进行任何前后台设置的情况下，AVPlayer进入后台，会自动暂停播放。再次回到前台时，播放器会有一定概率自动恢复播放（多大概率未知，测试得出的结论）。 如果这个恢复播放不是我们需要的，或者我们需要避免这种不确定的情况发生，我们可以手动管理这个过程： 12345678910111213NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification, object: self, queue: nil) { (notification) in self.player.pause()} NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification, object: self, queue: nil) { (notification) in //根据需要是否需要恢复播放 if shouleRecoverPlayer { self.player.play() } else { self.player.pause() } } iOS12.1关于tabbar的一个bug触发条件： 使用 UITabBarController + UINavigationController 组合 UITabBar带半透明效果，isTranslucent 属性为 true UIViewController的 hidesBottomBarWhenPushed 属性为 true 通过导航栏返回上一页时(导航栏返回按钮 or 屏幕左侧的滑动返回手势) 问题现象： 经确认是iOS12.1上的一个bug。解决方案： 123//MARK: - fix ios12.1 tabbar buglet tabbar = UITabBar.appearance()tabbar.isTranslucent = false 详细内容可以参考：修复 iOS12.1 UITabBar 布局位移bug - ZHFDBK的博客 - CSDN博客swift - UITabBar items jumping on back navigation on iOS 12.1 - Stack Overflow 推荐内容重构Swift中的Identifiers面对越来越多的identifier，改如何优雅地处理？文中讲了一些UITableViewCell、UICollectionViewCell、segues、UIStoryboards、UIViewController中关于identifiers的重构方法。 The End Is Near for Mobile Apps移动应用的末日将要来临？Medium科技板块最近比较火的一篇文章，分上下两篇，讲述移动应用的前景和趋势。 Realm学院这是Realm建立的一个用于学习编程技术的网站，主要方式是视频，内容配有字幕，并且都全部整理成文章。涵盖范围有Realm, Android, iOS, JavaScript, Architecture等。 文章质量非常高！ 开发利器KTVHTTPCache应该是iOS端目前最好的流媒体缓存框架了。 RealmRealm是一个开源的对象数据库管理系统，最初用于移动(Android/iOS)，也可用于Xamarin或React Native等平台，等平台，包括桌面应用(Windows)，并获得Apache许可。 对比FMDB，他的使用成本，维护成本都更低。 uToolsuTools是一个极简、插件化、跨平台的现代化桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。通过快捷键（默认alt+space）就可以快速呼出这个搜索框。它相当聪明，可以支持输入、拖拽、自动粘贴等作为输入源，相应的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到正确的结果。当你熟悉它后，能够为你节约大量时间，让你可以更加专注的改变世界。 对比Alfred，他的不同就在于免费，使用简单，更符合国人的习惯。","link":"/2018/12/01/monthly_5/"},{"title":"iOS开发月报#3|201809","text":"新机发布，你中意XS Max还是XR？ iOS Tips在label中插入图片1234567891011let label = UILabel()let attribute = NSMutableAttributedString(string: \"Title\")let imgAttch = NSTextAttachment()imgAttch.image = image//设置图片大小imgAttch.bounds = CGRect.init(x: 0, y: 0, width: 18, height: 15)let imageAttribute = NSAttributedString(attachment: imgAttch)//图片插入位置attribute.insert(imageAttribute, at: 0)label.attributedText = attribute CollectionCell阴影+圆角的优雅处理方式只针对类似App Store的整体圆角阴影的效果。 123456789//设置父视图阴影效果//CollectionView.swiftself.layer.shadowOffset = offsetself.layer.shadowColor = color.cgColorself.layer.shadowRadius = radiusself.layer.shadowOpacity = opacitycontentView.layer.cornerRadius = radius//如果切割圆角带imageView才需要添加下面contentView.layer.masksToBounds = true 处理tableView点击时label背景色消失问题123456789//第一种方式，UITableViewCell.swiftoverride func setHighlighted(_ highlighted: Bool, animated: Bool) {let color = self.indexLabel.backgroundColorsuper.setHighlighted(highlighted, animated: animated)self.indexLabel.backgroundColor = color}//第二种方式cell.textLabel.backgroundColor = UIColor.clearcell.textLabel.layer.backgroundColor = UIColor.red 调整UILabel文字的内边距自定义UILabel，然后重写drawText:方法 1234override func drawText(in rect: CGRect) { let insets = UIEdgeInsets.init(top: 20, left: 20, bottom: 20, right: 20) super.drawText(in: UIEdgeInsetsInsetRect(rect, insets))} swift 浮点数取整ceil(x)返回不小于x的最小整数值。floor(x)返回不大于x的最大整数值。round(x)返回x的四舍五入整数值。 1234let number1 = 12.456// ceil(number1) = 13.0, floor(number1) = 12.0, round(number1) = 12.0let number2 = 12.756// ceil(number2) = 13.0, floor(number2) = 12.0, round(number2) = 13.0 跳过非store下载的应用检查xattr -d com.apple.quarantine app所在路径 加载大图导致内存暴涨large_leaves_70mp.jpg图片是7033x10110(占用磁盘大小8.3MB)，分辨率 = 7033 x 10110 x 4（ARGB）,对应位图占用大小 = 分辨率 x 1024 x 1024 ( = 271MB)，解压会把图片转成位图，也就意味着会占用271MB内存，所以解压过程内存会瞬间消耗很大,等转成NSData后位图的内存就会被回收掉，内存就降下来，这时候NSData占用的大小即是图片的实际大小，该过程中由于会转成位图，而位图的大小是比图片的实际的大小大很多的，内存暴增的点就在位图。位图的内存大小计算是根据图片的分辨率而来（分辨率(width x heigth) x 1024 x 1024 x 4 (ARGB)），所以一般来说图片分辨率越高转成的位图占用的内存空间越大。 新版iphone尺寸 设备 逻辑分辨率 比例因子 对角线 分辨率 iPhone XS Max 414×896 @3x 6.5inch 1242px × 2688px iPhone XS 375×812 @3x 5.8inch 1125px × 2436px iPhone XR 414×896 @2x 6.1inch 828px × 1792px iPhone X 375×812 @3x 5.8inch 1125px × 2436px iPhone 8 Plus 414×736 @3x 5.5inch 1242px × 2208px iPhone 8 375×667 @3x 4.7inch 750px × 1334px iPhone SE 320×568 @2x 4inch 640px × 1136px iPhone 4 320×480 @2x 3.5inch 640px × 960px 带透明度的渐变使用CAGradientLayer进行渐变的时候，如果我们需要由一个颜色渐变至透明，当我们将透明色写成UIColor.clear或者其他通过RGBA设置的颜色，改变透明度为0时，会发现实际效果跟预期有出入，会带点黑色： 这是因为clearColor会有一个透明度为0的黑色通道。所以应该这样设置透明色： 1UIColor(white: 1, alpha: 0).cgColor 指定tableView，collectionView的header高度0如果我们想隐藏headerView可能会直接在其高度的代理方法，做如下设置： 123func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat {return 0} 当实际上这并不会生效，会返回一个默认高度。也就是说这个高度只有设置成一个非0的正数才是有效的。有些人会写成0.01，表面上看是解决问题了，但0.01的偏移会造成像素不对齐（Color Misaligned Images），加重CPU计算负荷。完美的解决方案是： 123func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat {return CGFloat.leastNonzeroMagnitude} CGFloat.leastNonzeroMagnitude表示CGFloat支持的最小正数值，不会引起像素偏移。 保持屏幕常亮1234//保持屏幕常亮UIApplication.shared.isIdleTimerDisabled = true//关闭屏幕常亮UIApplication.shared.isIdleTimerDisabled = false 注意：不要滥用屏幕常亮属性（苹果会因为这打回你的app），如果只在某些特殊场合需要屏幕常亮，应该在之后将该值恢复成默认值false。 GithubMMKVMMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今，在 iOS 微信上使用已有近 3 年，其性能和稳定性经过了时间的验证。近期也已移植到 Android 平台，一并开源。替代UserDefaults的绝佳方案。 LottieLottie是一个面向Android和iOS的移动库，它能够解析由AE在bodymovin导出为json的效果动画，并在移动端渲染矢量动画!一些复杂的UI可以完全交给设计师了，哈哈哈。 RSSHudRSSHub 是一个轻量、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。结合Reeder不要太爽哦。😆","link":"/2018/09/30/monthly_3/"},{"title":"iOS开发月报#2|201808","text":"数据库用完要close当我们向下面这样执行完一次数据可查询时，要记得将数据库关闭，否则，如果此时想往同一数据库写东西的话会因为数据正在锁定收到这样的提示database is locked。 12345678910111213141516171819//获取下载完成的文件信息func isExistdWith(_ id: String) -&gt; Bool{guard db.open() else {return false}do {let resultSet = try db.executeQuery(\"select * from tableName where id = ?\", values: [id])if resultSet.next() {let isCompleted = resultSet.bool(forColumn: self.isCompleted)db.close()//return之前要close数据库return isCompleted}} catch {}db.close()//return之前要close数据库return false} UIDatePicker的时间格式当我们用UIDatePicker做选择时间的控件时，DatePicker会根据手机时间的设置自动选择是12小时制还是24小时制，如果我们需要强制控制DatePicker是显示12小时制还是24小时制可以这么做： 123datePicker.datePickerMode = .timedatePicker.locale = Locale.init(identifier: \"en_GB\")//for 24 HrsdatePicker.locale = Locale.init(identifier: \"en_US\")//for 12 Hrs iOS skill map 变量对外只读，对内可读写123struct Person {private(set) var name : String!} 设置UITableViewCell分割线对齐默认的cell分割线都是偏向右边多一些的，如果我们想让分割线对齐的话，正确的做法是： 1tableView.separatorInset = UIEdgeInsets.init(top: 0, left: 40, bottom: 0, right: 40) 设置左右边距都是40但是使用这种方法会带来一个问题就是默认的textLabel会跟着右移。为了保持label的居中我们可以再加一句： 12tableView.separatorInset = UIEdgeInsets.init(top: 0, left: 40, bottom: 0, right: 40)tableView.layoutMargins = UIEdgeInsets.init(top: 0, left: 40, bottom: 0, right: 40) 富文本显示图片元素如果我们需要文字中插入图片元素时，可以使用富文本处理： 12345let attch = NSTextAttachment()attch.image = UIImage.(named:\"logo\")attch.bounds = CGRect.init(x: 0, y: 0, width: 18, height: 18)let imageAttribute = NSAttributedString(attachment: attch)titleLabel.attributedText = attributed 添加spotlight搜索索引首先导入CoreSpotlight和MobileCoreServices框架，然后加入以下代码： 12345678910111213141516171819var searchableItems = [CSSearchableItem]()//索引项let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeData as String)//titleattributeSet.title = \"Item Title\"//desriptionattributeSet.contentDescription = \"match.description\"//thumbattributeSet.thumbnailData = try? Data.init(contentsOf: URL(string: url)!)//keywordsattributeSet.keywords = [\"Love\", \"Peace\"]let searchableItem = CSSearchableItem(uniqueIdentifier: \"app_keywords\", domainIdentifier: \"com.company.app\", attributeSet: attributeSet)searchableItems.append(searchableItem)//建立索引 CSSearchableIndex.default().indexSearchableItems(searchableItems) { (error) -&gt; Void inif error != nil {print(error?.localizedDescription ?? \"Error\")}} Hexo编译问题在执行hexo g编译markdown文件时莫名报错： 1TypeError: Cannot set property 'lastIndex' of undefined 解决方案是在_config.yml中将auto_detect设为false Podfile用法12345678910111213141516171819202122232425262728293031323334353637383940414243# 下面两行是指明依赖库的来源地址source 'https://github.com/CocoaPods/Specs.git'source 'https://github.com/Artsy/Specs.git'# 说明平台是ios，版本是8.0platform :ios, '8.0'# 忽略引入库的所有警告（强迫症者的福音啊）inhibit_all_warnings!# 生成的是framework而不是静态库use_frameworks!# 针对MyApp target引入AFNetworking# 针对MyAppTests target引入OCMock，target 'MyApp' do pod 'AFNetworking', '~&gt; 3.0' target 'MyAppTests' doinherit! :search_paths pod 'OCMock', '~&gt; 2.0.1' endpod 'JSONKit', :podspec =&gt; 'https://example.com/JSONKit.podspec'# 引入内部库pod 'ABTest', :git =&gt; 'https://bitbucket.org/sealcn/remoteabtest.git'pod 'ABTest', :git =&gt; 'https://bitbucket.org/sealcn/remoteabtest.git', :tag=&gt; '0.0.6'pod 'ABTest', :git =&gt; 'https://bitbucket.org/sealcn/remoteabtest.git', :commit=&gt; '082f8319af'# 编译配置，指定仅在Debug模式下启用pod 'Reveal-SDK', :configurations =&gt; ['Debug']# 使用本地文件pod 'AFNetworking', :path =&gt; '~/Documents/AFNetworking'# 指定版本号0.1.3到0.2，不包括0.2pod 'CHIPageControl', '~&gt; 0.1.3'# 仅安装QueryKit下的Attribute和QuerySet模块pod 'QueryKit', :subspecs =&gt; ['Attribute', 'QuerySet']end# 这个是cocoapods的一些配置,官网并没有太详细的说明,一般采取默认就好了,也就是不写.post_install do |installer| installer.pods_project.targets.each do |target| puts target.name endend","link":"/2018/09/03/monthly_2/"},{"title":"iOS技能图谱","text":"结合目前遇到过的一些技术点和唐巧的iOS技能图谱产出的这个综合版的iOS技能图谱，供大家参考交流：","link":"/2018/08/09/skill-map/"},{"title":"关于水滴筹","text":"很多朋友因为我的原因关注并参与到水滴筹中，有些小伙伴因为担心水滴筹有手续费用就直接把钱打给我。为了打消大家的顾虑，我花了些时间理解水滴筹背后的一些事情。 水滴筹的背景水滴筹是由水滴公司于2016年推出的一项针对疾病救助的筹款业务。在水滴筹之前的筹款平台领头羊是轻松筹（2014年推出），当时包括轻松筹在内的平台都会收取2%左右的手续费。水滴筹却一开始就不收取任何手续费，筹款所得资金全部归收款人（目前仅收取微信提现产生的手续费：0.1%）。免手续费肯定更多人使用，慢慢的水滴筹不断从轻松筹手里抢占市场，目前市场份额已经第一（轻松筹现在也免手续费了）。 水滴的发展说水滴筹的发展就不得不说水滴的创始人沈鹏，他是美团的第10号员工。在美团，沈鹏战功卓著：早期带着5万元单枪匹马杀到天津，第二个月就将天津市场份额从第七提升到第一；23岁升任大区经理，通管北京、天津、山东同400人团队，参与“千团大战”；26岁，跟随王慧文立项美团外卖，带领团队在一年多的时间里把美团外卖做的行业第一。所以他的市场把控和感知能力是非常强的。 线下地推是美团的强项，这个强项也被带到了水滴公司，很多早期水滴员工都是沈鹏从美团挖来的。早期水滴筹获取流量的重要砝码就是地推，他们下沉到渗透率并不高的三四五线城市和农村地区，招募大量兼职人员，志愿者辅导当地人筹款；他们在各个医院，各个科室留下名片，传单，立起易拉宝。不光鼓励患者加入，他们还会免费指导筹钱金额怎么写，求助说明怎么写，怎么转发（一次发三条可以占满手机一屏）效果好，甚至哪些时间点转发效率更高都会说。完美复制美团“农村包围城市”的策略。 这种形式让水滴筹快速获取了大量用户，也带来了巨大的流量。快速发展的水滴公司，目前估值近30亿，腾讯是最大的投资方。 盈利模式前面说了水滴筹是免手续费的，地推人员也都是需要发工资的，那它怎么赚钱呢？ 首先按照水滴筹的规则，一次筹款是30天，在这30天内只要不发起提现，水滴筹有权将这笔款项委托给第三方进行资金托管，水滴筹至今累计筹款200多亿，平均每月就将近5亿的流水，这产生的利息是非常高的。 另外水滴筹共有超过2.5亿名爱心人士参与帮助，累计产生6.5亿人次捐助活动。这巨大的流量推动宣传了水滴公司的另外两项业务：水滴互助和水滴保。这两项业才是赚钱的，它们的区别是：水滴筹，捐款人，是来做慈善的；水滴互助，互助会员，是希望加入一个低成本的互助计划。水滴保，主动跑来的投保人，是希望找到性价比高的保险产品。 其中水滴互助是水滴公司发展的第一项业务（后来支付宝出了个相互宝，跟它的模式基本一样，一人生病，大家帮忙分摊），水滴筹的产生更深层的目的是给水滴互助导流。所以水滴公司的商业变现模式就是通过水滴筹这种公益互助类产品聚集高黏性的用户和流量，然后再通过水滴互助、水滴保等商业业务板块进行变现。 所以他们肯定是赚钱的啦，只不过是一面做“慈善”，一面做生意。 目前问题及现状水滴筹目前已经过了市场掠夺期，但仍有些问题需要解决。水滴筹在前期的审核是相对宽松的，最主要的诊断证明和身份证号，只要没问题，就可以进入审核阶段，说是5分钟，有时基本1分钟就好了。可以让你快速的开始募捐，提现时才会需要你出示更加详细的诊断报告，病历，医院消费清单，银行卡信息等。这些都只是确认你真的生病了，但是是否贫困，其实是没有确认的，因为为了一个筹款的人就去当地调查也不现实，这也不好确认。不过这也会带来问题，有可能导致“滥用众筹”，“滥用爱心”，此前某德云社相声演员名下有房有车却筹款惹来的争议就是此类。 虽然水滴筹的审核机制受到争议，但我们并不能否认其存在的社会价值，它切切实实的帮助了很多人。在未来的监管中，要在防范风险与鼓励创新之间寻求适当的平衡，可能是监管部门和水滴公司需要认真思考和探讨的问题。如今，对于渴望疾驰的水滴公司来说，要想持续发展，关键还是“不忘初心”。","link":"/2019/11/08/shuidi/"},{"title":"感谢大家的帮助","text":"好消息开始水滴筹之后，父亲治病的消息大家就都知道了，期间收到了很多来自亲友的支持和帮助。先告诉大家好消息，父亲手术完了，并且身体恢复一切正常，已于11月8号中午从重症监护室转到无菌病房，还需要在里面待够五天才转到普通病房。关于看病所需要的筹款，也得到了解决。今天晚上7点左右，我已经终止了这次筹款。 看病资金问题能快速解决，除了来自水滴筹的筹款，还有就是公司的大力支持。三位老板帮助了2万元，还破格提前给我发了年终奖，算上水滴筹中的63588元，一直到出院应该是没什么问题了。 感谢公司真的非常感谢公司给予的支持，啥也不说了，我要夸一夸他。我们公司叫乐信圣文，是一家全球领先的移动出海应用开发商，致力于为全球用户提供卓越的移动应用，作为中国移动互联网公司出海的新锐领军者，产品在全球移动端月活超过2000万，累计用户超过3亿。目前正在招聘Android、iOS、Unity、web前端、Python等开发工程师，另外中高级测试、数据分析师、产品运营、MG动画师也都职位空缺。大家有要换工作的或者朋友换工作的，可以推荐来我们这。这么好的老板，这么有前景的公司还等什么？详情可以问我或者关注公司微信公众号：乐信圣文Learnings。 感谢所以提供帮助的小伙伴其次来自小伙伴的支持也让我非常感动，很多感动瞬间，其中有两个场景让我特别难忘。一是刚开始发起水滴筹时，当时心里慌慌的，根本不知道接下来事情会怎么发展，也不敢看手机。但不到5分钟时间，大学室友就开始齐刷刷的给我打钱，给我加油，当时铺天盖地的收款和问候消息直接就给我感动哭了，我真是爱死你们了。还有一件事是来自于一个前同事，当时我们只有QQ这一种联系方式，因为QQ用的很少，直到昨天才看到他的祝福和转账。他因为公司问题两个月都没收到工资了，知道我的情况之后，还执意给我打钱。真的是折煞我也！不知道说什么好了。 其实每次转发时我都怕打扰到大家，因为水滴筹里的各种求转发的术语，很像牛皮癣广告。但你们却对我很宽容，帮我转发，号召别人帮我转发，很多人还多次打款，真的非常感谢。我知道大家都不容易，各种生活琐事，结婚，买房，都是花钱的地方，我用你们的钱，也很过意不去，这里给大家道个歉，给你们添麻烦了。我想说的是，你们帮助我，给我爸治病这些钱不是捐给我的而是借给我的，我会在之后经济允许的情况下把钱都一一还给大家。 大家一定要给我面子啊，这笔钱我是要还的上午我用了将近一个小时时间把水滴筹的捐款记录反复核对了两遍，只要是能对应上名字的人我都用小本本把人名和捐款数额记录下来。本次捐款收到了750次帮助，我记录下来的人名有120多个。也就是说有很大一部分人没有联系到，这其中有一大部分来自于我爸的朋友、同行，教会的人，一部分亲戚，还有就是所有参与转发水滴筹扩散之后的朋友圈成员。好像要把所有人都确认下身份也不现实，所以对于那些无法确知是谁且捐款数额较多的，我都在捐款记录的下面留了言，询问联系方式。如果能联系上，钱还是会还给你的。 这里的还钱是除了老板们的2万哈，不是不还，是因为我想换一种还法，通过努力工作的方式回报公司，帮你们多宣传多招人（主要还是有点多，他们又都是大佬，肯定不差钱）。 可能很多人捐钱时就没打算再要回来，但是我是有打算还的。我选择还大家钱是因为我知道挣钱的不易。我有困难你们帮我，我困难过去了，理应把钱还给你们。这是我的心愿，不还你钱我会不舒服的，所以大家为了照顾我的感受不能推脱啊。 当然了这个还钱过程肯定是不会快的，这段时间确实用钱厉害，等过了这个坎，我会慢慢地开始还大家钱。如果你因为什么事情着急用钱，可以先找我；如果你的钱迟迟不给，排除被遗漏的可能性，那就说明在我眼里你是土豪，土豪的钱就最后还啦。 更多近况另外关于这几天的详细进展，以及我在七院里的一些见闻，大部分是记录下来了。大家有兴趣的话可以访问这个网站进行了解：zhangferry.com","link":"/2019/11/09/thanks_letter/"},{"title":"VSCode配置Python版本","text":"刚学习Python没多久，对VSCode也不是很熟悉，在一次解问题的过程中，加深了对这两者的印象，于是记录一下。 环境：Mac OS 10.15，VSCode 1.41.1 问题定位我在尝试用VSCode写python爬虫，遇到一个问题ImportError: No module named requests。 通过问题描述很容易知道问题，这是因为导入了requests库，但是VSCode却没有找到这个库。 问题解决知道了问题，那就好办，安装requests就行了。requests需要通过pip安装，所以要先安装pip。在安装pip之前还要清楚一件事，就是当前的python版本，因为pip是跟python版本对应的。 升级python因为python2已经不再维护了，所以要保证当前为python3版本。查看当前python版本在命令行输入python： 12345678WARNING: Python 2.7 is not recommended.This version is included in macOS for compatibility with legacy software.Future versions of macOS will not include Python 2.7.Instead, it is recommended that you transition to using 'python3' from within Terminal.Python 2.7.16 (default, Aug 24 2019, 18:37:03)[GCC 4.2.1 Compatible Apple LLVM 11.0.0 (clang-1100.0.32.4) (-macos10.15-objc-s on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information. 得知当前python版本为2.7，所以我们要进行升级。 小提示：命令行运行python就是打开了终端python环境，如果我们想退出该环境，运行exit()即可。 下载python安装包下载地址当前最新版本为3.8.1，我们下载之后进行安装。 更改默认python版本虽然我们安装了python3.8，但此时命令行运行python，还是显示为2.7，这是因为我们电脑中运行着两个版本的python，默认版本还是2.7。我们需要更改这项默认配置。在此之前我们还需要确认终端的shell环境，常见的shell环境是bash和zsh。怎么当前是哪一个呢？在终端运行: 1$ echo $SHELL 1、bash使用vim打开.bash_profile，当然你也可以使用别的文本编辑器。 1vi .bash_profile 在最后一行添加： 1alias python=\"/Library/Frameworks/Python.framework/Versions/3.8/bin/python3.8\" 保存之后，更新配置： 1source .bash_profile 2、zsh编辑.zprofile文件 1vi .zprofile 在最后一行添加： 1alias python=\"/Library/Frameworks/Python.framework/Versions/3.8/bin/python3.8\" 保存之后，更新配置： 1source .zprofile 然后再次运行python，会看到： 123Python 3.8.1 (v3.8.1:1b293b6006, Dec 18 2019, 14:08:53)[Clang 6.0 (clang-600.0.57)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information. 说明我们已经成功将python默认版本改成了3.8版本。 安装pip推荐使用pip安装脚本进行安装： 12$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载安装脚本$ sudo python get-pip.py # 运行安装脚本 因为我们默认的python版本就是3.x版本，所以安装的pip会自动关联到python3版本上。 查看pip版本和路径1$ pip --version 会得到以下信息： 1pip 20.0.2 from /Library/Python/2.7/site-packages/pip (python 2.7) 为什么关联的是python2.7版本？这是因为我电脑上之前通过python2.7安装过pip。那对应的python3.8版本的pip呢？它是由pip3表示的，可以验证下: 1$ pip3 --version 会得到： 1pip 20.0.2 from /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/pip (python 3.8) 安装requests到这一步就很简单了，注意使用pip3执行安装命令。 1$ pip3 install requests VSCode的python环境和本机python环境我们成功安装了requests，但是在vscode中运行脚本依旧报无法找到requests库的错误。这时我开始怀疑vscode和本机的python环境可能是不同的，而且我本机有两个python版本，vscode用的是哪一个呢？不管怎么样，我应该需要让vscode的python环境指向本机的python3.8，因为我的pip3和requests都是基于这个版本的python安装的。 vscode的python环境在vscode的python编辑界面的最下面一行会显示当前的python环境：点击它可以看到当前支持python版本：发现并没有我们的python3.8，所以我们需要手动指定python的版本。 指定vscode的python版本使用快捷键Command + ,可以唤出vscode的设计界面。因为配置项非常多，我们通过搜索命令查询，键入[python path]（中括号表示整体搜索），可以找到python路径配置的设置项： 默认值是python，我们将它改为/usr/local/bin/python3，然后重启vscode，我们就可以看到当前的python版本已经改为3.8.1了。导入requests的代码执行也没有问题了！ 疑问？这里还有几个疑问：1、python2.7和3.7版本都是vscode在安装python时自己装进去的吗？2、如果不通过指定为本机python版本，仅使用vscode中的python版本能否安装pip？ 有能帮助解答的小伙伴将不胜感激！","link":"/2020/02/01/vscode_python/"},{"title":"2018年总结","text":"写的有点晚了，因为一些事情耽搁，本来想干脆不写了。但有股力量不断催促着自己要写下来，于是就有了这篇文章。今年对我是意义重大的一年，从几个方面说吧，工作，生活和2019年的目标。 工作 3月底进了新公司，换工作主要原因是在之前的公司遇到了上升瓶颈，对当时的我来说一直待下去也无法看到清晰的未来。从新公司开始，今年变化了很多，也成长了不少。 开发语言首先技术语言从OC转到了Swift，也是首次用Swift进行项目开发，并没有太大障碍。因为是经手新项目，所有也没有太多历史包袱（兼容OC），使用Swift+RxSwift+Clean architecture的进行开发。我对Swift的感觉还是很好的，值得大家花时间去学去适应，毕竟Swfit代表着未来，是苹果推荐语言。都9102年了，ABI稳定版Swift5.0马上就要来了，没有什么理由不使用它了，不是吗。 开发工具一直都是使用MacBook Pro+Xcode的环境进行开发，之后使用fastlane进行打包，每次编译打包都将近40分钟。为了提高开发效率，开始考虑黑苹果方案。配置一台i7处理器+16G内存的台式机，4000左右，开始搞黑苹果。 附送一个教程传送门，以下是黑苹果配置： 有两个需要注意的地方：1、显卡无法驱动。使用免驱显卡。当时装的时候Mojave版本还没有正式版，想升级时才发现macOS10.14及之后的版本将不再识别NVIDIA的显卡，除非换成AMD显卡，遂放弃升级。2、网卡问题可以在天猫购买一个支持黑苹果的网卡，收到货之后向店主要个网卡驱动，之后就能正常wifi上网啦。 其他如蓝牙问题因为基本不用，没有搞，也可以使用黑苹果专用外设解决。 博客2018年共写了12篇播放，看了下日期，第一篇是从7月份开始写的，也就是说这12篇都是后半年写出来的。 关于写博客这件事，之前是一直有种迷茫的状态，一查就懂的不想写，太复杂的又不愿花时间整理。后来慢慢不知怎么地就又找到了点感觉，其实也没有什么规律，只是写的时候不那么被动了。之前博客都是发的简书，后来觉得简书环境不太好了，不光是对程序员不友好了，简书整体也脱离了那种小清新的感觉，不知道从那个版本开始简书客户端UI突变，整个头条风，就不爱了。转到了掘金，不过之前的文章并没有搬运过来。 如果有留意我最近博客的话，可以看到我正在弄一个iOS月报的东西。这个想法的产生是因为，每隔一段时间都会积攒一些知识点，一些学习感悟，因为是零碎的东西，又不便于整合成一篇博客。后来关注到老司机周报、知识小集、阮一峰的网络日志这几个栏目，收到启发，于是整合出iOS开发月报这种形式。毕竟一个月整理一次对我来说是一件可以做到的事。因为是一个人在做，每个月接触的东西也都会不一样，可能形式会有大大小小的差别。配图不好，语言不通顺也请大家多包涵，如果有什么意见或者好的内容可以给我推荐。我会持续努力的，争取做好这个栏目，给大家带来更多有质量的东西。 生活 那些经历翻了下相册来给过去的一年做下汇总： 在17年的最后一天跟一个团体，参加跨年夜行活动，从奥林匹克公园走到天安门广场，看1月1号的升旗仪式。 1月份在中关村创业大街跟一个高中时的朋友一起去听了哈默的如何成为斜杆青年的讲座。 同样是一月开始追《海贼》，从第一话开始，一直都是看的漫画，到顶上战争知道这将是场精彩的对决，转为动漫，之后就一直是动漫了，目前看到大妈篇打卡二。 一月份还参加了极客公园创新大会，见到了傅盛、王小川、黎万强、李彦宏、罗振宇等一众大佬本人。 3月份裸辞，在家闲置了半个月。跟女朋友从苹果园开始骑行，去了位于门头沟的京西古道。到了地方，视野所见游客不足十人，人家都快下班了，说要关门不推荐我们进去，于是歇了会就原路返回了。 4月份进了新公司。第二次参加北京国际半程马拉松，提前一个月开始准备，期间每天早上两公里，周末五公里。成绩是2小时20分钟。 5月份跟女朋友去了青岛，当时天气还比较冷，只记得吃了两次九龙餐厅的饭，真香。 7月份跟女朋友去了秦皇岛的孤独图书馆，她预约了一个月才预约上。到了之后感觉一般，图书馆很小，书也不多，不让拍照。图书馆旁边是阿那亚教堂，也感觉一般吧，不推荐去。还去了十渡，玩了玻璃栈道和漂流。这个非常推荐。 8月份对我来说是灾难性的，母亲被一场突如其来的疾病夺去了年轻的生命。我无助绝望过，一蹶不振过，也悲观厌世过，好在女朋友陪在身边，给了我足够的陪伴与安慰，才让我重新振作起来，真的非常感谢她。后来我不断的回忆与后悔，为什么没有坚持每年对父母做一个体检，我明明是知道的。所以我也再次郑重建议大家，每年带父母至少体检一次，多陪陪他们，真的这没那么难。 之后的下半年除了跟我爸，我女朋友分别爬了两次香山，基本就没什么活动了。 关于理财16年接触基金，17年开始定投，一开始对定投的理解就是分摊风险，比股票稳定，大概率会盈利。18年年初收益率达到15%时，当时定投已经达到我的设定预期。但我却仍坚定的相信，继续持有会获得更大收益。之后经历中美贸易战，股市重挫，之后持续的经济低迷，我都相信会涨回来，直到年末基金亏损达30%。我才意识到，当初自己那盲目的乐观是多么不正确。 后来听了一些大佬对19年经济形势的预测，大概率经济不会转好。所以基金定投这个事也会停止下来，这对我来说是一个教训，以后对理财会更加谨慎。 关于阅读今年阅读量比较小，就这几本：《Objective-C高级编程》《Swift面向协议编程》《大话设计模式》《人类群星闪耀时》《巨人的陨落》《精进》《钝感力》《把生命浪费在美好的事物上》《你一定爱的欧洲极简史》 正在看的有：《重构》《未来简史》《iOS逆向与安全》计划要看的是：《代码的未来》《学习之道》《老人与海》《天才在左疯子在右》《解忧杂货铺》《怪诞行为学》《百年孤独》《菊与刀》 2019年OKR O1:精进技术栈KR1:刷50道LeetCode题，写5篇左右博客总结解题思路。KR2:做3个iOS、mac客户端的逆向。KR3:翻译5篇Swift相关技术文章。KR4:学习前端知识，给博客换个面貌。KR5:开发一款微习惯的APPKR6:博客输出24篇 O2:攒更多的钱KR1:工资外收入达到1000KR2:总收入达到买房需要的首付一半 O3:运动健身KR1:半程马拉松跑到2小时以内KR2:咕咚累积里程达到500公里","link":"/2019/01/01/2018-year-summary/"},{"title":"2019年总结","text":"好像随着年龄的增长，对时间的感知就变得越来越弱了。总感觉2019年还是一个很新鲜的年份，但它却已经走完了，2020年好像很遥远的样子，但它已经到来了。来个总结吧，2019年，这一年有太多的酸甜苦辣。从工作、生活和规划三个方面展开说吧。 工作 年初原项目组有一位很厉害的开发离职了，当时是我俩共同负责一个项目。他开发经验比我多，而且工作态度和习惯都很好，是我见过的未数不多让我称赞的程序员。曾经一起工作的将近一年多时间里，我都以他为学习榜样。对于他的离职，我纠结了很长一段时间，自认这是对我对公司的一大损失。 后来很长的时间里，一直都没有招到合适的人，我便一个人扛起了项目。很多之前应该是两个人一起商量的问题都需要自己一个人去思考解决方式，渐渐的我不断磨练自己的独立思考能力。大半年下来，突然感觉自己被逼着成长了许多，从一个崇拜别人，向别人学习的角色变成了一个不惧怕任何技术难题，能够帮助别人解决困难的角色。 2019年学会的第一个最重要的道理，很多时候有一个可以依赖的对象，是会减弱自己探索和尝试的动力，而开发很多时候对技能的理解和掌握，乃至个人进步，都是要依靠自己的探索获取的。 写作2019年共产出27篇博文，27是一个挺大的数量，但令我满意的文章到不是很多。博客内容质量的重要性应该是要远大于数量的，这一点后面注意到了。 对技术博客的写作今年做了一些不同的尝试。 首先对于月报的更新持续到今年7月份，共产出了一共13篇文章，就停更了。月报内容主要由三部分组成： 最近一段时间的bug修复经历和开发tip 阅读过的优秀博文 优秀的github库 第一部分，这个受开发经历的影响，就我个人来说，很多时候没有太好的经验可以写，到最后时感觉内容不好撑起这一个模块。第二部分，出现过几次前期准备不够，最后一两天才去寻找素材，导致推荐内容很一般。第三部分，优秀库的推荐，写到第十期时就感觉乏力的。当然我知道这里的内容是接近无限的，但是很多如果我都不了解，不使用，只读一个简介就去推荐，会有种不负责任的感觉。 还有一部分原因是，到后来关注的人越来越少，接到的反馈也越来越少，应该是跟质量下降有关。做这个东西也确实费时间，很多时候我就想如果这些时间去打磨一篇技术博客，可能效果会更好。而且月报给人感觉时效性更强，跟新闻类似，过了这个时间之后好像过时了一样，大家很少会特意翻看之前的内容，而普通的技术博客却不会有这种问题，解题思路，技术干货几乎不存在过时问题。 另外我也一直在观察给我启发的 “老司机iOS周报”，他们只有博文推荐和代码库推荐，由多位联合编辑共同完成，人员、时间、内容质量都不是问题。但就我观察得知，“老司机”的号召力和响应力也在不断减弱。技术类人员对内容聚合类产品的粘性是没有固定知识分享平台高的。一篇周报，十篇左右文章，大致看去，自己感兴趣的可能就两三篇，新窗口打开，导流到别的地方，有时间的话读一读，时间不够就放到收藏夹。一般在周报的停留时间不超过3分钟。 基于这些原因吧，我也就不再更新月报了，而是把时间分配到别的事情上去。 公众号 另外，开始尝试写公众号，名字叫“iOS成长之路”。文章更新不多，其中最主要的原因就是我习惯了写博客，而且博客有一套自己的workflow。一般我是先写博客，然后将文章复制到别的平台。像之前的简书和后来的掘金，都是可以全量复制的。 转到公众号时，虽然可以直接将Markdown转成公众号形式，但对图片却不识别，需要单独导入。我需要把github上的图片下载下来，放到公众号编辑界面。如果图多，就是项很繁琐的流程。而且公众号还限制了每天只能发一篇文章，所以后面更新了几次之后就不再更新了。如果有小伙伴知道解决方案的话，希望能够告知。之后的话，会想把公众号这个事情再推进下。 生活 那些经历今年基本没有什么活动。 清明节，回家看妈妈，不自觉拍了很多家里，地里的照片，感觉老家哪里都是美的。那个我曾经抵触，一心想逃离的家乡，在这个春天里一下变得可爱，温馨起来。走到路上我想起曾经走在这里发生过的一切，到了家里我回想这个房屋里曾经发生过的一切，那些欢声笑语。记忆一点点展开，如果此时放弃工作，放弃所有，跟爸爸就在老家生活下去，也未尝不可，我这样想着，对未来的规划和期许，已经都不重要了。但是也只能想想，现实还有很多问题需要考虑，需要处理，我已经被社会规则裹挟着由不得自己了，这可能就是长大的无奈吧。 4月份中旬，参加了《天火》的电影宣发，见到了很多明星，但也并没有太多兴奋，就感觉明星跟普通人其实也没有太多不同。12月12号，电影上映，因为宣发时收到了很多到场礼品，就买了票去支持下，女友和我观点一致：电影很烂，昆凌演的一般，剧情太散。配备了近乎完美的制作团队，外加周杰伦的宣传，电影竟然如此扑街，真的很让人匪夷所思。今年娱乐活动极少，一共就去电影院看了两场电影，其中一部还是这种感受。剧情，剧情，剧情，这是电影的灵魂，真的很重要啊。 4月底，参加我们609寝室第一个结婚的室友婚礼，分别两年多了再相聚，大家都基本没变。我们还是曾经的我们，各奔东西，又再次相聚，真好。 4月份报名了半马，但是很遗憾没有中签，直接导致了去年的一项目标没有完成。 5月份没有出门，跟女朋友在家探索了很多美食的做法，每次做好吃的，我都会用手机拍下来，相册里已经有几十张美食照片了。做饭其实是一项很有趣的事情，洗菜，切菜，食材下锅一瞬间的滋滋声，出锅时的香气四溢，都能不断激发自己的食欲，这可比塑料彩盒包装的外卖有灵魂多了。所以这一年不光点外卖次数少了很多，厨艺还增进了不少。 6月份重新拾起了跑步的习惯，每天下午下班之前的半个小时都陪菲姐去园区跑道跑步，这个习惯帮助她减掉了十几斤肉，也帮助我在年度跑步计划中增加了将近200公里的里程。 7月份准备园区的篮球比赛，虽然每次练习都挥汗如雨，各种制定战术，尽心准备，但还是改变不了比赛被别的公司虐的结局。虽然篮球比不过他们，但是我们敲代码比他们厉害啊，这么安慰自己。但老实说，为什么我感觉打球比敲代码还有意思啊。教练，我想打球。 8月份，配父亲去郑州等肾脏配型，当时想的是父亲留在这里，等有手术消息了，我再赶过去，但是医院要求等待期间必须要有家属陪同，那就回不了北京了。跟公司说明情况之后想申请远程办公，当时想的是如果公司不同意就直接离职。最后公司领导商量之后决定同意我的请求，之后就开始了长达45天的在郑州远程办公。 9月份，工作日期间，我将作息时间调整到跟公司一样的点，有时候去附近的咖啡店，有时候就在家办公。这期间最大的挑战就是自律和需求沟通。因为有时候配父亲做检查，或者送饭，耽误一些时间，这个就要想办法从别的地方补上来，还有就是家里的工作氛围比着公司要差一下，注意力的持续状态要短一些。所以这段时间基本周六都会根据情况抽出时间用来补进度。当然远程办公最爽的一点就是时间可以自由安排，可以是忙完一项任务或者通过时间挪移，你就可以在任意时间段做自己能做的事情。 当然因为效率没有在公司高，所以空闲时间相较而言还是更少了。这里的调整就是时间规划和时间管理的内容了，这个在未来我会重点优化下。 10月份，参加我们609第二个结婚的小伙伴婚礼，还顺道去了一趟大学校园。校园里多了好几栋教学楼和宿舍楼，当年的公教没变，宿舍楼变成了女寝？图书馆还是那么霸气，甚至想进去找个地方看会书。多好的环境啊，为什么当初没有好好珍惜，努力学习呢。好像在回忆过往时，我从来都是责备自己不够努力，不够优秀。 但是好像这就是真的，2019年也是，我并没有拼进全力，很多事情都没有做好，我应该更加努力，多逼一逼自己才是。 11月份，一直陪父亲等的肾脏配型终于有了结果，父亲接受手术，我来郑州陪护。这段经历大多数记在博客里面，这期间确实让我成长了不少。后来父亲出院，我回北京的第二天在V站看到一个帖子，一个程序员长时间加班导致身体不适，去医院检查被诊断为CKD4期（慢性肾病4期）。而CKD5期就是尿毒症，就是父亲的那个病。虽然我在医院见过很多病人了，但这个病的魔爪伸到了程序员群体，还是很让我惊讶和担忧的。 不只尿毒症，很多病都在向低龄化发展。健康！健康！健康！这个真的非常重要，作息，饮食，这两个最容易导致身体出问题的环节一定要重视啊。 12月份，在天桥看了一场话剧《黄金百万》，演员均非科班出身，当时还只是第三场演出，所以整体感觉水分很大，甚至一度有中途撤离的冲动。话剧演出结束，演员讲述舞台背后的故事时，却让我得到了些意外收获。他们是由互联网圈，投资圈，主持人圈的几个朋友组建起来的，其中就有为人熟知的张泉灵和于光东。他们都不缺钱，也不指望依靠话剧挣钱，就凭着爱好，组织话剧社，在本职工作之余，挤时间进行排练，很多人都不在北京居住，但他们还是圆满的完成了这次表演。 这让我看到了一种生活态度，工作不应该完全占据生活，生活也不应该只是吃喝玩乐，我们应该发觉自己的爱好，潜力，去做一些能带给自己满足感，更有意义的事情，这样才是精彩的活着。所以2020年，我也会往这方面做一些尝试。 关于理财看到很多人晒今年收益，50%，甚至120%。因为今年经济整体都是上行，大多数都是赚的，只是赚多赚少而已。像我这种理财小白，只是定投指数基金不动都有将近30%的收益。所以大家对于很多人的收益不要眼红，不要过于乐观。今年大好，明年是好还是坏谁也说不准了。理财的一条金科玉律就是，收益越大风险越大，能承受风险，有一定的专业知识，那就努力达到收益最大化。如果都做不到，那就不要定过高的目标，像我目前定的目标就是跑赢通货膨胀，保证手里的钱不贬值就行。 理财这项技能，可以看到上限还是很高的，以后会花更多的时间在上面做一些研究，补足这方面的能力，努力提高收益。 关于阅读阅读方面，近几年看的书越来越少了，今年只有：《软技能：代码之外的生存指南》《图解TCP/IP》《重构》《未来简史》《老人与海》《白夜行》《半小时漫画中国史+世界史》《如何高效读懂一本书》 这里最推荐的就是《软技能》，它介绍了程序员在编程能力之外还应该具备哪些能力，涵盖职业规划，自我营销，学习方法，理财手段，健身，精神提升等方面。这本书影响了我对自己职业的看法，同时也让我对未来的规划更坚定，更清晰了一些。非常建议大家都读一读。 OKR总结 2019年OKR总结O1:精进技术栈 KR 完成进度 总结 刷50道LeetCode，输出解题思路 10% 时间问题 逆向实践 0% 逆向理论没有持续深入研究，时间问题 翻译5篇技术文章 60% 翻译水平有待提高，输出较慢 博客主题优化 10% 学习前端要系统的学习，低估了这个工作量 开发微习惯APP 5% 发现有别的APP做的很好了，另因产品设计能力短时间没有补全，及时间问题，后来做罢 博客输出24篇文章 112% 因为多了几篇生活中的文章，如果只算技术文章也是不够的 总结：实现度较低，很多是因为时间问题，和对制定任务的难度预估不准确导致的。这一年对技术层面的提升总综合性，没有在某一点有所突出，今年需要做一些调整。 O2:攒更多的钱 KR 完成进度 总结 工资外收入达到1000 200% 有段时间帮助一个团队处理了几个问题，获得了一些报酬 总收入达到买房需要的首付一半 50% 收入是达到了，但是存款却没有 总结：这几项定的目标都有些含糊了，工资外收入其实更像表达的是，写博客的打赏，和公众号的一些收入。总收入的目标其实没有意义，存款才有意义。 O3:运动健身 KR 完成进度 总结 半程马拉松跑到2小时以内 0% 因为没有中签，也就没有跑半马的经历了 咕咚累积里程达到500公里 99% 依靠每天下午的跑步，基本追上了这个目标 总结：跑步里程到是一个合理的目标，半马因为受外界因素影响，所以是一个不太好的KR。 2020年OKR有些在2019年没有做好的事情，会在新的一年里持续的跟进优化。 O1：精进技术栈 KR1：刷20道经典LeetCode题目，输出2篇解题思路的文章 KR2：学习前端知识，优化博客小站 KR3：输出5篇对计算机知识总结的文章 KR4：维护一个Swift库，用于筛选项目中不用的文件 O2：个人成长 KR1：公众号粉丝达到500 KR2：学习基金知识，分析对比10种基金的数据表现 KR3：全年跑步里程400公里 KR4：阅读15本书 KR5：培养时间规划能力，总结并践行一份时间规划清单","link":"/2020/01/01/2019-year-summary/"},{"title":"七院第一天（11月3号）","text":"抵达郑州二号中午我爸打电话来医院这边配型成功，让三号早上来做手术。我得知这个消息有些开心也有些担忧，开心是因为盼了八个多月的肾源终于有了消息，担忧是紧接着将是一场大手术，不管医院怎么保证手术成功率，肾移植手术本身都是一项大手术。 我和弟弟是二号晚上9点半的火车，因为当天才进行买票，只有硬座了，三号早上5点45到的郑州。爸爸于前一天晚上在三姨和姨父的陪同下到的医院。见到爸爸，看他精神状态挺不错，我安心不少。他说需要做的检查都已经做了，身体条件一切正常，就等医生上班安排手术时间了。 准备手术钱去到住院部，医生首先问费用是否准备齐全，肾源费15万必须现金，住院账户上至少有6万可用费用，这个账户可以用支付宝微信银行卡充值。手术之前如果这些钱不够是不给手术的。我跟我爸简单核对了下现在有多少钱，加上我之前的积蓄，差不多够。基金里有3万左右，因为这个提现有几天延迟，我担心后面有别的情况出现，也申请了提现。 护士提示我们先准备现金，15万属于大额，有些银行必须要预约还需要预约。这一点确实超出我的预期，就赶紧带着卡跟我弟一块去取钱。楼下ATM取了两万就超额不让取了。附近有个建设银行，工作人员一听要跨行转账，而且这么多直接拒绝了我们。我的钱在招商卡里面，就又去了较远的招商银行。柜员问是否有预约，我怕因为这个不给取就赶紧说了这是做手术急用的钱。他犹豫了一下同意了，就开始在柜台那边操作。包括另一张银行卡的跨行提现，他说不知道能不能行，但可以帮我们试一下。虽然最后确实不行，但这个态度挺让我满意，前后对比两家银行，建行给我的印象就更差了。 15万放在包里真挺重的，我背着沉甸甸的钱回到了医院，就在护士的待领取下去缴费。我看柜台人员点钱，15万现金，一万一万的点，要数3-4次左右，光在那等点钱等了七八分钟。然后是凑手术和住院费的钱，我这边微信，支付宝，都交了进去，一直到预存金达到6万。此时手里的钱已经不足一万了，但好在达到了手术要求的费用。 术前准备回到医护室，护士交代，要买10支白蛋白，是术后用的。还给了我一张名片，让我打电话去找这个人买。不明白为什么医院不自己开，还要通过外面才能买？我没时间考虑太多这种事情，就按照她的要求，说什么做什么，要什么给什么。接过电话，那边先说价格380一支，我好像也没别的选择，就让他送了十支。 再之后护士又给了一张纸条，上面分两段列了需要购买的东西这些。洗脸盆、大便器、小便器、痰盂、毛巾、牙刷杯、牙刷、牙膏、奶瓶、卫生纸一提、成人尿垫一大包、湿巾一包，消毒湿巾一包、压力绷带两个、雾化吸氧面罩一个、呼吸训练器一个。这些是重症监护室需要用的。便携式体重秤、温度计、小药箱、小本和笔、口罩一包、输液报警器一个、扣背器一个。这些是从重症监护室出来用的。 听大夫说整个过程是晚上6点左右手术，手术完会进重症监护室，在里面观察恢复5天左右，由专门护工照顾，每天有一次探视的机会，可以通过摄像头跟病人交流几分钟。五天之后从重症监护室转到无菌病房，再有五天可以转到普通病房。普通病房阶段就可以自由看望，甚至可以下床简单活动。 买完必备东西之后，爸爸开始了透析。因为正常是一周透析三次，一三五，隔一天一透，今天周日，上次透析是周五，隔的时间较长，需要补一次。透析时我还跟爸爸说，这可能是你最后一次透析了，以后再想透析也没了。 和爸爸一起接受手术的还有一个人，安徽阜阳的，他也属鸡比我爸小一轮，身高体重血型两人也都基本一致。他们俩是要接受同一个供体。问了下还是基督家庭，三姨也感叹这是何种的缘分，冥冥之中可能就是上帝促成的这件事吧。 确定了晚上6点手术之后，爸爸从早上10点开始就被要求不能进食。因为透析的缘故他饥饿感更强了，但也没办法了。这时护士过来说你们余额不足了，需要充钱。问清楚之后我才知道，不是一共交6万而是卡内余额要有6万，一上午已经花了3万多了，就说还要充进去4万才行。这可让我很发愁，想到了这是医院账号，试着用了1万花呗，充值成功，然后是用3万信用卡的额度。这已经是穷尽了力气了，总算筹齐了做手术的钱。 手术前还有一项是洗肠，不知因为什么缘故我爸需要做两次才行，莫名有些心疼起来。之后又等了一段时间，两位叔叔也来了，也说看我爸精神状态不错。我知道每临大事时最紧张的阶段都是知道大事降临，等待事情发生的那段时间。只盼望时间可以过的快一点，不要让我们，不要让我爸煎熬太久。术前量血压，我爸高压170，他本身有一些高血压，也可能是紧张的原因，有点过高了。依照大夫的指示要吃两片降压药，此时还需要控制饮水，只让抿一小口够吃药就行。这一点水下口，可是解了他的瘾，爸爸说水真是太好喝了，想喝却不敢喝。 手术之前需要签字，医生一上来跟我说了一大堆可能的不良反应和意外情况，手术之后可能肾不工作，恢复不好还需要透析辅助，术后肺部容易感染，伤口愈合前如果翻身不小心还可能伤口破裂，术后免疫力会非常低，特别需要照顾好别感冒，抗排异药容易引起情绪焦躁，需要配合医生。想着医院原来的话，手术成功率高达99%，本来还很有信心的我一下紧张和不安起来。但医生不管这些，只是把所有可能的坏情况给我说一遍，然后说，都清楚了吧，签个字吧。这就是一个免责说明书，我毫无还手之力，签了字匆匆离开，只希望手术能够顺顺利利完成。 进行手术傍晚6点半左右进了手术室，在手术室门口，接待的医生已经是一身蓝绿色衣服了。他简单问了一下情况，然后记着一些东西，手势动作都很熟练。虽然是简单的步骤，但他的穿着，语气和动作，却让我感受到一种专业性。专业这个东西也是我一直向往和努力的目标。因着这种专业感我很快踏实下来，相信医生，他们肯定会好好给我爸治病。 医生说手术将近三个小时。亚茹姐也信基督，组织了一个小团队，在北京为爸爸祷告。郑老师，张阿姨还有老家的一个教会也在为爸爸祷告。很多人都在祝福着这场手术，盼望着它顺利进行。爸爸进入手术室半个小时之后，临床要一起进行手术的那个人也进了手术室。 这段时间感觉过的异常慢，7点，8点，9点，这个时间点左右差不多该出来了，我就一直盯着手术室的门。想象着它打开的那个瞬间。九点半左右，门开了，但是是跟他一起手术的那个人。他本身比我爸晚进去却早出来，又让我紧张起来。二十分钟左右，想像中的那个画面才出现：医生护士，推着病床，告诉我们手术一切顺利，已经排尿了。我问爸爸感觉怎么样，他声音沙哑说不出来，跟我们见了大概5秒中，很快就被医生推着进到重症监护室了。 此时一直悬着的心才放下来，向所有关注这场手术的人报了平安之后，我心里默默说着，感谢主。虽然身边很多人都是基督徒，我也是基督家庭，我却一直没有真正成为一名基督徒，但还是很感激，我相信这是一场被神祝福了的手术。 手术做完送了两支白蛋白，按照流程基本没什么事了。但是担心有别的情况，所以重症监护室外面得一直有人看着。我跟弟弟说好一替一会在这守着，这时我俩都已经三十多个小时没合眼了。我在监护室外待到夜里两点半，期间在凳子上眯了一会，然后弟弟来替我。","link":"/2019/11/03/2019_11_3/"},{"title":"为什么会得尿毒症","text":"看了父亲的病历，再结合之前了解的一些情况，我试着分析一下为什么会得尿毒症。 一些医学知识关于肾脏： 肾脏有很重要的代谢排毒功能，可以清除体内经由食物消化所残留的尿素、尿素氮、肌酸酐等，也会排出水分，维持体内的电解质平衡，甚至是控制血压高低起伏、活化维生素 D 的重要器官。此外，肾脏与肝脏一样，也是体内清除药物的重要器官，这也是为何肾功能不好时，就容易发生药物过量或中毒后遗症的原因。可见肾脏是何等的重要！等到肾脏的功能持续恶化到只剩下不到正常的 10% 时，才较容易出现包括恶心、水肿、高血压、倦怠无力、抽筋等症状，一旦造成更严重的尿毒症时，只能透析治疗。 其中衡量肾脏功能健康程度有个很重要的指标，肌酐： 肌酐是肌肉在人体内代谢的产物，临床常用来衡量肾功能的健康程度。正常范围是54-106umol/L。 痛风： 痛风是一种单钠尿酸盐(MSU)沉积所致的晶体相关性关节病，与嘌呤代谢紊乱及(或)尿酸排泄减少所致的高尿酸血症直接相关，属代谢性风湿病范畴。痛风可并发肾脏病变，严重者可出现关节破坏、肾功能损害，常伴发高脂血症、高血压病、糖尿病、动脉硬化及冠心病等。 因为痛风常发于指关节，痛起来是那种深入骨头的痛，取自“痛疯”的谐音。 时间线2007年2007年，爸爸来北京打工已经7、8年左右了。凭借着勤奋和聪明，他从一个蹬板车买花的小贩变成了一个接小区别墅建筑项目的小老板，生意上虽然越来越好，很多事上爸爸还是喜欢亲力亲为。 那时正赶上夏季，爸爸要给人做葡萄架，一个葡萄架工期差不多是10人天，因为没有跟别的事赶在一起，爸爸就一个人做了。做木工活，使用频率最高的工具就是电锯。他对流程和工具的使用已经是很熟练了，但那次可能是走神了或者预估错误，没有把握好电锯的切割幅度，一下切中了小拇指。虽然没有整个切掉，但是骨头都切断了，很血腥的一幕。紧接着送去医院，医生在手指中间接了一根钢针，保住了手指。 在调养期间，为了防止发炎，打了很多抗生素也吃了很多消炎药。我们总说伤筋动骨一百天，这个调养也将近持续了一百天。这一点虽然没有体现的病历中，但我隐隐感觉，这可能就是后面一系列事件的引子。 2008-2009年2008年左右，父亲感觉左脚大拇指外侧疼痛，频繁几次之后就去了北京解放军301医院做检查。当时检查为肌酐80（umol/L），被医生诊断为通风，并建议控制饮酒。当时吃了别嘌醇等药物进行治疗，很快疼痛的症状消失，就没有再去医院进行检查。 一直以来父亲都爱喝啤酒，因为北京这边亲戚朋友也比较多，大家不忙的时候常会一块聚聚。父辈那些人基本都爱喝酒，坐到一起，打牌，喝酒，吃肉，经常几天就一次，一喝就是酩酊大醉。虽然母亲经常批评父亲不要喝酒，但父亲感觉不疼了就是病好了，再加上朋友劝酒，自己又想喝，也没有加以控制。为了这事他被母亲不知吵了多少次。 关于痛风，目前还无法根治的，只能通过调养，延缓病情。而这其中最重要的就是要限制嘌呤的摄入，啤酒嘌呤虽然含的不多，但容易喝过量也就导致体内嘌呤大量增加。 2010-2011年大概一年之后，爸爸又出现了左脚大拇指疼痛的症状，而且这次要比上一次严重。再去北京解放军301医院检查，肌酐已经涨到200，被诊断为“慢性肾功能不全”。痛风患者中大约有40%的人会患有慢性肾病，因为饮酒的原因由痛风发展到了慢性肾病。 之后父亲也意识到了问题的严重性，开始慢慢戒啤酒。也是从这时开始，爸爸之后吃药就没再断过。确诊为“慢性肾功能不全”之后，从医院就拿了一个月的药。这期间效果一直一般，爸妈决定换个医院试试。然后去了北京武警医院，医生对病情的诊断是一致的，但对于病情的治疗并不乐观，说慢性肾病也是一个需要调理的疾病，并不能吃某种药就根治。这次在这里又拿了1个月的药。 对于医生不能彻底根治的说法，他们有些灰心。后来在电视上看到有家中医院关于治疗慢性肾病的广告，他们宣传的效果非常好，这给他们带来了一些希望。虽然知道大医院才更靠谱一些，他们还是去了那个医院，并开了3个月的中药。中药熬出来之后都是非常苦的，但是为了治病，父亲皱着眉头也都坚持把药喝下去的。期间药吃完了就再去买，都是一买几个月的。 虽然父亲一直生病，但是并不影响干活，只要脚不疼他忙起来依旧生龙活虎的。这段时间家里的经济状况也越来越好，当时很多亲戚结婚或者盖房来我家借钱，父亲都是慷慨解囊。 2012年到2012年暑假，我高考完来北京。爸爸身体已经出现一些症状：特别容易困，脚浮肿。有一天上午他需要到一个客户那里办事，我陪他一起去，车刚开到一半，父亲就说，开不了了，需要休息一会。然后停到一个地方，睡了20分钟，再继续走。当时脚也经常性的水肿，鞋都只能穿宽松的。 病情持续恶化，一天中午，父亲躺在床上不起来，被母亲发现时，他眼睛里面布满了血丝。我当时正在场，看到这个场景，只感觉心里被重重击打了一下，很恐慌，想哭却哭不出来。我背着他坐上车，那天直接去了北大医院，进入重症监护室。 医生已经下了病危通知书，他冷酷无情地告诉我跟母亲，病人随时有可能遭遇不测，请提前做好心理准备。我跟妈妈都哭了出来，那是我第一次近距离接触死亡。 过了几个小时，医生告诉我们父亲已经脱离了危险，并被确诊为尿毒症（慢性肾脏病5期），肌酐达到了1200。进入尿毒针阶段就只有两种方法维持生命了，透析和肾移植。因为肾移植手术不是想做就能做的，需要等待合适肾源，所以前期只能通过透析维持。度过危险期之后，由于北大医院病房紧张，父亲被转到了北京航空医院进行透析治疗。当时在航空医院住了将近一个月时间才恢复身体出院。 分析1、饮酒和一些药物 病根在痛风上，但痛风的病因和发病机制尚不清楚。但有些诱发因素，例如大量摄入动物内脏，贝类海鲜等高嘌呤食物，还有酒精的摄入，特别是啤酒。当然还有可能导致血尿酸增高的药物。 因为已经无从查证父亲当时手指受伤都吃了哪些药，动物内脏和贝类他也不喜欢吃，只能猜测那时的用药和父亲本身喜欢喝啤酒共同造成了痛风的发生。 2、中药要慎重，去大医院看病 痛风发展成为慢性肾炎，是有很大概率的，但是保养得当也可以控制的很好。但是在短短两年多的时间 就从慢性肾脏病1期发展到5期确实太快了，很多人根本不会发展到5期，或者是很多年之后才会发展恶化到尿毒症阶段。所以我就十分怀疑是吃中药阶段导致的病情加重。 关于中药治疗肾病的效果，我看了一些网上的讨论，是还不错的，有用中药调理这种说法。那就大概率是被那个广告医院给坑了，喝中药阶段一点改善没有，而且中药本身会含有很多非药效的杂质，喝到体内会大大增加肾的负担。 3、定期检查 还有一点是如果不能保证吃的药一定就对病情有帮助，那就需要定期去医院检查，一个是了解病情处在哪个阶段，一个就是能看出来当时再吃的那个药是否有作用。 更重要的一点一定要去大医院啊。","link":"/2019/11/07/2019_11_7/"},{"title":"AVPlayer支持的视频格式","text":"发现很多人对视频格式存在一些误解，之前写的一篇文章讲AVPlayer的支持格式也有一些问题，所以这里单独出一篇文章讲一下，希望大家能明白。 基本概念一个在线视频能够播放，大致是经过了如下步骤： 可以总结为：拉数据-&gt;解协议-&gt;解封装-&gt;音视频解码-&gt;音视频同步-&gt;播放。下面就针对这几个概念一一做下解释： 播放协议一般点播采用HTTP，而直播的话，大部分还是采用RTMP或者私有协议，原因是延时会比较小，RTMP本身也是为了直播设计的。常见的流媒体协议： 简写 全称 推出机构 目前使用领域 HLS HTTP Live Streaming 苹果 多应用于苹果 RTP 实时传输协议 IETF 范围较广 RTCP 实时传输控制协议 IETF 范围较广 RTSP 实时串流协议 RealNetworks等 范围较广 RTMP 实时消息协议 Adobe 较流行 MMS 串流媒体协议 Microsoft 范围较广 RTP/RTSP/RTCP的区别 RTSP发起/终结流媒体、RTP传输流媒体数据 、RTCP对RTP进行控制，同步。 HLS(Http Live Streaming)HLS是苹果推出，实现的基于HTTP的流媒体传输协议:优点：1、通过m3u8索引文件可实现针对当前浏览设备的智能选择播放源，2、通过m3u8索引文件可实现添加备份索引文件，防止服务器崩溃视频播放失败3、和http视频一样 不需要太多服务器额外配置缺点：1、并非真正实时视频，30s左右时间差2、需要视频处理3、因为需要请求索引文件（ts视频文件）请求次数相对较多，对服务器负载较大 视频编码所谓视频编码方式就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式。它是一种为了减少视频体积，同时保证画面质量的压缩技术，常见的视频编码有： 名称 推出机构 推出时间 目前使用领域 HEVC(H.265) MPEG/ITU-T 2013 研发中 H.264 MPEG/ITU-T 2003 各个领域 MPEG4 MPEG 2001 不温不火 MPEG2 MPEG 1994 数字电视 XviD OpenDivX 2002 流行 VP9 Google 2013 研发中 VP8 Google 2008 不普及 VC-1 Microsoft Inc. 2006 微软 H.264 H.264又叫AVC，是国际标准化组织（ISO）和国际电信联盟（ITU）共同提出的继MPEG4之后的新一代数字视频压缩格式，它集合了H.263和MPEG4的优点，拥有更高的数据压缩比。在同等的图像质量条件下，H.264的数据压缩比能比H.263高2倍，比MPEG-4高1.5倍。也是目前苹果支持最好的编码格式。 音频编码和视频编码类似，音频编码的作用是减少音频中的冗余，同时在保证一定音频质量的条件下作的压缩处理。 名称 推出机构 推出时间 目前使用领域 AAC MPEG 1997 流媒体 AC-3 Dolby Inc. 1992 DVD, 数字电视 MP3 MPEG 1993 各个领域（旧） WMA Microsoft Inc. 1999 Windows AAC AAC（高级音频编码技术 Advanced Audio Coding)，出现于1997年，是基于MPEG-2的音频编码技术。由Fraunhofer IIS、杜比、苹果、AT&amp;T、索尼等公司共同开发，以取代mp3格式。2000年，MPEG-4标准出台，AAC从新整合了其特性，故现又称MPEG-4 AAC，即m4a。 苹果的CoreAudio对AAC有较好的支持。 封装格式我们常见的视频格式MP4, AVI, RMVB, 3GP, MKV都是指视频的封装格式,大部分情况就是视频文件的后缀。常见的组合方式有： table th:nth-of-type(2) { width: 60%; } 名称 简介 常用编码格式 扩展名 Flash Video 由Adobe Flash延伸出来的的一种流行网络视频封装格式。随着视频网站的丰富，这个格式已经非常普及。 H.264+MP3 flv AVI（Audio Video Interleave） 比较早的AVI是微软开发的。其含义是Audio Video Interactive，就是把视频和音频编码混合在一起存储。AVI也是最长寿的格式，已经存在10余年了，虽然发布过改版（V2.0于1996年发布），但已显老态。AVI格式上限制比较多，只能有一个视频轨道和一个音频轨道（现在有非标准插件可加入最多两个音频轨道），还可以有一些附加轨道，如文字等。AVI格式不提供任何控制功能。 Xvid+MP3 avi WMV（Windows Media Video） 同样是微软开发的一组数字视频编解码格式的通称，ASF（Advanced Systems Format）是其封装格式。ASF封装的WMV档具有“数字版权保护”功能。 VC-1+WMA wmv/asf MPEG（Moving Picture Experts Group） 是一个国际标准化组织（ISO）认可的媒体封装形式，受到大部分机器的支持。其存储方式多样，可以适应不同的应用环境。MPEG-4档的档容器格式在Part 1（mux）、14（asp）、15（avc）等中规定。MPEG的控制功能丰富，可以有多个视频（即角度）、音轨、字幕（位图字幕）等等。MPEG的一个简化版本3GP还广泛的用于准3G手机上。 H.264+AAC,H263+AAC dat(VCD),vob(DVD), mp4, 3gp Matroska 是一种新的多媒体封装格式，这个封装格式可把多种不同编码的视频及16条或以上不同格式的音频和语言不同的字幕封装到一个Matroska Media档内。它也是其中一种开放源代码的多媒体封装格式。Matroska同时还可以提供非常好的交互功能，而且比MPEG更方便、强大。 各种编码格式的组合 mkv Real Video Real Media（RM） 是由RealNetworks开发的一种档容器。它通常只能容纳Real Video和Real Audio编码的媒体。该档带有一定的交互功能，允许编写脚本以控制播放。RM，尤其是可变比特率的RMVB格式，没有复杂的Profile/Level，制作起来较H.264视频格式简单，非常受到网络上传者的欢迎。此外很多人仍有RMVB体积小高质量的错误认知，这个不太正确的观念也导致很多人倾向使用rmvb，事实上在相同码率下，rmvb编码和H.264这个高度压缩的视频编码相比，体积会较大。 RealVideo+RealAudio rm/rmvb QuickTime File Format 是由苹果公司开发的容器。1998年2月11日，国际标准化组织（ISO）认可QuickTime文件格式作为MPEG-4标准的基础。QuickTime可存储的内容相当丰富，除了视频、音频以外还可支持图片、文字（文本字幕）等。 H.264+AAC mov, qt MP4mp4格式是H.264编码指定使用的标准封装格式，3GP是MP4格式的一种简化版本，减少了储存空间和较低的频宽需求，让手机上有限的储存空间可以使用。 实际上这些封装格式对应的音频视频编码格式也不是固定的，就拿MP4来说，常见的MP4是由H.264+AAC封装，但是也由Xvid+AAC编码的可能。如果解码器不支持Xvid，则可能会出现无法播放，或者播放播放过程有声音无画面的情况。 苹果支持哪些音视频编码格式我们可以在手机介绍界面，找到手机支持的视频格式iPhone - Compare Models - Apple 这里我们可以找到对应iPhone7支持的视频编码格式： Video formats supported: HEVC, H.264, MPEG-4 Part 2, and Motion JPEG HEVC又叫H.265，iOS11+A9芯片才开始对HEVC的支持，iPhone6s及以前的设备不支持HEVC解码。音频格式用红框标出来了，内容较多，可自行对比。 AVPlayer支持哪些视频格式苹果设备支持音视频格式并不是就代表AVPlayer也支持那么多格式，确定AVPlayer的支持格式，我们可以查看AVKit中的一个API: 123456789101112131415161718192021222324252627282930313233343536373839404142434445//展示当前支持的音视频格式let asset = AVURLAsset.audiovisualTypes()//打印asset可以得到（已经转过展示格式）asset type ( \"audio/aacp\", \"video/3gpp2\", \"audio/mpeg3\", \"audio/mp3\", \"audio/x-caf\", \"audio/mpeg\", \"video/quicktime\", \"audio/x-mpeg3\", \"video/mp4\", \"audio/wav\", \"video/avi\", \"audio/scpls\", \"audio/mp4\", \"audio/x-mpg\", \"video/x-m4v\", \"audio/x-wav\", \"audio/x-aiff\", \"application/vnd.apple.mpegurl\", \"video/3gpp\", \"text/vtt\", \"audio/x-mpeg\", \"audio/wave\", \"audio/x-m4r\", \"audio/x-mp3\", \"audio/AMR\", \"audio/aiff\", \"audio/3gpp2\", \"audio/aac\", \"audio/mpg\", \"audio/mpegurl\", \"audio/x-m4b\", \"application/mp4\", \"audio/x-m4p\", \"audio/x-scpls\", \"audio/x-mpegurl\", \"audio/x-aac\", \"audio/3gpp\", \"audio/basic\", \"audio/x-m4a\", \"application/x-mpegurl\") 还有一个方式用来判断当前格式是否可播： 12//An extended MIME type string such as video/3gpp2; codecs=\"mp4v.20.9, mp4a.E1\" or audio/aac; codecs=\"mp4a.E1\".let playable: Bool = AVURLAsset.isPlayableExtendedMIMEType(\"video/3gpp2; codecs=\\\"mp4v.20.9, mp4a.E1\\\"\") 这里的MIMEType可以在这里找到System-Declared Uniform Type Identifiers 总结由此我们可以下一个总结，AVPlayer支持的：视频编码格式：H.264、HEVC(iPhone7及以后设备)、MPEG-4。视频格式（封装格式）：.mp4、.mov、.m4v、.3gp、.avi等。如果想支持更多的视频格式，可以使用使用第三方的框架，常用的视频编码和解码框架有VLC和ffmpeg。 参考文献视频文件格式 - 维基百科，自由的百科全书音频编码格式的比较 - 维基百科，自由的百科全书","link":"/2018/11/26/avplayer-supported-format/"},{"title":"iOS蓝牙中的进制转换","text":"最近在忙一个蓝牙项目，在处理蓝牙数据的时候，经常遇到进制之间的转换，蓝牙处理的是16进制（NSData），而我们习惯的计数方式是10进制，为了节省空间，蓝牙也会把16进制（NSData）拆成2进制记录。这里我们研究下如何在他们之间进行转换。 假设我们要向蓝牙发送0x1B9901这条数据 Byte转NSDataByte value[3]={0}; value[0]=0x1B; value[1]=0x99; value[2]=0x01; NSData * data = [NSData dataWithBytes:&amp;value length:sizeof(value)]; //发送数据 [self.peripheral writeValue:data forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse]; 优点：这种方法比较简单，没有进行转换，直接一个字节一个字节的拼装好发送出去。 缺点：当发送数据比较长时会很麻烦，而且不易更改。 NSString转NSData- (NSData *)hexToBytes:(NSString *)str { NSMutableData* data = [NSMutableData data]; int idx; for (idx = 0; idx+2 &lt;= str.length; idx+=2) { NSRange range = NSMakeRange(idx, 2); NSString* hexStr = [str substringWithRange:range]; NSScanner* scanner = [NSScanner scannerWithString:hexStr]; unsigned int intValue; [scanner scanHexInt:&amp;intValue]; [data appendBytes:&amp;intValue length:1]; } return data; } //发送数据 [self.peripheral writeValue:[self hexToBytes:@&quot;1B9901&quot;] forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse]; 优点：比较直观，可以一次转换一长条数据，对于一些功能简单的蓝牙程序，这种转换能处理大部分情况。 缺点：只能发送一些固定的指令，不能参与计算。 求校验和接下来探讨下发送的数据需要计算的情况。最常用的发送数据需要计算的场景是求校验和（CHECKSUM）。这个根据硬件厂商来定，常见的求校验和的规则有： 如果发送数据长度为n字节，则CHECKSUM为前n-1字节之和的低字节 CHECKSUM=0x100-CHECKSUM（上一步的校验和） 如果我要发送带上校验和的0x1B9901，方法就是： - (NSData *)getCheckSum:(NSString *)byteStr{ int length = (int)byteStr.length/2; NSData *data = [self hexToBytes:byteStr]; Byte *bytes = (unsigned char *)[data bytes]; Byte sum = 0; for (int i = 0; i&lt;length; i++) { sum += bytes[i]; } int sumT = sum; int at = 256 - sumT; printf(&quot;校验和：%d\\n&quot;,at); if (at == 256) { at = 0; } NSString *str = [NSString stringWithFormat:@&quot;%@%@&quot;,byteStr,[self ToHex:at]]; return [self hexToBytes:str]; } //将十进制转化为十六进制 - (NSString *)ToHex:(int)tmpid { NSString *nLetterValue; NSString *str =@&quot;&quot;; int ttmpig; for (int i = 0; i&lt;9; i++) { ttmpig=tmpid%16; tmpid=tmpid/16; switch (ttmpig) { case 10: nLetterValue =@&quot;A&quot;;break; case 11: nLetterValue =@&quot;B&quot;;break; case 12: nLetterValue =@&quot;C&quot;;break; case 13: nLetterValue =@&quot;D&quot;;break; case 14: nLetterValue =@&quot;E&quot;;break; case 15: nLetterValue =@&quot;F&quot;;break; default: nLetterValue = [NSString stringWithFormat:@&quot;%u&quot;,ttmpig]; } str = [nLetterValue stringByAppendingString:str]; if (tmpid == 0) { break; } } //不够一个字节凑0 if(str.length == 1){ return [NSString stringWithFormat:@&quot;0%@&quot;,str]; }else{ return str; } } //发送数据 NSData *data = [self getCheckSum:@&quot;1B9901&quot;];//data=&lt;1b99014b&gt; [self.peripheral writeValue:data forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse];拆分数据这种是比较麻烦的，举个栗子：在传输某条信息时，我想把时间放进去，不能用时间戳，还要节省空间，这样就出现了一种新的方式存储时间。这里再补充一些C语言知识： 一个字节8位（bit） char 1字节 int 4字节 unsigned 2字节 float 4字节 存储时间的条件是： 只用四个字节（32位） 前5位表示年（从2000年算起），接着4位表示月，接着5位表示日，接着5位表示时，接着6位表示分，接着3位表示星期，剩余4位保留。 这样直观的解决办法就是分别取出现在时间的年月日时分星期，先转成2进制，再转成16进制发出去。当然你这么写进去，读的时候就要把16进制数据先转成2进制再转成10进制显示。我们就按这个简单粗暴的思路来，准备工作如下： 10进制转2进制// 十进制转二进制 - (NSString *)toBinarySystemWithDecimalSystem:(int)num length:(int)length { int remainder = 0; //余数 int divisor = 0; //除数 NSString * prepare = @&quot;&quot;; while (true) { remainder = num%2; divisor = num/2; num = divisor; prepare = [prepare stringByAppendingFormat:@&quot;%d&quot;,remainder]; if (divisor == 0) { break; } } //倒序输出 NSString * result = @&quot;&quot;; for (int i = length -1; i &gt;= 0; i --) { if (i &lt;= prepare.length - 1) { result = [result stringByAppendingFormat:@&quot;%@&quot;, [prepare substringWithRange:NSMakeRange(i , 1)]]; }else{ result = [result stringByAppendingString:@&quot;0&quot;]; } } return result; } ### 2进制转10进制 // 二进制转十进制 - (NSString *)toDecimalWithBinary:(NSString *)binary { int ll = 0 ; int temp = 0 ; for (int i = 0; i &lt; binary.length; i ++) { temp = [[binary substringWithRange:NSMakeRange(i, 1)] intValue]; temp = temp * powf(2, binary.length - i - 1); ll += temp; } NSString * result = [NSString stringWithFormat:@&quot;%d&quot;,ll]; return result; } ### 16进制和2进制互转 - (NSString *)getBinaryByhex:(NSString *)hex binary:(NSString *)binary { NSMutableDictionary *hexDic = [[NSMutableDictionary alloc] init]; hexDic = [[NSMutableDictionary alloc] initWithCapacity:16]; [hexDic setObject:@&quot;0000&quot; forKey:@&quot;0&quot;]; [hexDic setObject:@&quot;0001&quot; forKey:@&quot;1&quot;]; [hexDic setObject:@&quot;0010&quot; forKey:@&quot;2&quot;]; [hexDic setObject:@&quot;0011&quot; forKey:@&quot;3&quot;]; [hexDic setObject:@&quot;0100&quot; forKey:@&quot;4&quot;]; [hexDic setObject:@&quot;0101&quot; forKey:@&quot;5&quot;]; [hexDic setObject:@&quot;0110&quot; forKey:@&quot;6&quot;]; [hexDic setObject:@&quot;0111&quot; forKey:@&quot;7&quot;]; [hexDic setObject:@&quot;1000&quot; forKey:@&quot;8&quot;]; [hexDic setObject:@&quot;1001&quot; forKey:@&quot;9&quot;]; [hexDic setObject:@&quot;1010&quot; forKey:@&quot;a&quot;]; [hexDic setObject:@&quot;1011&quot; forKey:@&quot;b&quot;]; [hexDic setObject:@&quot;1100&quot; forKey:@&quot;c&quot;]; [hexDic setObject:@&quot;1101&quot; forKey:@&quot;d&quot;]; [hexDic setObject:@&quot;1110&quot; forKey:@&quot;e&quot;]; [hexDic setObject:@&quot;1111&quot; forKey:@&quot;f&quot;]; NSMutableString *binaryString=[[NSMutableString alloc] init]; if (hex.length) { for (int i=0; i&lt;[hex length]; i++) { NSRange rage; rage.length = 1; rage.location = i; NSString *key = [hex substringWithRange:rage]; [binaryString appendString:hexDic[key]]; } }else{ for (int i=0; i&lt;binary.length; i+=4) { NSString *subStr = [binary substringWithRange:NSMakeRange(i, 4)]; int index = 0; for (NSString *str in hexDic.allValues) { index ++; if ([subStr isEqualToString:str]) { [binaryString appendString:hexDic.allKeys[index-1]]; break; } } } } return binaryString; }有了这几种转换函数，完成上面的功能就容易多了，具体怎么操作这里就不写一一出来了。但总感觉怪怪的，这么一个小功能怎么要写这么一大堆代码，当然还可以用C语言的方法去解决。这里主要是为了展示iOS中数据如何转换，C语言的实现方法这里就不写了，有兴趣的同学可以研究下。 附带两个函数int转NSData - (NSData *) setId:(int)Id { //用4个字节接收 Byte bytes[4]; bytes[0] = (Byte)(Id&gt;&gt;24); bytes[1] = (Byte)(Id&gt;&gt;16); bytes[2] = (Byte)(Id&gt;&gt;8); bytes[3] = (Byte)(Id); NSData *data = [NSData dataWithBytes:bytes length:4]; }NSData转int接受到的数据0x00000a0122 //4字节表示的int NSData *intData = [data subdataWithRange:NSMakeRange(2, 4)]; int value = CFSwapInt32BigToHost(*(int*)([intData bytes]));//655650 //2字节表示的int NSData *intData = [data subdataWithRange:NSMakeRange(4, 2)]; int value = CFSwapInt16BigToHost(*(int*)([intData bytes]));//290 //1字节表示的int char *bs = (unsigned char *)[[data subdataWithRange:NSMakeRange(5, 1) ] bytes]; int value = *bs;//34 ------------------------ //补充内容，因为没有三个字节转int的方法，这里补充一个通用方法 - (unsigned)parseIntFromData:(NSData *)data{ NSString *dataDescription = [data description]; NSString *dataAsString = [dataDescription substringWithRange:NSMakeRange(1, [dataDescription length]-2)]; unsigned intData = 0; NSScanner *scanner = [NSScanner scannerWithString:dataAsString]; [scanner scanHexInt:&amp;intData]; return intData; }这两个转换在某些场景下使用频率也是挺高的，蓝牙里面的数据转换基本也就这么多了，希望能够帮助大家。更多关于字节编码的问题，大家可以点这里：传送门 扩展基于CoreBluetooth4.0框架的连接BLE4.0的Demo：你不点一下吗","link":"/2016/12/12/bluetooth-number-transform/"},{"title":"AVPlayer详解系列（一）参数设置","text":"最近工作内容基本都是围绕视频播放展开的，从AVPlayer到IJKPlayer，期间遇到挺多问题，趟了很多bug，也总结了一些心得。对AVPlayer了解的更多一些，因为涉及点比较多，所以打算做一个系列详尽的写一下这部分内容。希望大家多多支持，有问题的地方欢迎指正。 思维导图先来一张思维导图，作为这篇文章的目录索引： 为什么使用AVPlayer：首先在iOS平台使用播放视频，可用的选项一般有这四个，他们各自的作用和功能如下： 使用环境 优点 缺点 MPMoviePlayerController MediaPlayer 简单易用 不可定制 AVPlayerViewController AVKit 简单易用 不可定制 AVPlayer AVFoundation 可定制度高，功能强大 不支持流媒体 IJKPlayer IJKMediaFramework 定制度高，支持流媒体播放 使用稍复杂 由此可以看出，如果我们不做直播功能AVPlayer就是一个最优的选择。 另外AVPlayer是一个可以播放任何格式的全功能影音播放器支持视频格式： WMV，AVI，MKV，RMVB，RM，XVID，MP4，3GP，MPG等。支持音频格式：MP3，WMA，RM，ACC，OGG，APE，FLAC，FLV等。支持视频格式： MP4，MOV，M4V，3GP，AVI等。支持音频格式：MP3，AAC，WAV，AMR，M4A等。详见AVPlayer支持的视频格式##如何使用AVPlayer存在于AVFoundation框架，我们使用时需要导入：#import &lt;AVFoundation/AVFoundation.h&gt; 几个播放相关的参数在创建一个播放器之前我们需要先了解一些播放器相关的类 AVPlayer：控制播放器的播放，暂停，播放速度 AVURLAsset : AVAsset 的一个子类，使用 URL 进行实例化，实例化对象包换 URL 对应视频资源的所有信息。 AVPlayerItem：管理资源对象，提供播放数据源 AVPlayerLayer：负责显示视频，如果没有添加该类，只有声音没有画面 我们这片文章就围绕这几个参数展开，光说这些你可能还有点不明白，那我们就围绕一个最简单的播放器做起，一点点扩展功能，在具体讲解这几个参数的作用。 最简单的播放器根据上面描述，我们知道AVPlayer是播放的必要条件，所以我们可以构建的极简播放器就是： 123NSURL *playUrl = [NSURL URLWithString:@\"http://baobab.wdjcdn.com/14573563182394.mp4\"];self.player = [[AVPlayer alloc] initWithURL:playUrl];[self.player play]; 是不是很简单，只有三行代码！但是它太简单了，仅可以完成音频的播放，连画面都没有。回看上面播放相关类的介绍，是因为缺少AVPlayerLayer；作为一个播放器，我不能只播放一条视频啊，我还想根据需要切换视频，那我们就得把AVPlayerItem也加上。加上这两个属性之后的播放器是这样的： 123456789NSURL *playUrl = [NSURL URLWithString:@\"http://baobab.wdjcdn.com/14573563182394.mp4\"];self.playerItem = [AVPlayerItem playerItemWithURL:playUrl];//如果要切换视频需要调AVPlayer的replaceCurrentItemWithPlayerItem:方法self.player = [AVPlayer playerWithPlayerItem:_playerItem];self.playerLayer = [AVPlayerLayer playerLayerWithPlayer:self.player];self.playerLayer.frame = _videoView.bounds;//放置播放器的视图[self.videoView.layer addSublayer:self.playerLayer];[_player play]; 现在的播放器稍微完整了一些，我们在自己创建的容器里可以看到画面了！ 更多功能但是它作为一个视频播放器，还是有很多不能让人满意的地方。例如：没有暂停、快进快退、倍速播放等，另外如果遇到url错误是不是还要有播放失败的提示，还有播放完成的相关提示。为完成这些，我们需要对AVPlayerItem和AVPlayerLayer进一步了解一下。 一、AVPlayer的控制前面讲过该类是控制视频播放行为的，他的使用比较简单。播放视频： 1[self.player play]; 暂停视频： 1[self.player pause]; 更改速度： 1self.player.rate = 1.5;//注意更改播放速度要在视频开始播放之后才会生效 还有一下其他的控制，我们可以调转到系统API进行查看 二、AVPlayerItem的控制AVPlayerItem作为资源管理对象，它控制着视频从创建到销毁的诸多状态。 1、播放状态 status12345typedef NS_ENUM(NSInteger, AVPlayerItemStatus) { AVPlayerItemStatusUnknown,//未知 AVPlayerItemStatusReadyToPlay,//准备播放 AVPlayerItemStatusFailed//播放失败}; 我们使用KVO监测playItem.status，可以获取播放状态的变化 1[self.playerItem addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionNew context:nil]; 在监听回调中： 12345678910111213141516171819202122232425- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{ if ([object isKindOfClass:[AVPlayerItem class]]) { if ([keyPath isEqualToString:@\"status\"]) { switch (_playerItem.status) { case AVPlayerItemStatusReadyToPlay: //推荐将视频播放放在这里 [self play]; break; case AVPlayerItemStatusUnknown: NSLog(@\"AVPlayerItemStatusUnknown\"); break; case AVPlayerItemStatusFailed: NSLog(@\"AVPlayerItemStatusFailed\") break; default: break; } } }} 虽然设置完播放配置我们可以直接调用[self.player play];进行播放，但是更稳妥的方法是在回调收到AVPlayerItemStatusReadyToPlay时进行播放 2、视频的时间信息在AVPlayer中时间的表示有一个专门的结构体CMTime 123456typedef struct{ CMTimeValue value; // 帧数 CMTimeScale timescale; // 帧率（影片每秒有几帧） CMTimeFlags flags; CMTimeEpoch epoch; } CMTime; CMTime是以分数的形式表示时间，value表示分子，timescale表示分母，flags是位掩码，表示时间的指定状态。 获取当前播放时间，可以用value/timescale的方式： 1float currentTime = self.playItem.currentTime.value/item.currentTime.timescale; 还有一种利用系统提供的方法，我们用它获取视频总时间： 1float totalTime = CMTimeGetSeconds(item.duration); 如果我们想要添加一个计时的标签不断更新当前的播放进度，有一个系统的方法： 1- (id)addPeriodicTimeObserverForInterval:(CMTime)interval queue:(nullable dispatch_queue_t)queue usingBlock:(void (^)(CMTime time))block; 方法名如其意， “添加周期时间观察者” ，参数1 interal 为CMTime 类型的，参数2 queue为串行队列，如果传入NULL就是默认主线程，参数3 为CMTime 的block类型。简而言之就是，每隔一段时间后执行 block。比如：我们把interval设置成CMTimeMake(1, 10)，在block里面刷新label，就是一秒钟刷新10次。 正常观察播放进度一秒钟一次就行了，所以可以这么写： 12345[self.player addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) queue:nil usingBlock:^(CMTime time) { AVPlayerItem *item = WeakSelf.playerItem; NSInteger currentTime = item.currentTime.value/item.currentTime.timescale; NSLog(@\"当前播放时间：%ld\",currentTime);}]; 3、loadedTimeRange 缓存时间获取视频的缓存情况我们需要监听playerItem的loadedTimeRanges属性 1[self.playerItem addObserver:self forKeyPath:@\"loadedTimeRanges\" options:NSKeyValueObservingOptionNew context:nil]; 在KVO的回调里: 1234567if ([keyPath isEqualToString:@\"loadedTimeRanges\"]){ NSArray *array = _playerItem.loadedTimeRanges; CMTimeRange timeRange = [array.firstObject CMTimeRangeValue];//本次缓冲时间范围 float startSeconds = CMTimeGetSeconds(timeRange.start); float durationSeconds = CMTimeGetSeconds(timeRange.duration); NSTimeInterval totalBuffer = startSeconds + durationSeconds;//缓冲总长度 NSLog(@\"当前缓冲时间：%f\",totalBuffer);} 4、playbackBufferEmpty监听playbackBufferEmpty我们可以获取当缓存不够，视频加载不出来的情况： 1[self.playerItem addObserver:self forKeyPath:@\"playbackBufferEmpty\" options:NSKeyValueObservingOptionNew context:nil]; 在KVO回调里： 123if ([keyPath isEqualToString:@\"playbackBufferEmpty\"]) { //some code show loading } 5、playbackLikelyToKeepUpplaybackLikelyToKeepUp和playbackBufferEmpty是一对，用于监听缓存足够播放的状态 123456[self.playerItem addObserver:self forKeyPath:@\"playbackLikelyToKeepUp\" options:NSKeyValueObservingOptionNew context:nil]; /* ... */if([keyPath isEqualToString:@\"playbackLikelyToKeepUp\"]) { //由于 AVPlayer 缓存不足就会自动暂停，所以缓存充足了需要手动播放，才能继续播放 [_player play]; } AVURLAsset播放视频只需一个url就能进行这样太不安全了，别人可以轻易的抓包盗链，为此我们需要为视频链接做一个请求头的认证，这个功能可以借助AVURLAsset完成。 AVPlayerItem除了可以用URL初始化，还可以用AVAsset初始化，而AVAsset不能直接使用，我们看下AVURLAsset的一个初始化方法： 1234567/*!@param URL An instance of NSURL that references a media resource.@param options An instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.*/+ (instancetype)URLAssetWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; AVURLAssetPreferPreciseDurationAndTimingKey.这个key对应的value是一个布尔值, 用来表明资源是否需要为时长的精确展示,以及随机时间内容的读取进行提前准备。 除了这个苹果官方介绍的功能外，他还可以设置请求头，这个算是隐藏功能了，因为苹果并没有明说这个功能，我是费了很大劲找到的。 12345 NSMutableDictionary * headers = [NSMutableDictionary dictionary];[headers setObject:@\"yourHeader\"forKey:@\"User-Agent\"];self.urlAsset = [AVURLAsset URLAssetWithURL:self.videoURL options:@{@\"AVURLAssetHTTPHeaderFieldsKey\" : headers}];// 初始化playerItemself.playerItem = [AVPlayerItem playerItemWithAsset:self.urlAsset]; 补充：后来得知这个参数是非公开的API，但是经多人测试项目上线不受影响。 播放相关通知1、声音类：1234//声音被打断的通知（电话打来）AVAudioSessionInterruptionNotification//耳机插入和拔出的通知AVAudioSessionRouteChangeNotification 根据userInfo判断具体状态 2、播放类123456//播放完成AVPlayerItemDidPlayToEndTimeNotification//播放失败AVPlayerItemFailedToPlayToEndTimeNotification//异常中断AVPlayerItemPlaybackStalledNotification 对于播放完成的通知我们可以这么写： 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playerMovieFinish:) name:AVPlayerItemDidPlayToEndTimeNotification object:[self.player currentItem]]; 3、系统状态1234//进入后台UIApplicationWillResignActiveNotification//返回前台UIApplicationDidBecomeActiveNotification 提示：所有通知和KVO的使用我们都要记得在不用时remove掉。 小结视频播放相关的知识比较多，细节的方面需要一点一点去扣。暂且写这么多吧，以后有需要会及时补充。参考：ZFPlayerAVPlayer那些坑如果还有什么不理解的可以简书私信问我，或者查看我写的Demo，欢迎star- ( ゜- ゜)つロ乾杯~","link":"/2017/08/25/avplayer-detail-1/"},{"title":"【译】设计模式引导--OOP的能力","text":"原文链接作者：Hitendra Solanki 导读–本博客系列要求具有面向对象编程的中级专业知识。您应该对类、对象、构造函数、继承、值和引用类型有基本的了解。通过仔细地从头到尾阅读本系列文章，不管是中级还是高级开发，您都将有所收获。 设计模式用于表示经验丰富的面向对象软件开发人员社区采用的最佳实践。 建造者模式帮助我们更简单更易读地创建一个类，它遵守着以下两条规则：1、分割原始类和它的构造方法2、在最后一个返回类的实例 建造者模式最佳的例子就是SwiftUI，是的你没有看错。SwiftUI中大部分类像是Text，Image都是使用的建造者模式。 问题：想一下，一个Person类拥有不少于十个属性，当你要使用它时，你需要为它创建一个构造方法。它的构造者将拥有不少于十个参数，去管理这么一个带有很多参数的单一函数或构造方式将是非常困难的，最终你也会让这端代码失去可读性。看下面的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Person { //personal details var name: String = \"\" var gender: String = \"\" var birthDate: String = \"\" var birthPlace: String = \"\" var height: String = \"\" var weight: String = \"\" //contact details var phone: String = \"\" var email: String = \"\" //address details var streeAddress: String = \"\" var zipCode: String = \"\" var city: String = \"\" //work details var companyName: String = \"\" var designation: String = \"\" var annualIncome: String = \"\" //constructor init(name: String, gender: String, birthDate: String, birthPlace: String, height: String, weight: String, phone: String, email: String, streeAddress: String, zipCode: String, city: String, companyName: String, designation: String, annualIncome: String) { self.name = name self.gender = gender self.birthDate = birthDate self.birthPlace = birthPlace self.height = height self.weight = weight self.phone = phone self.email = email self.streeAddress = streeAddress self.zipCode = zipCode self.height = height self.city = city self.companyName = companyName self.designation = designation self.annualIncome = annualIncome }}//This is function in Xcode-Playground which executes our test codefunc main() { let hitendra = Person(name: \"Hitendra Solanki\", gender: \"Male\", birthDate: \"2nd Oct 1991\", birthPlace: \"Gujarat, India\", height: \"5.9 ft\", weight: \"85kg\", phone: \"+91 90333-71772\", email: \"hitendra.developer@gmail.com\", streeAddress: \"52nd Godrej Street\", zipCode: \"380015\", city: \"Ahmedabad\", companyName: \"Fortune 500\", designation: \"Software architect\", annualIncome: \"45,000 USD\") //use of Person object print(\"\\(hitendra.name) works in \\(hitendra.companyName) compay as a \\(hitendra.designation).\")}//call main to execute our test code in Xcode-Playgroundmain()/* Console output:Hitendra Solanki works in Fortune 500 compay as a Software architect.*/ 将上面的例子在playground中运行一下，你会得到预期结果。逻辑上这也是对的。 我们可以尝试优化上面的代码，从解决这两个问题入手。1、我们必须按照既定的顺序传参数，而不能通过重新排列参数提高可读性。2、即使创建对象时我们不知道一些属性值，我们也不得不传入所有参数。 例如你需要创建一个Person类，但是这个人还在找工作。只有当他进入某一公司我们才能得到他的工作信息。 解决方案：1、创建相关属性的逻辑分组。2、为不同分组的属性创建不同的建造者类。3、在建造者类中最后一步返回实例。 让我们从上面的例子开始，我们已经拥有一个Person类，它含有14个属性。我们仔细观察这14个属性，可以将它分为四组。1、个人信息2、联系方式3、地址信息4、公司信息 通过强大的设计模式我们可以解决上面两个问题，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179//This is function in playground which executes our test codefunc main() { var hitendra = Person() //person with empty details let personBuilder = PersonBuilder(person: hitendra) hitendra = personBuilder .personalInfo .nameIs(\"Hitendra Solanki\") .genderIs(\"Male\") .bornOn(\"2nd Oct 1991\") .bornAt(\"Gujarat, India\") .havingHeight(\"5.9 ft\") .havingWeight(\"85 kg\") .contacts .hasPhone(\"+91 90333-71772\") .hasEmail(\"hitendra.developer@gmail.com\") .lives .at(\"52nd Godrej Street\") .inCity(\"Ahmedabad\") .withZipCode(\"380015\") .build() //use of Person object print(\"\\(hitendra.name) has contact number \\(hitendra.phone) and email \\(hitendra.email)\") //later on when we have company details ready for the person hitendra = personBuilder .works .asA(\"Software architect\") .inCompany(\"Fortune 500\") .hasAnnualEarning(\"45,000 USD\") .build() //use of Person object with update info print(\"\\(hitendra.name) works in \\(hitendra.companyName) compay as a \\(hitendra.designation).\")}//call main to execute our test codemain()//Person class which only contains the detailsclass Person { //personal details var name: String = \"\" var gender: String = \"\" var birthDate: String = \"\" var birthPlace: String = \"\" var height: String = \"\" var weight: String = \"\" //contact details var phone: String = \"\" var email: String = \"\" //address details var streeAddress: String = \"\" var zipCode: String = \"\" var city: String = \"\" //work details var companyName: String = \"\" var designation: String = \"\" var annualIncome: String = \"\" //empty constructor init() { }}//PersonBuilder class helps to construct the person class instanceclass PersonBuilder { var person: Person init(person: Person){ self.person = person } //personal details builder switching var personalInfo: PersonPersonalDetailsBuilder { return PersonPersonalDetailsBuilder(person: self.person) } //contact details builder switching var contacts: PersonContactDetailsBuilder { return PersonContactDetailsBuilder(person: self.person) } //address details builder switching var lives: PersonAddressDetailsBuilder { return PersonAddressDetailsBuilder(person: self.person) } //work details builder switching var works: PersonCompanyDetailsBuilder { return PersonCompanyDetailsBuilder(person: self.person) } func build() -&gt; Person { return self.person }}//PersonPersonalDetailsBuilder: update personal detailsclass PersonPersonalDetailsBuilder: PersonBuilder { func nameIs(_ name: String) -&gt; Self { self.person.name = name return self } func genderIs(_ gender: String) -&gt; Self { self.person.gender = gender return self } func bornOn(_ birthDate: String) -&gt; Self { self.person.birthDate = birthDate return self } func bornAt(_ birthPlace: String) -&gt; Self { self.person.birthPlace = birthPlace return self } func havingHeight(_ height: String) -&gt; Self { self.person.height = height return self } func havingWeight(_ weight: String) -&gt; Self { self.person.weight = weight return self }}//PersonContactDetailsBuilder: update contact detailsclass PersonContactDetailsBuilder: PersonBuilder { func hasPhone(_ phone: String) -&gt; Self { self.person.phone = phone return self } func hasEmail(_ email: String) -&gt; Self { self.person.email = email return self }}//PersonAddressDetailsBuilder: update address detailsclass PersonAddressDetailsBuilder: PersonBuilder { func at(_ streeAddress: String) -&gt; Self { self.person.streeAddress = streeAddress return self } func withZipCode(_ zipCode: String) -&gt; Self { self.person.zipCode = zipCode return self } func inCity(_ city: String) -&gt; Self { self.person.city = city return self }}//PersonCompanyDetailsBuilder: update company detailsclass PersonCompanyDetailsBuilder: PersonBuilder { func inCompany(_ companyName: String) -&gt; Self { self.person.companyName = companyName return self } func asA(_ designation: String) -&gt; Self { self.person.designation = designation return self } func hasAnnualEarning(_ annualIncome: String) -&gt; Self { self.person.annualIncome = annualIncome return self }}/* Console output: Hitendra Solanki has contact number +91 90333-71772 and email hitendra.developer@gmail.com Hitendra Solanki works in Fortune 500 compay as a Software architect. */ 在上面的例子中，我们把Person类根据职责分割成了几个不同的类。我们创建了多个建造者，他们分别管理相关分组内的属性，而Person只持有这些建造者。 我们拥有一个建造者基类PersonBuilder和四个衍生的建造者类，PersonPersonalDetailsBuilder, PersonContactDetailsBuilder, PersonAddressDetailsBuilder 和 PersonCompanyDetailsBuilder。 当其他四个从Personbuilder衍生出来的建造者需要更新相关属性时，Personbuilder这个基类可以帮助我们在它们之间进行转换。 在上面的例子中我们可以看到新的构造方法变得更加易读了，我们可以用一种更加优雅的方式更新一组或者某一个属性。 需要注意一下，上面的例子中我们再每个建造者更新方法之后返回了它自己。这让我们能够在相同的建造者中写出链式方法，而不是分开的多行。这个概念称为流程模式。 优点1、用一种优雅的方式很容易地初始化一个含很多参数的类。2、遵从单一职责原则。3、根据你的情况，以任意的顺序初始化对象和更新属性。","link":"/2019/08/20/builder_design_pattern_swift/"},{"title":"关于消息摘要及对应的Swift实现","text":"开发过程中我们经常会遇到对数据进行一些类似MD5，SHA-256等的处理，那处理的作用是什么以及为什么要这么做，就是今天要讨论的内容。如果你对这些算法的概念已经很熟悉，那就不用继续往下看了，如果你感觉生疏，或者并不能说清楚他们的作用，那就跟着我一起回顾一下吧。 从MD5说起我门从最常见的MD5说起。下面是维基百科对MD5的定义： MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。 MD5的概念中出现了两个名词：信息摘要算法 + 密码散列函数。我们再分别来看这两个概念的含义。 信息摘要算法消息摘要算法消息摘要是把任意长度的输入揉和而产生长度固定的伪随机输入的算法。 它具有以下特点： 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，一般认为，摘要的最终输出越长，该摘要算法就越安全。变长输入，定长输出。 一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。 消息摘要函数是单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。 好的摘要算法，没有人能从中找到“碰撞”，即无法找到两条不同的消息，使它们的摘要相同。 从理论上来说，不管使用什么样的摘要算法，必然存在2个不同的消息，对应同样的摘要。因为输入是一个无穷集合，而输出是一个有限集合。但是实际上，很难或者说根本不可能人为的造出具有同样摘要的2个不同消息。 密码散列函数：密码散列函数（Cryptographic hash function），又译为加密散列函数，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的数据是什么。 概念梳理这里比较重要的就是理解信息摘要，它概念就是把一段数据压缩成固定长度的数据，但是我们不能通过压缩后的数据反推原始数据。 有一种应用场景比较能说明问题：我们在登录的时候，对用户密码进行MD5计算之后再传到服务器，之后数据库显示的用户信息就是MD5之后的16字节字符串。管理员即使能访问用户数据库但他并不能由MD5处理之后的数据得知原始密码。而客户端这边却可以在输入密码之后，进行MD5计算然后与服务器密码进行比较。 SHA家族安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。 SHA的出现就是解决MD5不安全的问题，它是一种比MD5更安全的密码散列函数。 SHA家族的算法，由美国国家安全局（NSA）所设计，并由美国国家标准与技术研究院（NIST）发布，是美国的政府标准，其分别是： 名称 简介 应用范围 发布时间 SHA-0 SHA-1前身 - 1993 SHA-1 曾被视为MD5的后继者，但SHA-1的安全性在2000年以后已经不被大多数的加密场景所接受。 广泛 1995 SHA-2 包括SHA-224/SHA-256/SHA-384/SHA-512，目前并未被破解 广泛 2001 SHA-3 比SHA-2更安全的散列函数，并无替代SHA-2的计划 较小 2015 散列函数的安全性上面说到了MD5是不安全的，不安全意味着可以找到MD5的“碰撞”，就是两个文件可以产生相同的“指纹”。这意味着，当你在网络上使用电子签名签署一份合同后，还可能找到另外一份具有相同签名但内容迥异的合同，这样两份合同的真伪性便无从辨别。 2004年8月17日，在CRYPTO 2004的Rump会议上，王小云，冯登国、来学嘉，和于红波宣布了攻击MD5、SHA-0 和其他杂凑函数的初步结果。他们攻击SHA-0的计算复杂度是2的40次方，这意味着他们的攻击成果比Joux还有其他人所做的更好。 2005年二月，王小云和殷益群、于红波再度发表了对SHA-0破密的算法，可在2的39次方的计算复杂度内就找到碰撞。 2009年，中国科学院的谢涛和冯登国仅用了2的20.96次方的碰撞算法复杂度，破解了MD5的碰撞抵抗，该攻击在普通计算机上运行只需要数秒钟。 2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1。 摘要的Swift实现Swift有一个比较成熟的专门处理摘要，加密等安全相关的框架CryptoSwift。 以下是Swift对摘要算法的原生实现，需要引入CommonCrypto框架，这个已经内置到Xcode里面了，列出了对String和Data的摘要扩展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import Foundationimport CommonCryptoenum CryptoAlgorithm { case MD5, SHA1, SHA224, SHA256, SHA384, SHA512 var digestLength: Int { var result: Int32 = 0 switch self { case .MD5: result = CC_MD5_DIGEST_LENGTH case .SHA1: result = CC_SHA1_DIGEST_LENGTH case .SHA224: result = CC_SHA224_DIGEST_LENGTH case .SHA256: result = CC_SHA256_DIGEST_LENGTH case .SHA384: result = CC_SHA384_DIGEST_LENGTH case .SHA512: result = CC_SHA512_DIGEST_LENGTH } return Int(result) }}extension String { var md5: String { return digest(string: self, algorithm: .MD5) } var sha1: String { return digest(string: self, algorithm: .SHA1) } var sha224: String { return digest(string: self, algorithm: .SHA224) } var sha256: String { return digest(string: self, algorithm: .SHA256) } var sha384: String { return digest(string: self, algorithm: .SHA384) } var sha512: String { return digest(string: self, algorithm: .SHA512) } func digest(string: String, algorithm: CryptoAlgorithm) -&gt; String { var result: [CUnsignedChar] let digestLength = Int(algorithm.digestLength) if let cdata = string.cString(using: String.Encoding.utf8) { result = Array(repeating: 0, count: digestLength) switch algorithm { case .MD5: CC_MD5(cdata, CC_LONG(cdata.count-1), &amp;result) case .SHA1: CC_SHA1(cdata, CC_LONG(cdata.count-1), &amp;result) case .SHA224: CC_SHA224(cdata, CC_LONG(cdata.count-1), &amp;result) case .SHA256: CC_SHA256(cdata, CC_LONG(cdata.count-1), &amp;result) case .SHA384: CC_SHA384(cdata, CC_LONG(cdata.count-1), &amp;result) case .SHA512: CC_SHA512(cdata, CC_LONG(cdata.count-1), &amp;result) } } else { fatalError(\"Nil returned when processing input strings as UTF8\") } return (0..&lt;digestLength).reduce(\"\") { $0 + String(format: \"%02hhx\", result[$1])} }}extension Data { var md5: String { return digest(data: self, algorithm: .MD5) } var sha1: String { return digest(data: self, algorithm: .SHA1) } var sha224: String { return digest(data: self, algorithm: .SHA224) } var sha256: String { return digest(data: self, algorithm: .SHA256) } var sha384: String { return digest(data: self, algorithm: .SHA384) } var sha512: String { return digest(data: self, algorithm: .SHA512) } func digest(data: Data, algorithm: CryptoAlgorithm) -&gt; String { var result: [CUnsignedChar] let digestLength = Int(algorithm.digestLength) let pdata = (data as NSData).bytes result = Array(repeating: 0, count: digestLength) switch algorithm { case .MD5: CC_MD5(pdata, CC_LONG(data.count), &amp;result) case .SHA1: CC_SHA1(pdata, CC_LONG(data.count), &amp;result) case .SHA224: CC_SHA224(pdata, CC_LONG(data.count), &amp;result) case .SHA256: CC_SHA256(pdata, CC_LONG(data.count), &amp;result) case .SHA384: CC_SHA384(pdata, CC_LONG(data.count), &amp;result) case .SHA512: CC_SHA512(pdata, CC_LONG(data.count), &amp;result) } return (0..&lt;digestLength).reduce(\"\") { $0 + String(format: \"%02hhx\", result[$1])} }}","link":"/2019/02/27/digest_introduction/"},{"title":"【译】iOS13新特性抢鲜看","text":"原文链接作者：MacRumors Staff原文日期：2019-5-2 初览iOS13是苹果针对iPhone和iPad的下一代操作系统，将会在6月份的WWDC上和大家初次见面。传闻的功能包括夜间模式、iPad界面更新和新的主屏幕。 我们可以期待什么苹果位于加州的总部已经在开发iOS操作系统的下一个升级版本，该系统可以在iPhone、iPad和iPod touch上运行。 虽然目前我们对这款新软件的了解有限，但我们已经听到了一些有趣的传言，这些传言透露了一些我们有望在此次更新中看到的功能和变化，根据之前的更新，这次更新将被命名为“iOS 13”。iOS 12标志着苹果iOS开发政策的重大转变，工程师们现在有了更多的自由，可以在必要时推出尚未准备好的功能。 由于这个原因，iOS 13可能比之前的更新更加成熟，同时，任何未最终确定的功能都有可能被推迟。 由于苹果在iOS 12到iOS 13之间专注于bug修复和底层改进所引起的延迟，我们已经获取了惊人数量的泄漏信息，所以可以预见6月份iOS 13不少的特性。 我们可以预见的功能包括夜晚模式，音量外观的改变，iPad上关于多任务的更新，新的撤销手势，一个合并了“寻找手机”和“寻找朋友”的APP：“寻找我的手机”，闹钟和邮件的更新，以及像iOS app可以很容易的在Mac上使用这样的扩平台能力。 我们有望在6月份的WWDC首次一睹iOS 13的风采，届时将正式发布新款iPhone。开发者和开放的测试人员将更早一点使用到这次更新，beta版本系统测试期间，我们也会在MacRumors.com上持续跟进新的特性和改变。 可能的特性夜间模式iOS 13将首次拥有夜间模式，这个功能iOS用户已经期盼了相当一段时间了。这个夜间模式和MacOS Mojave里的夜间模式相呼应，它会会使用户拥有一个更好的夜晚观看体验。今年的WWDC里有一张夜间主题的效果图，可能正暗示了即将到来的iOS 13的夜间模式。 iPad调整iOS 13中将有几个特性是关于iPad的。据说，苹果将推出一项功能，可以在一个iPad应用程序中使用tab视图显示多个窗口。改进的多任务处理功能将在iOS 13中实现，iPad应用程序支持多个窗口和应用程序内的可堆叠卡。应用程序的特点是，最初附加在屏幕某一部分上的表格，可以通过拖动手势分离，变成一张可以操纵的卡片。 卡片可以叠在另一张上面，深度效果将指示卡片的上下效果，快速滑动卡片将使它消失。 新的手势iPad或将拥有一个新的对于标准文本输入时的撤销手势，用户可以通过三根手指轻敲键盘区域，然后向左或者向右滑动，就可以撤销或者重做一个动作。 新的手势将允许用户在表视图和集合视图中选择多个项目，允许他们在项目列表上拖动多个手指来绘制选择，类似于Mac上的单击和拖动Finder。 音量指示器更新iOS 13获奖包含一个新的音量指示器，它会比现在的指示器样式更缓和。 邮件新的邮件app将把邮件内容分成市场、购买、旅游、不重要、更多等可搜索分类。此外还有一个稍后阅读的队列和一个针对特殊邮件线程的静音收件选项。 跨平台的iOS和Mac应用在iOS 12和macOS Mojave的时候，苹果引入了一个新框架桥接iOS和Mac之间的应用，作为测试，像股票、家庭和录音等iOS独享的app被发布到macOS上。在iOS 13和macOS10.15, 苹果计划向开发者扩大这个功能，这将使得应用从iOS平台到Mac上的迁移更加容易。 新版“找到我的手机”苹果正在开发一个融合“查找朋友”和“查找iPhone”的新应用，它很可能会随着iOS 13和macOS 10.15一同发布。该应用程序将包括一个新的“查找网络”功能，允许苹果设备被跟踪，即使没有连接到Wi-Fi或蜂窝网络，原理是利用附近的其他设备。 这个应用将包括已有的查找手机功能，像丢失模式、远程擦除设备。从“查找朋友”中提取的基于位置的共享选项也仍然可用。 据说苹果还在研究一个相关的硬件产品，像是瓦片一样的跟踪器。它被描述为一个“标签”，能够附着在任何设备上，并且通过用户的iCloud账号进行配对。当用户距离他们绑定的设备太远的话，这个小东西就会发出报警声，它是基于与iPhone之间的距离工作的。苹果没说什么时候发布它，但是有可能是跟新版iPhone一同发布。 地图新版的地图应用将使哪些常用地址像是家或者公司的设置和导航更简单。频繁使用的地址信息将会更高效的分类，并且可以为他们配上图片。 提醒事项一个新的提醒应用程序将在一个网格中包含四个默认部分，包括今天要完成的任务、所有任务、计划任务和标记任务。 图书新版的图书应用将包含一个新的进度追踪功能和一个旨在鼓励用户阅读的奖励系统。 家庭新的家庭应用将更好地与安全摄像头集成，并将提供一项无需第三方应用就能查看过去录音的功能。 健康新的健康应用将有一个改良的每日活动视图和更加全面的月经周期跟踪。还会有一个“听力健康”的功能，它可以测量你耳机和周围环境的音量。 其他新功能速度提升和bug修复iOS 13和iOS 12很像，将会提高运行速度，并修复一个bug。 键盘将会有一个新的默认的基于滑动的键盘可用，类似于SwiftKey。 字体字体管理将在iOS 13中得到改进，设置应用程序将获得一个新的字体管理菜单。 更新分享栏在iOS 13中，用于共享照片和web链接的共享表单界面将变得更加智能，这意味着用户可以向其中发送内容。 Safari在iPad的iOS 13系统中，Safari会在必要时自动加载桌面版本的网站。苹果正在测试一款Safari下载管理器，用户可以在一个地方下载。 照片实况更新苹果计划将照片实况的视频长度延长至原来的两倍，也就是从3秒变成6秒。 嗨Siri”嗨Siri“将会更好的过滤像是笑声和孩子哭声这种环境音。 屏幕使用时间屏幕使用时间功能将增加一个新功能用于限制孩子对手机的使用，可以设定一个可以和不可以玩的时间。 界面的更新当启动多任务处理面板并关闭应用程序时，将会有一个新的动画，iPad的主屏幕将会发生一些变化。 文件应用的修改虽然关于一个改版后的文件应用程序会是什么样子的细节很少，但据说苹果正在为它开发新的功能，比如更好的第三方软件集成。 新版的Emojis新表情符号将不会在iOS 13发布时出现，但在2019年晚些时候的iOS 13更新中，苹果将会引入他们。Unicode联盟已经确定了加入表情符号标准的字符，其中包括火鸟、水獭、华夫饼、树懒、白心、牵手的人、冰块、潜水器、猩猩、果汁盒、沙拉三明治等等。 辅助功能一个更全面的辅助功能菜单将出现在设置应用程序的主页上，其中包括改进的助听器支持等。 iPad Pro支持鼠标有传言称，苹果公司可能计划在iPad Pro上添加USB鼠标支持，作为一项辅助功能，而不需要使用适配器。 据报道，iPad Pro的USB-C接口将允许你插入USB鼠标，作为那些无法使用触摸屏的用户的另一种输入方式。目前还不清楚该功能何时会实现，但它最早可能在iOS 13中实现。 跟开发者相关的变化对于开发者来说，iOS 13将为媒体播放、搜索、语音呼叫、活动票务、消息附件、航班等功能带来改进的Siri集成。 其他面向开发者的功能还包括ARKit的改进，它为增强现实提供了一个全新的快速框架，以及一个配套的应用程序，让开发者可以在视觉上创建增强现实体验。ARKit还将支持游戏控制器和立体声AR耳机。 新框架将包括扩展使用Taptic引擎，对第三方应用程序的文档扫描支持，以及无需使用照片应用程序即可从外部设备捕捉照片的功能。 NFC将得到改进，开发人员将能够在他们的应用程序中添加对扩展的NFC格式的支持，并且还将添加CoreML的更新版本。","link":"/2019/05/10/iOS13_new_features/"},{"title":"《图解TCP/IP》总结","text":"最近刚把《图解TCP/IP》翻了一遍，是有很多收获，但是还有很多东西不是太懂。又因为计算机网络涉及的内容多且杂，所以有了这篇记录性质的文章。 网络基础知识计算机网络最重要的一个概念就是协议，简单来说，协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备，不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能实现通信。 那这个协议由谁来规定呢，ISO（国际标准化组织）制定的一个国际标准OSI（开放式通信系统互联参考模型）。本书将要说明的TCP/IP并非ISO所制定的某种国际标准，而是由IETF（互联网工程任务组）所建议的致力于推进标准化作业的一种协议。这里提一下，通常OSI只是一种参考模型，他将网络分层，但是它并没有规定任何具体的协议，协议内容则归属为TCP/IP。 OSI参考模型中各个分层的作用： 传输方式的分类面向有连接型：在发送数据之前，需要在收发主机之间连接一条通信线路。比如打电话，必须对方接通才能开始通话。 面向无连接型：不要求建立连接和断开连接，发送端可以任何时候发送数据，接收端也永远不知道自己何时会收到数据。 分组交换：让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送，就是分组交换。有了分组交换，数据被细分，所有计算机可以一起收发数据，这样也就提高了通信线路的利用率。TCP/IP正是采用了分组交换技术。 单播（Unicast）：一对一通信，早先的固定电话就是单播通信的典型例子。 广播：将消息从1台主机发送到与之相连的所有其他主机。典型例子就是电视播放。 多播与广播类似，将消息发到多个接收主机，不同之处在于多播要限定某一组主机作为接收端，最典型的例子就是电话会议。 任播从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息，通常，所被选中的那台特定主机将返回一个丹波信号，随后发送端主机会只跟这台主机进行通信。任播在实际网络中的应用有DNS根域名解析服务器。 地址TCP/IP通信中使用MAC地址、IP地址、端口号等信息作为地址标识。 地址很重要的两个属性是唯一性和层次性。 MAC地址由设备的制造厂商对每块网卡进行分别制定。人们可以通过制造商识别号、制造商内部产品编号以及产品通用编号确保MAC地址的唯一性。但并不具有层次性。IP地址因具有网络号和主机号而具有层次性。 TCP/IP基础知识TCP/IP的诞生 TCP/IP的具体含义从字面意义上讲，有时这就是指TCP和IP两种协议，但是更多情况下，他是利用IP进行通信时所必须用到的协议群统称。 TCP/IP规范–RFC前面提到的TCP/IP的协议由IEFT讨论制定，被人们列入RFC(Request For Comment)文档并公布到互联网上。RFC不仅记录了协议规范内容，还包含了协议的实现和运用的相关信息，以及实验方面的信息。 可以通过RFC Editor查看RFC所有内容。 TCP/IP协议分层模型 这个就是常被问及网络分层模型，它有两种，一种是OSI7层模型；一种是TCP/IP的5层模型，也有一种分法是4层模型，是将5层模型中的网卡层和硬件层合为网络接口层。 物理层（硬件）TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。 主要功能是：利用传输介质为数据链路层提供物理连接，负责处理数据传输并监控数据出错率，以便数据流的透明传输。 数据链路层（网络接口层）网络接口层（有时人们也将网络接口层与硬件层合并起来称作网络通信层。） 利用以太网中的数据链路层进行通信，因此属于接口层。也就是说，把它当做让NIC起作用的“驱动程序”也无妨。 网络层（互联网层）网络层(Network layer)是参考模型的第3层。主要功能是：为数据在结点之间传输创建逻辑链路，通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现拥塞控制、网络互联等功能。 IPIP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。 ICMP(Internet Control Message Protocol)IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能而制定的。它有时也被用来诊断网络的健康状况。 ARP(Address Resolution Protocol)地址解析协议，从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。 传输层传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。 TCPTCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。 TCP首部其中控制位是用于连接管理的标记位，字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如下所示。 连接管理TCP会在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答（TCP中发送第一个SYN包的一方叫做客户端，接收这个的一方叫做服务端。） 。如果对端发来确认应答，则认为可以进行数据通信。如果对端的确认应答未能到达，就不会进行数据通信。此外，在通信结束时会进行断开连接的处理（FIN包）。 可以使用TCP首部用于控制的字段来管理TCP连接。一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成（建立一个TCP连接需要发送3个包。这个过程也称作“三次握手”。） 。 UDPUDP是User Datagram Protocol的缩写。 UDP有别于TCP，它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。 由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下几个方面： 包总量较少的通信（DNS、SNMP等） 视频、音频等多媒体通信（即时通信） 限定于LAN等特定网络中的应用通信 广播通信（广播、多播） UDP首部 应用层（会话层及以上分层）TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。因此，细看TCP/IP的应用程序功能会发现，它不仅实现OSI模型中应用层的内容，还要实现会话层与表示层的功能。 FTP在FTP中进行文件传输时会建立两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接（这两种连接的控制管理属于会话层的功能。） 远程登录（TELNET和SSH）远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能。TCP/IP网络中远程登录常用TELNET（TELetypewriter NETwork的缩写。有时也称作默认协议。） 和SSH（SSH是Secure SHell的缩写。） 两种协议。 发送数据包假设甲给乙发送电子邮件，内容为：“早上好”。而从TCP/IP通信上看，是从一台计算机A向另一台计算机B发送电子邮件。这一过程可以用如下图示表示： 应用协议HTTP当用户在浏览器的地址栏里输入所要访问Web页的URI以后，HTTP的处理即会开始。HTTP中默认使用80端口。它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。 HTTP中常用的有两个版本，一个HTTP1.0，另一个是HTTP1.1。在HTTP1.0中每一个命令和应答都会触发一次TCP连接的建立和断开。而从HTTP1.1开始，允许在一个TCP连接上发送多个命令和应答（这种方式也叫保持连接（keep-alive）。） 。由此，大量地减少了TCP连接的建立和断开操作，从而也提高了效率。 多媒体实现技术由于TCP具有流控制、拥塞控制、重发机制等功能，有时应用所发出去的数据可能无法迅速到达对端目标主机。然而在互联网电话（使用的VoIP（Voice Over IP的缩写。） ）和电视会议当中，即使有少许丢包，也希望系统延时少一点，非常注重系统的即时性。因此，在实时多媒体通信当中采用UDP。 然而，只使用UDP还不足以达到进行实时多媒体通信的目的。例如，在互联网电视电话议会中需要提供查询对方号码、模拟电话机的拨号以及以什么形式交互数据等功能。为此，需要一个叫做“呼叫控制”的支持。呼叫控制主要采用H.323与SIP协议。此外，还需要RTP协议（结合多媒体数据本身的特性进行传输的一种协议）和压缩技术（在网络上传输音频、视频等大型多媒体数据时进行压缩）的支持。 H.323H.323是由ITU开发用于在IP网上传输音频、视频的一种协议。起初，它主要是作为接入ISDN网和IP网之上的电话网为目的的一种规范而被提出的。 H.323定义了4个主要组件。它们分别是终端（用户终端）、网关（吸收用户数据压缩顺序的不一致性）、网闸（电话本管理、呼叫管理）以及多点控制单元（允许多个终端同时使用）。 SIP与H.323相对的TCP/IP协议即是SIP（Session Initiation Protocol）协议。 “终端之间进行多媒体通信时，需要具备事先解析对方地址、呼出对方号码并对所要传输的媒体信息进行处理等功能。此外，还需要具备中断会话和数据转发的功能。这些功能（呼叫控制与信令）都被统一于SIP协议中。它相当于OSI参考模型中的会话层。 RTP和RTCPUDP不是一种可靠性传输协议。因此有可能发生丢包或乱序等现象。因此采用UDP实现实时的多媒体通信需要附加一个表示报文顺序的序列号字段，还需要对报文发送时间进行管理。这些正是RTP（Real-Time Protocol）的主要职责。 RTP为每个报文附加时间戳和序列号。接收报文的应用，根据时间戳决定数据重构的时机。序列号则根据每发出一次报文加一的原则进行累加。RTP使用这个序列号对同一时间戳的数据（尤其是对于视频的数据。视频中一个帧的数据往往要超过一个包，然而它们发送的时间戳一致。此时就可以使用同一时间戳内不同的序列号加以区分。） 进行排序，掌握是否有丢包的情况发生。 RTCP（RTP Control Protocol）是辅助RTP的一种协议。通过丢包率等线路质量的管理，对RTP的数据传送率进行控制。 TLS/SSL与HTTPS对于一些涉及机密信息的网络连接需要进行加密处理，Web中可以通过TLS/SSL（Transport Layer Security/Secure Sockets Layer。由网景公司最早提出的名称叫SSL，标准化以后被称作TLS。使用TLS/SSL的HTTP通信叫做HTTPS通信。 HTTPS中采用对称加密方式。而在发送其公共密钥时采用的则是公钥加密方式（对称加密虽然速度快，但是密钥管理是巨大的挑战。公钥加密密钥管理相对简单，但是处理速度非常慢。TLS/SSL将两者进行取长补短令加密过程达到了极好的效果。由于谁都可以发送公钥，使得密钥管理更为简单。） 。 确认公钥是否正确主要使用认证中心（CA（Certificate Authority） ）签发的证书，而主要的认证中心的信息已经嵌入到浏览器的出厂设置中。如果Web浏览器中尚未加入某个认证中心，那么会在页面上提示一个警告信息。此时，判断认证中心合法与否就要由用户自己决定了。 IEEE802.1XIEEE（The Institute of Electronical and Electronics Engineers，美国电子和电气工程师协会）委员会中，依据不同的工作小组制定了各种局域网技术标准。因于1980年2月启动局域网国际标准化项目，所以命名为802。 IEEE802.1X是为了能够接入LAN交换机和无线LAN接入点而对用户进行认证的技术（包括我们常用的WiFi）并且它只允许被认可的设备才能访问网络。虽然它是一个提供数据链路层控制的规范，但是与TCP/IP关系紧密。一般，由客户端终端、AP（无线基站）或2层交换机以及认证服务器组成。 蓝牙蓝牙与IEEE802.11b/g类似，是使用2.4GHz频率无线电波的一种标准（因此，当IEEE802.b/g等设备与蓝牙设备一起使用时，无线电波信号削减有可能导致通信性能的下降。） 。数据传输速率在V2中能达到3Mbps（实际最大吞吐量为2.1Mbps）。通信距离根据无线电波的信号的强弱，有1药看看吧3 B、10药看看吧3 B、100药看看吧3 B三种类型。通信终端最多允许8台设备（其中一台为主节点，其他1～7台为受管节点。这种网络也叫做piconet，微微网。） 。 如果说IEEE802.11是针对笔记本电脑这样较大的计算机设备的标准，那么蓝牙则是为手机或智能手机、键盘、鼠标等较小设备而设计的标准。","link":"/2019/08/31/diagram_tcpip_concepts/"},{"title":"iOS开发月报#13|201907","text":"这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。欢迎推荐内容，可以前往zhangferry/iOSMonthlyReport提交issue。 TipsGolbal queues的优先级如果要在后台执行非UI相关的工作, 一般把这部分工作放在Global queue. Global queue是一种系统内共享的并行的队列。申请Global queue的方法很简单: 1let userQueue = DispatchQueue.global(qos: .userInitiated) 其中后面的.userInitiated参数代表队列的优先级。该优先级公有6中分类，有高到低为：userInteractive&gt;default&gt;unspecified&gt;userInitiated&gt;utility&gt;background通过该段代码验证： 12345678910111213141516171819202122232425for i in 1...3 { DispatchQueue.global(qos: DispatchQoS.QoSClass.default).async { NSLog(\"DispatchQoS.QoSClass.default, %d\", i) } DispatchQueue.global(qos: DispatchQoS.QoSClass.background).async { NSLog(\"DispatchQoS.QoSClass.background, %d\", i) } DispatchQueue.global(qos: DispatchQoS.QoSClass.unspecified).async { NSLog(\"DispatchQoS.QoSClass.unspecified, %d\", i) } DispatchQueue.global(qos: DispatchQoS.QoSClass.userInitiated).async { NSLog(\"DispatchQoS.QoSClass.userInitiated, %d\", i) } DispatchQueue.global(qos: DispatchQoS.QoSClass.userInteractive).async { NSLog(\"DispatchQoS.QoSClass.userInteractive, %d\", i) } DispatchQueue.global(qos: DispatchQoS.QoSClass.utility).async { NSLog(\"DispatchQoS.QoSClass.utility, %d\", i) }} 其中userInitiated为LIFO(后进先出)，即如果有新插入的userInteractive级别的队列任务，为先执行新任务之后再执行之前该级别任务。其余优先级的队列任务均是FIFO(先进先出)。 “No such module” when using @testable in Xcode Unit tests因为测试工程和主工程分属不同Module，所以如果我们想在测试项目中调用主工程代码需要导入主工程： 1@testable import moduleName 这个时候如果报以上错误，会有以下可能：1、targetName错误这个可以去Target-&gt;Build Setting-&gt;Product Module Name确认。2、主工程和测试模块支持版本号不一致保证Build Setting-&gt;iOS Deployment Target中的版本号在主工程和测试工程中一致。 authenticating with the app store上传卡顿如果往AppStoreConnect传包一直卡在这个步骤，可以试一下这种方式：第一步：cd ~第二步：mv .itmstransporter/ .old_itmstransporter/第三步：&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter&quot;等待执行完成。 订阅的freetrial没有标明截止时间被拒如题，如果订阅功能含freetrial，一定要在freetrial按钮旁边标清楚试用的截止时间。 WakaTime一款能够统计开发时间的网页端应用，支持众多IDE。集成到IDE之后，注册账号然后会获取到一个Key，绑定该值。然后当我们愉快的开发时，一些开发的信息就会被记录下来。我们可以通过其网页端的dashboard查看我们开发的情况。因为前几天升级XCode，需要重新装插件，所以最近几天的开发记录为空。 Lookin | 免费好用的iOS UI调试软件出自QMUI团队，可能是小集的影响力已经很大了，这个软件首发之后竟发现已经有一众人开始关注这个东西了。可能因为UI调试这个操作是一个高频的行为，而Xcode目前又做的不够好，所以大家都期待有一个高效的UI调试工具。我也是下下来试了下，结合之前对Reveal和Sherlock的使用，说下自己的体会吧，首先是优点：1、免费2、支持动态修改UI元素属性，例如位置，颜色，圆角这些3、可以查看CALayer的信息因为是刚发布没多久，还是有些需要改进的地方的1、动态修改UI元素的信息，均是通过UIView，和CALayer的信息进行修改，无法实现像UILabel改文案，更新行数等操作2、3D的渲染有时候会有bug出现，位置不正确，另外仅支持一个左右的旋转不支持上下3、屏幕适配还不支持，不能修改屏幕其实我对sherlock也都仅限于使用，中和频率不高的使用性和高昂的费用，我选择试用结束就放弃，虽然Lookin还存在一些不足，但是免费大于一切啊，希望可以做的更好，为更多开发者带来便利。 GithubR.swiftAndroid开发中引用资源可以通过R机制，所谓R机制就是在我们创建一个Android项目的时候，IDE会自动帮我们创建一个名为R的类型，它所在的文件名称也是叫做R.java，R类型中没有任何方法，包含的是代表不同类型资源的内部静态类，而这些内部静态类中，也只有静态的属性，每个属性代表一个资源，故我们要引用某个资源类型中的某个资源，可用R.资源类型.资源名来引用。下面就是代码中的实例： 12// 从图片资源文件夹中加载名为\"image_test\"的图片以其创建位图Bitmap aBitmap = BitmapFactory.decodeResource(this.getResources(), R.drawable.image_test); 相对来说iOS中的资源引用就麻烦很多，需要通过字符串引用，无法代码补全，资源更换无法自检查。解决iOS资源引用的这些问题而借鉴Android方案的R.Swift应运而生。传统的方式： 12let settingsIcon = UIImage(named: \"settings-icon\")let gradientBackground = UIImage(named: \"gradient.jpg\") 使用R.Swift 12let settingsIcon = R.image.settingsIcon()let gradientBackground = R.image.gradientJpg() 不光图片，它还支持Fonts，Resource files，Colors，Localized strings，Storyboards，Segues，Nibs，Reuseable Cells。我第一次见到这玩意的时候就一个感受：wocao，🐂🍺！更多关于R.Swift的使用规则参照官网说明。 Swift-Booksgithub上的内容，可以分为两类，纯干货和干货的整理。这个库属于后者，是一个收录Swift&amp;Object-C相关资料的仓库。收录的都是比较经典的学习资料，而且非常全！建库已经两年了，但是star却不多，不知道是因为曝光度的问题，还是因为大家对设计版权问题的内容有些警惕。但不管怎样吧，我还是要推一推这个库。 open-source-ios-apps开源的iOS应用列表。基本涵盖了iOS开发涉及的所有领域，通过完整的app去学习别人的开发技巧是一个相对直观的方式，面对这个大礼包，记得来看一看哈。 Chinese-Podcasts中文博客的收录，包含科技，风投，生活，电影，设计等领域。音频内容最大的优势就是便捷，你可以在走路，跑步，甚至休息的时候使用它。音频相比视频还有一个更大的好处是，它会给大脑预留更多的想象空间，听音频我们会思考的更多一些。去年一直在听东吴同学会，最近一段时间则听ggtalk和硅谷早知道多一些。 文摘1、 生存是一种即时策略游戏，所有的人都是这场游戏的玩家。财务自由了，就是游戏赢家。–《科技爱好者周刊：66期》 2、 我以为别人尊重我，是因为我很优秀。慢慢的我明白了，别人尊重我，是别人很优秀；优秀的人更懂得尊重别人，对人恭敬其实是在庄严你自己。 3、 所谓成熟的人，就是精神上能够自给自足的人。","link":"/2019/07/31/monthly_13/"},{"title":"iOS开发月报#12|201906","text":"这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。欢迎推荐内容，可以前往zhangferry/iOSMonthlyReport提交issue。 Tips闪光动画图片上的闪光动画，类似这种效果：分析拆解可知这是一个带透明的白色渐变移动产生的效果。渐变+移动，我们可以使用CAGradientLayer + CABasicAnimation实现： 1234567891011121314151617181920212223func showGradientAnimation() { let gradient = CAGradientLayer() gradient.frame = canvasView.bounds //左上角到右下角的渐变 gradient.startPoint = CGPoint(x: 0, y: 0) gradient.endPoint = CGPoint(x: 1, y: 1) gradient.locations = [0.0, 0.0, 0.0] //调透明度渐变要使用白色 gradient.colors = [UIColor.init(white: 1, alpha: 0.0).cgColor, UIColor.init(white: 1, alpha: 0.3).cgColor, UIColor.init(white: 1, alpha: 0.0).cgColor] canvasView.layer.addSublayer(gradient) let animation = CABasicAnimation.init(keyPath: \"locations\") //从0位置开始从1位置结束 animation.fromValue = [0, 0, 0.3] animation.toValue = [0.7, 1, 1] animation.duration = gradientAnimationDuration animation.repeatCount = 1 animation.isRemovedOnCompletion = true gradient.add(animation, forKey: nil)} 集成Universal Links时的几点注意事项这个是onlink总结对于各个平台对应用间跳转的支持情况，其中deeplink指Universal Links： 跳转至facebook指定页面如果是facebook某一主页，可以通过： 123//这里可以替换成自己的主页idlet url = URL(string: \"fb://page?id=**\")! UIApplication.shared.open(url, options: [:], completionHandler: nil) 这是使用了app scheme的方式进行跳转的，要求本机安装了facebook才能跳转成功。 如果是跳转到某一个主页的某一个帖子，可以通过： 123//这里替换成固定的帖子链接let url = URL(string: \"https://www.facebook.com/**/posts/**\")! UIApplication.shared.open(url, options: [:], completionHandler: nil) 这是通过Universal Links方式跳转的，该链接可以通过苹果的验证。如果未安装应用会跳转到网页端，如果安装了就直接跳到指定页面。 那正常来说，facebook主页也应该可以通过支持deep link的https链接跳转才对，但实际测试来看是不行的。所以如果要加上是否安装的逻辑的话，就是： 123456let url = URL(string: kFacebookHomePageSchemeUrl)!if UIApplication.shared.canOpenURL(url) { UIApplication.shared.open(url, options: [:], completionHandler: nil) } else { UIApplication.shared.open(URL(string: kFacebookHomePageUrl)!, options: [:], completionHandler: nil)} 测试：推荐：将连接复制到便签，邮件，短信，或者使用二维码的形式使用。 不要将链接粘贴到 Safari 中 - iOS 目前阻止从任何浏览器的地址栏进行深度链接。 验证apple-app-site-association的连接，可以苹果的验证工具 lottie动画效果在安卓和网页端正常在iOS端不正常在一次使用lottie调用设计提供的动画时，该动画是一个放烟花，然后散开的动画。用网页预览可以完美展示效果，但是放到客户端运行时，却只展示一部分即烟花上飞过程，而没有散开效果。最后仔细查看文档，找到这个：经设计确认，烟花绽放的效果使用了AE中的Repeater（中继器）控件，而该控件在lottie的3.0版本还不支持，但是在2.5.2版本是支持的，回退版本至2.5.2解决了动画确认问题。 PS：一些古怪问题，第一反应要从官网文档说明、Issues、QA中找答案 几个产品相关概念ROI(return on investment)：投资回报率反应产品的盈利情况，用百分比表示。市场营销、运营活动，都是企业获利为出发点，通过利润/投资量化目标。利润的计算涉及财务，很多时候用更简单的收入作分子。当运营活动的ROI大于1，说明这个活动是成功的，能赚钱。ecpm(effective cost per mille)：每千次展示可以获得的广告收入这是广告主预估自身收益的指标。arpu(Average Revenue Per User)：每用户平均收入ARPU注重的是一个时间段内运营商从每个用户所得到的利润。很明显，高端的用户越多，ARPU越高。LTV(life time value)：生命周期总价值意为客户终生价值，是公司从用户所有的互动中所得到的全部经济收益的总和。 推荐阅读23 位开发者告诉你这次 WWDC 最让他们兴奋的新事物对23位iOS开发者的采访，一起来看下他们眼中这届WWDC什么最让人兴奋。 免费领取小专栏 – WWDC2019 内参6月份的WWDC给我们开发者带来了很多东西，Dark Mode、Swift UI、Combine、iPad OS等等。也是我感觉近几年WWDC干货最多的一界了。干货太多不知道怎么学习怎么办？这里没故事的卓同学分享的WWDC2019 内参免费领取名额。可以看各位大佬对WWDC的最新解读分析，目前二十多天里已经更新了30篇文章！。 SwiftUI 的一些初步探索 (一)这是一篇解读SwiftUI的文章，目前还有第二篇。而喵神也在计划写一本关于SwiftUI 和Combine 的书籍 我已经计划写一本关于 SwiftUI 和 Combine 编程的书籍，希望能通过一些实践案例帮助您快速上手 SwiftUI 及 Combine 响应式编程框架，掌握下一代客户端 UI 开发技术。现在这本书已经开始预售，预计能在 10 月左右完成。如果您对此有兴趣，可以查看 ObjC 中国的产品页面了解详情及购买。十分感谢！ 我发现喵神总能一下找到作为新概念最应该注意的问题，比如SwiftUI和Swift5.1的关系，为什么需要新系统才能预览以及ViewBuilder里接受那些条件语句等。想了解SwiftUI 这篇文章真是必读 GithubAbout-SwiftUIWWDC当天开始建立的一个专门收集SwiftUI资料的仓库，应该是史上最全了。果然大家还是最爱SwiftUI！ MovieSwiftUI使用 SwiftUI &amp; Combine和MovieDB API实现的一款应用。Talk is cheap, show me the code.结合实践是最快速的了解一个概念的方式。这也是最近一段时间上升最快的SwiftUI&amp;Combine相关仓库了。 CombineSwiftPlayground一个帮助理解Combine概念的 Swift Playground。对于首次接触响应式编程的人来说具体事例是帮助理解概念很好的方式。 该Playgrounds要求Xcode11 beta2及以上版本才能查看。 rxswift-to-combine-cheatsheet列举了Combine和RxSwift之间的差别和一些概念上的对比，对于有一点RxSwift概念的人来说可以快速的理解Combine，也是对于想从RxSwift迁移至Combine的一份参考。 文摘 普通选民也开始意识到，民主机制已经不再能够为他们带来权力。世界正在变化，但他们摸不清变化的方式和原因。权力正在转移，但选民不知道权力去了哪儿。在英国选民的想象中，权力被欧盟夺走了，所以他们投票脱欧。而在美国选民的想象中，是既得利益者垄断了权力，所以他们支持反体制的候选人，比如伯尼·桑德斯和唐纳德·特朗普。但可悲的事实是，没有人知道所有的权力去了哪儿。就算英国离开欧盟、特朗普接掌白宫，权力也绝不会回到普通选民身上。–未来简史 月度小结关于WWDCWWDC发布的信息里面最让我感兴趣的就是SwiftUI和Combine，目前从Github的活跃情况来看也是这两个技术相关仓亏最多。SwiftUI解决了写UI布局的痛点，而Combine的出现表明了苹果对响应式编程的认可，对于我这种使用了一年RxSwift的人来说简直是一种福音。还有一点是这两个大招都是对Swift的支持，这是一个很明显的信号：Swift已经很成熟了，很强大了，以后还会有更多更好的优化。 过去几年，你可以忽视 Swift，但是，未来几年，如果不拥抱 Swift，将无法紧跟着 Apple 生态圈。 关于生活从上个月开始有规律的进行跑步，上个月跑步里程是60km，这个月是70km，距年初定的目标已经完成了56%。跑步带来的一个好处是最近一段时间的睡眠质量有显著提高，睡得更香了。如果你有睡眠质量问题，可以考虑跑步这个方式尝试解决哦。 封面图来自于在公司园区跑道上的拍摄。","link":"/2019/06/29/monthly_12/"},{"title":"iOS开发月报#4|201810","text":"记录本月开发遇到的知识点，小tips，和bug总结。 大事件新版iPad Pro、MacBook Air、Mac mini发布，全线涨价，但是真香。。。 Tips适配swift4.21、利用xcode快速迁移升级到Xcode10之后，我们打开项目会出现如下提示， 点击会有一个版本升级窗口，如果你的的项目包含一些第三方库的话，第三方库的选型也会出现在上面： 默认勾选第三方库，但是我们适配的时候不应该让Xcode去自动检索第三方库代码。只对我们的app进行代码迁移就够了。适配完后可以在这里查看我们当前的swift版本： 对于第三方库，如果都适配了swift4.2，那么更新到对应版本就行了。如果有没适配的，可以通过制定版本的方式解决冲突，在Podfile文件末尾添加如下代码： 1234567post_install do |installer|installer.pods_project.targets.each do |target|target.build_configurations.each do |config|config.build_settings['SWIFT_VERSION'] = '4.0'endendend 属性访问权限swift中提供的访问权限关键词由低到高有以下五种：private &lt; fileprivate &lt; internal &lt; public &lt; open其中internal是Swift中的默认控制级，一下介绍了这几种关键字的区别： private：当前作用域或者当前类中访问。 fileprivate：表示代码可以在当前文件中访问。 internal：在当前target中访问 public：可跨target使用，但不能被集成或者重写。 open：可跨target使用，允许被集成或者重写。 对于一个严格的项目来说，精确的最小化访问控制级别对于代码的维护来说是很重要的。能用public的就别用open。 修改文件权限当我们执行某些命令行操作，收到如下提示时： 123Linking /usr/local/Cellar/the_silver_searcher/2.1.0... Error: Could not symlink etc/bash_completion.d/ag.bashcomp.sh/usr/local/etc/bash_completion.d is not writable. 就表明我们对需要修改的文件权限不够，我们可以给文件加上修改的权限： 1sudo chown -R $(whoami) /usr/local/etc/bash_completion.d 其中-R表示对目前目录下的所有文件与子目录进行相同的拥有者变更(即以递回的方式逐个变更) 默认关键字1public static let `default` = ImageCache(name: &quot;default&quot;) default是默认关键字，如果使用要加单斜号。 tabbar手动跳转1func tabBarController(UITabBarController, didSelect: UIViewController) In iOS v3.0 and later, the tab bar controller calls this method regardless of whether the selected view controller changed. In addition, it is called only in response to user taps in the tab bar and is not called when your code changes the tab bar contents programmatically.In versions of iOS prior to version 3.0, this method is called only when the selected view controller actually changes. In other words, it is not called when the same view controller is selected. In addition, the method was called for both programmatic and user-initiated changes to the selected view controller. tabbar的didSelect代理方法，只有在手动点击的时候才会触发。通过代码跳转是不会触发的。 自定义tabbar动画123456// 当点击tabBar的时候,自动执行该代理方法(不需要手动设置代理) override func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) { for view in tabBar.subviews {//控制view实现各种动画效果}} NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END从xcode6.3开始，为了能让OC也能表示swift的?(optional)和!功能，增加了对对象的可选指定。指定属性是否可选，可以： 123@property (nonatomic, copy, nonnull) NSString * tickets;//或者@property (nonatomic, copy) NSString * __nonnull tickets; 如果属性多了，每一个都这么写会很麻烦，苹果增加了一对新的宏命令，就是NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。放在里面的对象就相当于都增加了nonnull命令，nonull为默认值。 一个自定义collectionView布局的bugbug描述： 123NSInternalInconsistencyExceptionUICollectionView received layout attributes for a cell with an index path that does not exist: &lt;NSIndexPath: 0x280d2b200&gt; {length = 2, path = 1 - 5} 原因：layoutAttributesForElementsInRect返回的UICollectionViewLayoutAttributes数组有indexPath没有被 [NSIndexPath indexPathForRow:numberOfSection]覆盖。当数据量增加时不会出问题，当数量减少时出现。有人反映这是iOS10的bug，但实际上，我拿iOS10模拟器跑并没有问题，反而是在崩溃后台看到是iOS12的用户上报的。那究竟什么原因不详，附stackoverflow(iOS 10 bug: UICollectionView received layout attributes for a cell with an index path that does not exist - Stack Overflow]地址。解决方案：当我们自定义layout时，需要清除UICollectionViewLayoutAttributes的缓存 12345678//方案一： 在自定义layout的类里override func prepare() {super.prepare()attributesArr.removeAll()}//方案二：在collectionview刷新出collectionView.reloaData()collectionView.collectionViewLayout.invalidateLayout() 配置git SSH1、设置git的user name和email 12$ git config --global user.name &quot;username&quot;$ git config --global user.email &quot;username@gmail.com&quot; 2、生成秘钥 1$ ssh-keygen -t rsa -C &quot;username@gmail.com&quot; 如果不需要设置密码，连按三个回车。最后得到了两个文件：id_rsa和id_rsa.pub。3、添加秘钥到ssh-agent中 1$ ssh-add ~/.ssh/id_rsa 4、复制公钥内容到剪贴板 1$ pbcopy &lt; ~/.ssh/id_rsa.pub 5、登录git仓库（Github或者Bitbucket）将公钥内容粘贴到指定配置位置。Github地址为：https://github.com/settings/keys Apple Watch开发注意事项1、watch没有UIKit，对于UI的操作只能通过storyboard进行2、watch只支持帧动画，我们只能通过png序列来实现动画效果。WKInterfaceGroup 和 WKInterfaceImage均可以实现帧动画。3、开发的watch应用内存被限定为80M，太多帧的动画会不支持4、提交应用watch也需要配置市场截图。5、watch分为两个target。当新建一个Target为WatchDemo，xcode会自动生成一个WatchDemo Extension。前者负责UI，后者负责逻辑。引用cocoapods可以这么写： 12345target 'WatchDemo Extension' doplatform :watchos, '3.0'use_frameworks!pod 'Alamofire'end 6、Always Embed Swift Standard Libraries在Build Settings里面，这两个target，需要将WatchDemo Extension中设置为Yes，另一个设置为No GithubSizes可以在一个界面，显示各个屏幕尺寸。这样我们就不用每个模拟器跑一遍看效果了。方便调试。 iOS-DeviceSupport当手机升级，而xcode未升级时，我们会遇到Device Support的弹框，此时要么升级xcode，要么需要导入对应的Device Support文件。这个库就是提供这种文件的。 InjectionIII用于解决烦人的UI调试问题。当修改了一些UI属性之后，在xcode中我们只能运行程序才能看到效果，如果是处理大量的UI问题，这个过程是很烦人的。好在InjectionIII帮我们解决了这个问题，一起了解一下吧！","link":"/2018/10/31/monthly_4/"},{"title":"iOS开发月报#6|201812","text":"大事件这个月的大事件是高通与苹果之间的专利大战。高通分别在中国和德国对苹果公司提起专利诉讼，结果均胜。苹果将在中国禁售iPhoneX及之前的机型。在德国则是全面禁售。 加上新品手机的创新力度不够，导致苹果股票持续走低，四个月前，苹果还是首个突破万亿美元市值的上市公司，到现在股价已经下跌了 36%，市值只有 7160 亿美元，几个月内市值损失接近 3000 亿美元。 Tips更换启动图不生效现象：更换启动图，不生效，即使删除旧图，运行程序启动图仍然是之前的版本。尝试了删除app重装，clean、重启Xcode，删除DriverData，还试过挪图片位置，改名字，均无效。最后尝试了重启手机-&gt;再安装才正常。 问题分析：这个是系统问题，为了加快程序启动的速度系统会把启动图做个缓存，之后每次启动是加载缓存启动图，所以才会出现修改不生效问题。但我们也并不知道系统会什么时候更新启动图，这个就有点尴尬😓stackoverflow上有关于这个问题的讨论：iOS Keeping old launch screen and app icon after update 有人说这个不影响线上版本，从上线之后的测试来看，大部分用户没有受到影响，但还是出现了部分手机升级却未更换启动图的问题。因为是系统层面控制，没有太好的解决方案，如果有人遇到这个情况，需要注意一下。 赋值权限在Mac 系统的终端上修改文件权限使用的是 Linux 中的 chmod 命令：r：可读，表示可以读取内容w:可写，表示可以编辑内容，但是不可以删除文件x: 可执行，表示可以执行文件。 r:4w:2x:1rwx=4+2+1=7 1$ chmod 777 file 这行命令的意思就是：文件所有者权限是7，同用户组的权限是7，其他非本地用户组的权限是7。同理可以出现这样的命令 chmod740.barshrc 再讲两个：chmod u=rwx, go=rx .barshrc 这个命令中u表示拥有者，g表示group中的用户，o表示others，和上面的想对应。注意go=rx，这里go是拼接起来的，表示g和o的用户有读和执行的权限。 1$ chmod a+w .barshrc 表示所有的用户（a表示all）增加写的权限。 App图片瘦身随着项目版本的不断迭代，会很容易积累越来越多的图片，对这些图片我们有两个主要方面可以优化： 1、删除不用的图片我们需要借助一个工具LSUnusedResources它可以检索项目中未使用的图片资源，我们可以指定检索图片的路径，后缀进行过滤。注意：无法区分png序列的引用。最好手动删除 2、图片压缩可以通过ImageOptim，对图片进行无损压缩。使用时只需将要压缩的文件拖到程序中即可。如果图片较多时，可以借助其命令行工具： 1/Applications/ImageOptim.app/Contents/MacOS/ImageOptim $file_name 对应的shell脚本: 12345678# 处理文件名出现空格问题MY_IFS=$IFSIFS=$'\\n'for file_name in $(find &quot;$1&quot; -name &quot;*.png&quot; -type f); doecho $file_name/Applications/ImageOptim.app/Contents/MacOS/ImageOptim $file_namedoneIFS=$MY_IFS 该工具还有一个Sketch插件：Plugin for Sketch ，可以在输出icon的时候直接进行压缩优化。 后台音频耗电问题功能：一段助眠音频可以后台播放，播放完成后如果返回app，会跳到对应的完成界面。问题：有用户反馈，听音频睡着了，早上醒来，电量掉了很多（40%）。调研：使用Xcode中 Debug Navigator栏的Energy Debug Gauge（需真机）测试。播放完成4分钟左右的后台耗电状态如下：分析可知虽然此时app停止了所有行为，但是生命周期仍处于Background状态，耗电量也还是存在的。暂时认为问题是客户端一直处于Background模式，并未被Suspend，导致一直被系统维护着，所以一直有耗电情况。 再一次查看苹果关于后台模式的文档： When the UIBackgroundModes key contains the audio value, the system’s media frameworks automatically prevent the corresponding app from being suspended when it moves to the background. As long as it is playing audio or video content or recording audio content, the app continues to run in the background. However, if recording or playback stops, the system suspends the app. 可知，只要播放器未被销毁，就会一直占用后台模式！解决方案：在播放完成时销毁播放器。 检验：再次观察播放音频完成一段时间之后的后台耗电情况：此时app被挂起，耗电量基本为0，唤醒app，仍能正常工作。问题解决。 推荐阅读尝试分模块整理推荐阅读的内容 iOS开发过程中的设计模式 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 以上摘自菜鸟教程 Swift中的策略模式从一个小例子入手，讲解策略模式在swift中的使用。 Swift 中的设计模式 #1 工厂方法与单例方法Swift 中的设计模式 #2 观察者模式与备忘录模式Swift 中的设计模式 #3 外观模式与适配器模式SwiftGG翻译组翻译的设计模式系列文章。 设计模式资料整理应该是目前总结最全的适合iOS开发的设计模式资料汇总。 iOS逆向 iOS应用逆向工程，是指从目标应用的界面及功能表现入手，使用不同的工具和理论知识去分析其实现原理，得出应用的代码结构、整体设计、功能实现、执行流程等，然后利用iOS的系统知识和语言特性，借鉴或修改原有实现流程的技术。 推荐两篇掘金上关于iOS逆向的文章：TikTok(抖音国际版)逆向，全球的小姐姐们，我来啦！逆向 Mac 应用 Bartender这两篇都是通过具体实例入手，讲解逆向常用的工具和一些逆向的思路，非常适合新手。最好跟着介绍实际操作一番，第一次成功逆向一个项目之后，那种爽歪歪的感觉，你懂的！ 另外推荐一位逆向领域的牛人刘培庆（博客，github），了解逆向的同学大多应该都不陌生，iOS方面的逆向优先参照 MonkeyDev。刘总今年出了新书《iOS应用逆向与安全》，非常适合对逆向有兴趣的同学。 利用脚本提高工作效率 脚本语言（英语：Scripting language）是为了缩短传统的“编写、编译、链接、运行”（edit-compile-link-run）过程而创建的计算机编程语言。早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作 AppleScript入门：探索macOS自动化 文章选自少数派，讲述了： 什么是 AppleScript？ 我使用 AppleScript 的情境 AppleScript 基础语法 AppleScript suite 之外的解法：模拟键鼠 非常清晰详细的AppleScript入门文章。如何提高工作效率 - 自动化篇文章选自掘金，串联Shell Script, Apple Script, Automator, Alfred &amp; WorkFlows，告诉你如果灵活应用，达到利用脚本提高工作效率的目的。 我写了一个利用AppleScript和Alfred的WorkFlows在命令行打开指定路径的工具。 123456789101112131415on run argvtell application \"Finder\"-- get selection pathset pathFile to selection as textset pathFile to get POSIX path of pathFile-- fix space problem in the directoryset pathFile to quoted form of pathFiletell application \"Terminal\"activatetell window 1do script \"cd \" &amp; pathFileend tellend tellend tellend run 使用方法是：点击选中文件夹，按下热键CMD + T。 音视频创业那点事：听莲叔和羊叔回忆峥嵘岁月莲叔和羊叔是 SwiftGG 翻译组的真·大佬。成绩好，学历高，思维缜密，能力很强。听过《升职加薪》那期节目的朋友应该都有印象。作为标准的技术人才，在创业大潮中自然也想试试身手，打拼一番。 和 Cee 聊聊如何拿 Google Offer翻译组里真是人才辈出啊，前几天 Cee 在群里说了个好消息，他拿到了美国 Google 的 Offer。群友们纷纷表示祝贺并进行了隆重的认哥仪式，将 SwiftGG 诞生以来第一个 GG（哥哥） 称号颁发给我们公认的大哥 Cee。 以上两个音频来自于(ggtalk)[https://talk.swift.gg/]，也是我最近上下班路上用来消遣的音频节目，墙裂推荐！ 计算机科学速成课由Carrie Anne Philbin主讲，Carrie Anne Philbin是一名计算机科学教师和作家。她是树莓派基金会的教育主管，也是学校(CAS)多样性和包容组的主席。她为青少年写了电脑书《树莓派历险记》。特意介绍是因为我感觉这个课程因为这个主讲人的个人魅力而趣味十足😄。不管你是不是计算机专业的学生，看过之后应该都能有所收获。 Github12306ForMac以前要么开Windows虚拟机，要么使用官方Web，现在可以使用12306ForMac订票助手啦。希望对大家有所帮助！ LongestCocoaSoWhatIsTheLongestMethodOrConstantNamesInCocoaFramework? （那么，Cocoa框架中最长的方法名或常量名是什么？）答案是： outputImageProviderFromBufferWithPixelFormat:pixelsWide:pixelsHigh:baseAddress:bytesPerRow:releaseCallback:releaseContext:colorSpace:shouldColorMatch: kCMSampleBufferConduitNotificationParameter_UpcomingOutputPTSRangeMayOverlapQueuedOutputPTSRange 这个项目有一定的调侃意味，so what? 我选择swift🤣","link":"/2019/01/02/monthly_6/"},{"title":"iOS开发月报#9|201903","text":"这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。欢迎推荐内容，可以前往zhangferry/iOSMonthlyReport提交issue。 TipsSpine + SpriteKit项目中需要引入一些实物动画，每个动画之间有不同形态的切换，考虑过gif, mp4, AE + lottie, Spine + SpriteKit。 最后确定使用Spine做动画效果，用SpriteKit处理动画。Spin并没有官方支持SpirteKit的库，但有一个做的比较好的第三方库maxgribov/Spine，支持Swift4.1。 该库支持Bones, Slots, Skins等常用的动画要素，通过Spine导出的json文件和动画素材做出各种动画效果，是仅有的近期还在维护的支持SpriteKit的Spine运行时库。但它也存在一个问题，还不支持Mesh Animation(网格动画)。如果所需的动画效果不需要网格的话，非常推荐使用这个库。 而我们所需的动画效果又必须用到网格动画，思考再三考虑决定放弃使用这个库，使用SKTextureAtlas(纹理集) + 逐帧动画来实现特殊的动画效果。虽然输出的还是png序列，但是SpriteKit对纹理集有足够的优化，Xcode会在打包时把.atlas文件夹中的所有图片做成一张合图，然后生成一个plist文件描述每个小图片的位置信息，所以包的大小和渲染成本都会大大降低。 快速创建转场样式说到自定义转场我们可能会直接想到UIViewControllerAnimatedTransitioning，结合这个类我们可以实现多种多样的订阅样式。但是使用这种方式做转场，我们需要引入很多代码。有一种简单的实现转场的方式是通过CATransition An object that provides an animated transition between a layer’s states. 通过文档的介绍我们知道，这个类就是用来做转场的，只不过支持的样式有限，但如果正好满足你需要的话，推荐使用这种方式来实现转场。 我们来实现一个present的渐变效果： 12345678910111213//创建transition对象let transition = CATransition()transition.duration = 0.5//动画样式//type: .fade, .moveIn, .push, .revealtransition.type = .fade//动画出现方位//subtype: .fromRight, .fromLeft, .fromTop, .fromBottem//transition.subtype = .fromRighttransition.timingFunction = CAMediaTimingFunction(name: .easeIn)self.view.window?.layer.add(transition, forKey: \"present\")self.present(targetVc, animated: false, completion: completion) 如果是做push的渐变，我们只需要改变最后的控制动画的代码： 1234567//父容器为UINavigationControllerself.view.layer.add(transition, forKey: \"push\")self.present(targetVc, animated: false, completion: completion)//父容器为UITabbarControllerself.tabBarController?.view.layer.add(transition, forKey: \"push\")self.present(targetVc, animated: false, completion: completion) 什么是UserAgentUser-Agent 首部包含了一个特征字符串，用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号，然后前端的展示就可以根据这些信息进行针对性的优化。 我们打开Chrome浏览器，生成一个请求，然后用Charles抓包，可以看到对应的User-Agent 1user-agent Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.28 Safari/537.36 通过UA我们可以得到以下信息： 信息项 内容 浏览器名称 Chrome 浏览器版本号 70.4.3729.28 渲染引擎 WebKit 537.36 操作系统 Mac OS 10.13.6 Apple Configurator 2 出现 Unauthorized Error注销账号，再次登录 Command PhaseScriptExecution failed with a nonzero exit code运行一个项目时遇到了这个bug提示，一直编译不过去，这其实是一个Xcode10引起的bug。解决方案：在Xcode菜单栏选择File -&gt; Workspace Setting -&gt; Build System 选择Legacy Build System 重新运行即可。参考：踩坑Xcode 10之New Build System 斐波那契函数斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…… 这个是我们公司技术面试的必问题目，也是筛掉人数最多的一个问题。有一部分同学会使用数组尝试解决这个问题，但这会把问题复杂度升级，还有些可能根本没有思路。但其实这个问题不复杂的，用到递归可以很快的解决。斐波那契函数的数学表达是： 123F(1)=1F(2)=1F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*） 用Swift实现就是： 1234567func fibonacci(n: Int) -&gt; Int { if n == 1 || n == 2 { return 1 } else { return fibonacci(n: n - 1) + fibonacci(n: n - 2) }} 推荐阅读SpriteKit Tutorial for Beginnersraywenderlich上介绍SpriteKit入门的一篇教程，通过这篇文章你可以实现一个忍者击杀怪物的小游戏，理解SpriteKit框架里常用的几种游戏元素。不得不说这个教程做的是真的棒👍 开发小知识该文章主要整理一些小知识点，主要涉及 iOS 以及计算基础相关知识点，某些知识点暂时只有标题，后续会持续更新。笔者最近一段时间面试过程中发现一些普遍现象，对于一些很不起眼的问题，很多开发者都只停留在知道、听说过的层面，但是一旦问 是什么 和 为什么 ，很多应试者回答的并不理想。大家可以对着这篇文章查找自己的知识盲区。 Swift 5 终于来了，快来看看有什么更新！！Xcode10.2 已经发布，是时候开始使用 Swift5 了，可以提前看下老司机周报总结的Swift5 更新内容，对适配工作做好准备。 苹果开了一场没有任何硬件的发布会3 月 26 日凌晨 1 点，苹果在 Apple Park 新总部的乔布斯剧院召开了春季特别活动。 在活动现场，苹果发布了： 新闻服务 Apple News+ 可以返现的 Apple Card 游戏服务 Apple Arcade 全新的 Apple TV App 服务 Apple TV+ 原创视频服务 全部是软件和服务，没有新硬件的出现——这或许意味着，苹果正在寻找下一个十年的生长空间。 音视频辞职环游中国的程序员小 K大概每个人都有过这种冲动，辞掉工作出去旅行，想去哪就去哪，再也不用赶需求修 bug 通宵加班。不过对大多数人来说，也就止步于“想想”，并不会付诸行动。但是我身边有一位朋友，真的做到了这件事：辞职一年环游中国！ 这是最近几期ggtalk对我触动最大的一期，同样是做iOS开发的，为什么人家那么优秀🙃 Github996.ICU工作996，生病ICU。这段时间的“明星项目”，旨在反抗国内互联网公司形成的每周工作6天，每天工作早9点到晚9点的不良加班风气。截止到3月30号，仅四天时间star已经超11万。 XVim2XVim2是一个用于Xcode的Vim插件。如果你是一个Vim党，你可以直接在Xcode代码编辑界面使用Vim的各种特性。我是最近开始接触，也在慢慢适应Vim的远离鼠标工作模式。另附送一个安装流程： 1、关闭Xcode2、钥匙串-&gt;证书助理-&gt;证书创建 名称：XcodeSigner 身份类型：自签名根证书 证书类型：代码签名3、重新签署Xcode 12#需要等待一段时间sudo codesign -f -s XcodeSigner /Applications/Xcode.app 4、按照官方步骤安装XVim2 文摘1、培养出在没人监督自己的时候也能高效工作的自我责任感非常重要。你也可以拔这称为是具有一种性格或者具有一种素质，它们都是同一个概念。如果缺乏对自己的责任感，你将永远依赖外部动机来驱使你努力工作。你容易折服于一根胡萝卜的诱惑，也容易屈从于一根大棒的威胁。–《软技能：代码之外的生存指南》 2、最终，它成为我自己的知识体系中严重的短板。没有花时间去彻底掌握Lambda表达式的工作原理，结果浪费了大把的时间。最后当我下决心花时间去了解Lambda表达式的时候，我只花了几个小时阅读并实践，就领会了这一概念。–《软技能：代码之外的生存指南》 3、回到从前，在我们刚开始一起生活的时候，我们就决定将我们收入的10%用于风险什一税–实际上我们把这部分收入捐给一家慈善机构，以帮助印度的孤儿。在我们第一次奉献什一税的第二周，我的妻子就得到了加薪，加薪的数额正好是我们当时奉献什一税的数额。我个人认为，我们的成功很大一部分就是因为这种对奉献的承诺，一直恪守到今天。即使你不信仰任何宗教，我认为这一点也有某种符合逻辑的解释。我认为，你把钱看的越重，你就越难以在理财方面做出明智的、成功的投资选择。自愿把自己收入的固定数额奉献或者捐赠给慈善机构，可以改变你对金钱的看法。这一思想上的转变让你从金钱的所有者变成管理者。–《软技能：代码之外的生存指南》","link":"/2019/03/31/monthly_9/"},{"title":"iOS开发月报#7|201901","text":"这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。欢迎推荐内容，可以前往zhangferry/iOSMonthlyReport提交issue。 另外，马上就要过年了，提前祝大家春节快乐！ 新闻一览Github宣布私有库免费Github宣布提供免费且不限量的私有仓库服务，如果协作者超过3个仍需购买付费服务。喜大普奔啊，得知消息之后，我赶紧就建立一个私有仓库，放一些不想让你们看到的东西🙃 Swift 5 Release Notes for Xcode 10.2 betaSwift5 版本终于发布了，最低可以使用Xcode10.2beta 查看。Swift5 带来了ABI稳定，届时系统将自带Swift动态库，由Swift编译的项目将不会自动把运行库打到包里。 Swift5 具体还有哪些特性，可以参考知识小集团队的翻译版本 TipsDictionary的merge操作Dictionary的merge可能平常用的不多，我是在一次bug排查的过程中，发现自己对merge操作理解也有些偏差。这里做个简单梳理。看其中一种情况： 123456789var dictionary = [\"a\": 1, \"b\": 2]// Keeping existing value for key \"a\":dictionary.merge([\"a\": 3, \"c\": 4]) { (current, _) in current }// [\"b\": 2, \"a\": 1, \"c\": 4]// Taking the new value for key \"a\":dictionary.merge([\"a\": 5, \"d\": 6]) { (_, new) in new }// [\"b\": 2, \"a\": 5, \"c\": 4, \"d\": 6] 注意尾随闭包中有两个参数，返回第一个参数，表示如果merge操作有重复key值，将保留merge前的value不变。如果闭包返回第二个参数，如果merge有重复key，将更新至最新值。Dictionary向关的merge函数一共有四个，使用类似： 1234567public mutating func merge&lt;S&gt;(_ other: S, uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -&gt; [Key : Value].Value) rethrows where S : Sequence, S.Element == (Key, Value)//上面示例对应方法public mutating func merge(_ other: [[Key : Value].Key : [Key : Value].Value], uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -&gt; [Key : Value].Value) rethrowspublic func merging&lt;S&gt;(_ other: S, uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -&gt; [Key : Value].Value) rethrows -&gt; [[Key : Value].Key : [Key : Value].Value] where S : Sequence, S.Element == (Key, Value)public func merging(_ other: [[Key : Value].Key : [Key : Value].Value], uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -&gt; [Key : Value].Value) rethrows -&gt; [[Key : Value].Key : [Key : Value].Value] 一些Git操作删除子目录git当一个含git的目录包含了其他含git目录时，外部git是不能将内部git纳入版本管理的。有一种解决方案是，移除内部的git仓库。1、删除内部git 12cd 需要移除的git目录rm -rf .git # 或者显示隐藏目录手动删除.git文件夹 此时虽然已经删除了.git但是原目录还存在缓存，无法添加到外部git中。2、删除缓存内容 1git rm -r --cached next git pull强制覆盖本地文件当我们需要将某一分支，跟远程对应分支保持一致时，可以做如下操作： 123git fetchgit reset --hard origin/branch_namegit pull fatal:refusing to merge unrelated histories当我们为一个项目关联了一个远程仓库，执行pull的操作时出现 123 * branch master -&gt; FETCH_HEAD * [new branch] master -&gt; origin/masterfatal: refusing to merge unrelated histories 这是因为git从2.9.0版本开始，预设行为不允许合并没有共同祖先的分支。如果你非要合并，需要加上--allow-unrelated-histories参数才行： 1git pull origin master --allow-unrelated-histories 几个提高效率的快捷键最近在熟练使用了几个快捷键后，明显感觉开发效率提高了不少，这里总结了几个常用但不是非常常用的快捷键（Command + C 和 Command V等）。另外 Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Power 电源键 XcodeCommand + Shift + J 文件目录指向当前文件Command + Shift + O 文件、对象搜索Command + Shift + F 全局搜索Command + shift + , 编辑 schemeCommand + Control + Left/Right 浏览历史切换Command + Option + Left/Right 折叠、展开当前代码段Command + Option + C 显示Commit界面系统操作Command + Option + Power 睡眠状态Power 1.5s睡眠状态Command + Control + Power 强制Mac重启 适用其他程序Command + , 打开偏好设置Command + W 关闭最前面的窗口Command + Option + W 关闭应用所有窗口Command + Q 推出应用Command + M 最小化Command + Shift + [/] 左右切换应用tab 推荐阅读未来世界的幸存者今年市场经济不景气，很多互联网公司经历“裁员潮”，其实不光是换联网行业，其他行业也面临同样的问题。那怎么提高自己的核心竞争力，是每一个从事互联网行业的人都应该考虑的。我们不应该只满足于日常开发，要找准自己的定位，提早做职业规划。另外不断尝试拓展自己的知识面，增加自己的影响力，这样才能让自己在不断变化的市场中立于不败之地。 除了阮老师的这本书，还推荐卓同学的iOS 2019 隆中对 什么是真正的程序员作者仿照《小王子》中的情节，通过小printf遇见的不同类型的程序员，最后悟出什么才是真正的程序员！有两个概念比较有意思： 达克效应：能力强的人总是低估自己，能力弱的人总是高估自己。 能够为人们解决真正需要解决的问题的程序员，才是真正的程序员 Language Server Protocol来自SwiftGG翻译组的一篇文章。苹果公司 在 Swift.org 论坛上宣布，正在着手为 Swift 和 C 语言支持 Language Server Protocol（语言服务器协议，LSP）。那这意味着什么呢？这可能是苹果自 2014 年将 Swift 作为开源软件发布以来，为 Swift 做出的最重要的决定。它意味着我们可以不必使用Xcode去开发Swift项目，而是可以选择像是Visual Studio, Atom这些IDE。Swift将变成一种更加通用的变成语言。 Hashable / HasherHash是程序开发过程中很重要的一个概念，它可以让我们查找集合特定元素的时间复杂度由O(n)降低到O(1)。这篇文章介绍了Swift中关于哈希的实现，哈希冲突的改变，以及Swift4.1之后关于自动化实现Equatable的相关介绍。 Table View 太複雜？利用 MVVM 和 Protocol 就可以為它重構瘦身！TableView是我们常用的系统部件，随着业务逻辑的不断迭代它内部的逻辑可能会越来越复杂，代码量也越来越多，如果不能很好的组织逻辑架构，这里会变得非常臃肿。作者利用MVVM pattern，加上一点Protocol技巧，来简化dataSource的工作，把UI和逻辑解耦合，并且最大化这个tableView模组的扩展性。 音视频临近年关，可能很多人会考虑年后换工作的情况，最近几期的ggtalk也在讨论跳槽这个大家比较关注的话题，希望大家收听之后能够有所收获：狭义跳槽论：面试官，大厂新人和准备起跳的某 C广义跳槽论：简洁明了的方法论附带之前的几期关于升职加薪的节目：聊聊程序员的升职加薪（上）聊聊程序员的升职加薪（下） 程序员的春节趣事今天上班路上听了这期节目，全程非常的欢快。我是今天晚上回家的火车，那些相似的春节趣事我也马上要经历一次了，是需要提前准备下怎么应对了🙃。 以下是官方内容介绍：快过年了，估计大家也没心情工作学习，准备进入放假状态。严肃的话题放到年后，这期我们请到了袁滚滚、张思琦和老朋友莲叔，围绕着春节轻松愉快的聊一期。 Github本篇GitHub模块，介绍几个Git和GitHub相关的项目。 Git中文教程来自geeeeeeeeek的高质量Git中文教程，在GitHub已经获得了1w+的start。对git操作还有疑问的同学可以借助这份教程，完整的梳理一下git相关的知识，或者扫一下git盲区。 Git的奇技淫巧我们在使用git的时候，有时候会被一些具体的问题难住，这篇文章从具体操作入手，介绍一些我们知道但不一定都用过的git指令。等等，我也想写一份我自己的Git奇淫技巧了，因为git这个东西是真的庞大。 HelloGitHub这是一个面向编程新手、热爱编程、对开源社区感兴趣人群的项目，内容以月刊的形式更新发布。内容包括：流行项目、入门级项目、让生活变得更美好的工具、书籍、学习心得笔记、企业级项目等，这些开源项目大多都是非常容易上手、很 Cool，能够让你用很短时间感受到编程的魅力和便捷。从而让大家感受到编程的乐趣，动手开始编程。 GitHub漫游指南介绍你可能在Github上遇到的所有问题，从如何起一个好名字到如何推广项目，GitHub用户分析，每一个环节都非常详细。无论你处于编程的哪个阶段，我认为你都能从这份指南中获取到灵感和帮助。 README该文件用来测试和展示书写README的各种markdown语法。GitHub的markdown语法在标准的markdown语法基础上做了扩充，称之为GitHub Flavored Markdown。简称GFM，GFM在GitHub上有广泛应用，除了README文件外，issues和wiki均支持markdown语法。","link":"/2019/01/31/monthly_7/"},{"title":"iOS开发月报#8|201902","text":"这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。欢迎推荐内容，可以前往zhangferry/iOSMonthlyReport提交issue。 新闻一览2019年开发人员技能报告 这是HackerRank平台通过对7万多名开发人员做的一项调查，问题从他们认为最有前途的技术到他们在工作中和面试过程中想要的是什么，甚至还有coding过程中听什么音乐最有帮助！一起看下吧。 Tipspresentedviewcontroller和presentingViewController假设从A控制器通过present的方式跳转到了B控制器，那么 A.presentedViewController 就是B控制器；B.presentingViewController 就是A控制器。如果没有对应关系会返回nil 获取类名12//传入实例对象objectlet typeName = String(describing: type(of: object)) 隐藏NavigationBar导致手势返回失效当我们从一个A(NavigationController)界面通过push进入B界面，如果要隐藏B的NavigationBar，那么从B到A的返回手势也会被屏蔽掉。如果需要加回来我们可以这么做： 1234//1.给需要添加返回手势的ViewController增加UIGestureRecognizerDelegate//2.由当前ViewController接管pop手势self.navigationController?.interactivePopGestureRecognizer?.delegate = self 关于 Decimal官方对Decimal介绍就一句话 A structure representing a base-10 number. 表示以10为基数的数的结构体，就是十进制的表示方法。它可以通过 mantissa * 10 ^ exponent的形式表示任意数值。mantissa(尾数)是最长38位的整数，exponent(指数)是 -128到127的整数。 你也可以把Decimal理解成跟Int, Float, Double一样的数据类型，那有了整形，浮点型数值还会出现Decimal这个类型？可以看一个例子： 123456let stride: Float = 0.01var sum: Float = 0for _ in 1...100 { sum += stride}print(sum)//0.99999934 sum的值不是1，这是因为精度的问题，那如果把Float换成Decimal就会完全等于1。 SKProduct的price属性就是Decimal类型 违反5.5条款被打回的经历在一次有关内购项审核被打回的经历中，遇到了一个新问题，错误描述中提示违反了条款5.5 Developer Code of Conduct。简单看下这一条 Please treat everyone with respect, whether in your responses to App Store reviews, customer support requests, or when communicating with Apple, including your responses in Resolution Center. Do not engage in harassment of any kind, discriminatory practices, intimidation, bullying, and don’t encourage others to engage in any of the above.Customer trust is the cornerstone of the App Store’s success. Apps should never prey on users or attempt to rip-off customers, trick them into making unwanted purchases, force them to share unnecessary data, raise prices in a tricky manner, charge for features or content that are not delivered, or engage in any other manipulative practices within or outside of the app. 总结一下就是要尊重用户。 在联系过苹果审核客服之后，被告知是因为在引导过程中弹了两次订阅弹窗（一次订阅，一次freetrial）被拒的。但其实这个流程已经跑了大半年，一直没问题，这次却突然被揪出来了，有点莫名其妙。 可能审核人员认为，这种行为有诱导或者强迫用户付费的嫌疑。由此也可以看出审核人员对项目流程的管理越来越严格了。去掉一个步骤之后再次提交就过审了。 推荐阅读Swift ABI 稳定对我们到底意味着什么Swift 社区最近最重大的新闻应该就是 ABI 稳定了。这个话题虽然已经讨论了有一阵子了，但随着 Xcode 10.2 beta 的迭代和 Swift 5 的 release 被提上日程，最终 Swift ABI 稳定能做到什么程度，我们开发者能做些什么，需要做些什么，就变成了一个重要的话题。 一起来看下使用 Swift 5 会对我们的项目有什么影响以及怎么处理。 VoidSwiftGG翻译组翻译的Mattt一篇介绍Void的文章。Void是什么，它和nil有什么区别，这个我们经常用但不一定真的理解的东西，一起通过这篇文章看下吧。 love2.io程序员的自我修养，作为一个合格的程序员需要具备哪些知识呢？ 数据结构、算法、代码架构、项目管理工具、网络知识等？可能还不够，还需要懂点设计、学着当一个合格的PM、学会团队合作、学会学习、提升效率等等；够了吗？你还需要了解一下创业流程、关注自己的身体健康。。。 太多了，不列举了，因为这里都有。 为什么数字下标要从 0 开始而不是 1？大家都知道数字下标是从0开始的，那为什么是0而不是1呢？说实话在看这篇文章之前我也不能很清楚的说明白，如果你也有这种疑惑就看看这个文章吧。 什么叫有知识选自罗胖60秒：1、话说什么叫做有知识？最近我看万维钢老师有一个有趣的定义。他说，考试得了高分，不叫有知识。茶余饭后能高谈阔论，这也不叫有知识。 你发现没有，这些场合下，知识虽然有用，但是这些知识都不太牵扯到具体的得失，所以只是智力游戏。 2、那什么才叫有知识呢？万维钢老师说，只有当局势不明朗，没有人告诉你该怎么办，而错误的判断又会导致一些不良后果，这个时候，如果你因为有知识而敢于拿一个主意，你才算是真有知识。 3、请注意，这不是在说，实用的知识才是知识，而是在说，只有当知识能够帮助你做实际决策的时候，它才是你的知识。 4、这种决策当然可大可小，大到你选择什么样的职业，选择听医生的哪个建议；小到帮你选择看哪一部电影，或者是为孩子挑选买哪一本书。这都是具体的决策。 音视频苏俄科幻简史：直指星海的冒险时代 最近在机核（gamecores）上听到的一段讲述苏俄科幻的音频，可以当故事听，也可以当一段历史去听，非常有意思。 对于很多人而言，苏俄的科幻文学、电影乃至游戏都是一个比较陌生的概念。事实上从沙俄末期到苏联再到今天的俄罗斯，来自极北之地的斯拉夫人民也曾在科幻这个领域上走了很远很远，取得了惊人的成绩。 GithubDoraemonKit由滴滴团队开源，中文名“哆啦A梦”。 DoraemonKit 是一个功能集合面板，能够让每一个 App 快速接入一些常用的或者你没有实现的一些辅助开发工具、测试效率工具、视觉辅助工具，而且能够完美在 Doraemon 面板中接入你已经实现的与业务紧密耦合的一些非通有的辅助工具，功能强大，接入方便，便于扩展。 git-history这个项目可以让你在浏览器动态地查看Github库上代码的变动历史。 使用方法非常简单：1、在对应的文件url中把github.com替换成github.githistory.xyz2、没有第二步 resume.github.com这个库可以通过你仓库的活跃事件来生成一份在线简历。使用很简单，直接访问以下网址：https://resume.github.io/?yourusername 需要将yourusername替换成你的用户名，别忘了那个? iOS-Developer-Roadmap一名iOS开发人员需要具备哪些知识呢？这个库做了比较详尽的总结，以技能树的形式对iOS开发所需知识点，知识面做了整理，我们可以作为参照，查看自己有哪些缺失。 文本版本 图片版本(基础版本, 完整版本)","link":"/2019/02/28/monthly_8/"},{"title":"nRF芯片设备DFU升级（适配Xcode10.2.1）","text":"这里主要参考这个项目：iOS-nRF-Toolbox，它是Nordic公司开发的测试工程，包含一整套nRF设备的测试解决方案。 项目是用Swift写的，不过之前还是有OC版本的，但是后来由于一些**（不可描述的问题），才变成了现在的纯Swift版本。对于使用Swift开发的人员，直接仿照Demo操作即可。如果你是用Swift开发的，那下面的内容你可以不用看了。接下来我就讲一下针对OC引用DFU升级的操作步骤和我遇到的问题。 代码研究nRF-Toolbox项目包含BGM，HRM，HTM，DFU等多个模块，我们今天只关注其中的DFU升级模块。打开项目，在对应的NORDFUViewController.swift中我们能够看到有三个引用库import UIKit,import CoreBluetooth,import iOSDFULibrary，这里的iOSDFULibrary就是DFU升级的库，也是解决DFU升级最重要的组件。我们只要把这个库集成到我们的项目中，就能够完成nRF设备的DFU升级了。 集成步骤有两种方案集成： 通过cocoapods集成 编译出framework然后把库导入项目 第一种方案是作者推荐的，但是我试了很久，引入DFULibrary会出现头文件找不到等一系列问题，无奈只能放弃，如果有人通过这种方式成功，还望告知。下面讲的是通过第二种方案的集成。 第一步：导出iOSDFULibrary 这一步是最关键也是最容易出问题的，这个库也是由Swift写成的，我们将这个库clone到本地，然后选择iOSDFULibrary进行编译 最后生成两个framework: iOSDFULibrary.framework Zip.framework 这时库内的代码已经变成了我们熟悉的OC语言。理论上这个库应该是没问题的了，但是事实还是有问题的，见issues#39。作者给出的解决方法是： 1、On your mac please install carthage (instructions) 2、Create a file named cartfile anywhere on your computer 3、add the following content to the file: github &quot;NordicSemiconductor/IOS-Pods-DFU-Library&quot; ~&gt; 2.1.2 github &quot;marmelroy/Zip&quot; ~&gt; 0.6 1、Open a new terminal and cd to the directory where the file is 2、Enter the command carthage update –platform iOS 3、Carthage will now take care of building your frameworks, the produced .framework files will be found in a newly created directory called Carthage/Build/iOS,copy over iOSDFULibrary.framework and Zip.framework to your project and you are good to go. carthage是一种和cocoapods相似的的类库管理工具，如果不会使用的话可以参照Demo，将framework文件导入到自己的项目。 第二步、导入frameworkTarget-&gt;General 直接拖入项目默认只会导入到Linked Frameworks and Libraries，我们还需要在Embeded Binaries中引入。 第三步、使用iOSDFULibrary 1234567891011121314//create a DFUFirmware object using a NSURL to a Distribution Packer(ZIP)DFUFirmware *selectedFirmware = [[DFUFirmware alloc] initWithUrlToZipFile:url];// or//Use the DFUServiceInitializer to initialize the DFU process.DFUServiceInitiator *initiator = [[DFUServiceInitiator alloc] initWithCentralManager: centralManager target:selectedPeripheral];[initiator withFirmware:selectedFirmware];// Optional:// initiator.forceDfu = YES/NO; // default NO// initiator.packetReceiptNotificationParameter = N; // default is 12initiator.logger = self; // - to get log infoinitiator.delegate = self; // - to be informed about current state and errors initiator.progressDelegate = self; // - to show progress bar// initiator.peripheralSelector = ... // the default selector is usedDFUServiceController *controller = [initiator start]; 库中有三个代理方法DFUProgressDelegate，DFUServiceDelegate，LoggerDelegate，它们的作用分别为监视DFU升级进度，DFU升级及蓝牙连接状态，打印状态日志。 常见问题1、selectedFirmware返回nil 1DFUFirmware *selectedFirmware = [[DFUFirmware alloc] initWithUrlToZipFile:url]; 需要在General的Embeded Binaries选项卡里导入那Zip.framework和iOSDFULibrary.framework2、崩溃报错 1dyld: Library not loaded: @rpath/libswiftCore.dylibReferenced from: /private/var/containers/Bundle/Application/02516D79-BB30-4278-81B8-3F86BF2AE2A7/XingtelBLE.app/Frameworks/iOSDFULibrary.framework/iOSDFULibraryReason: image not found 需要改两个地方 如果不起作用，将Runpath Search Paths的选项内容删掉再重新添加一遍即可3、打包上架时报ERROR IT MS-90087等问题问题描述： 1234ERROR ITMS-90087: \"Unsupported Architectures. The executable for ***.app/Frameworks/SDK.framework contains unsupported architectures '[x86_64, i386]'.\"ERROR ITMS-90362: \"Invalid Info.plist value. The value for the key 'MinimumOSVersion' in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0\"ERROR ITMS-90209: \"Invalid Segment Alignment. The app binary at '***.app/Frameworks/SDK.framework/SDK' does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.\"ERROR ITMS-90125: \"The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple's linker.\" 解决方法，添加Run Script Phase Shell脚本内容填写如下内容，再次编译即可 12345678910111213141516171819202122232425262728APP_PATH=\"${TARGET_BUILD_DIR}/${WRAPPER_NAME}\"# This script loops through the frameworks embedded in the application and# removes unused architectures.find \"$APP_PATH\" -name '*.framework' -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME=$(defaults read \"$FRAMEWORK/Info.plist\" CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH=\"$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME\"echo \"Executable is $FRAMEWORK_EXECUTABLE_PATH\"EXTRACTED_ARCHS=()for ARCH in $ARCHSdoecho \"Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME\"lipo -extract \"$ARCH\" \"$FRAMEWORK_EXECUTABLE_PATH\" -o \"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\"EXTRACTED_ARCHS+=(\"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\")doneecho \"Merging extracted architectures: ${ARCHS}\"lipo -o \"$FRAMEWORK_EXECUTABLE_PATH-merged\" -create \"${EXTRACTED_ARCHS[@]}\"rm \"${EXTRACTED_ARCHS[@]}\"echo \"Replacing original executable with thinned version\"rm \"$FRAMEWORK_EXECUTABLE_PATH\"mv \"$FRAMEWORK_EXECUTABLE_PATH-merged\" \"$FRAMEWORK_EXECUTABLE_PATH\"done 完整OC项目这个是对应Swift版本用OC写的完整项目，应该是OC停止维护之前的版本。会有一些bug。在将DFUFramework更新之后，我把它搬到了我的github上，有需要的同学可以下载研究：OC-nRFTool-box。 以下为更新内容，时间：2017.12.26收到很多关于无法适配Xcode9.2的反馈，因为最近比较忙没时间处理，不好意思啦，今天抽出时间来把代码更新了一下。 Xcode9.2 出现的问题 1、dyld: Library not loaded: @rpath/libswiftCore.dylibReferenced from: /private/var/containers/Bundle/Application/02516D79-BB30-4278-81B8-3F86BF2AE2A7/XingtelBLE.app/Frameworks/iOSDFULibrary.framework/iOSDFULibraryReason: image not found2、DFUFirmware *selectedFirmware = [[DFUFirmware alloc] initWithUrlToZipFile:url]; 返回为空或者崩溃问题 我的测试结果是更新iOSDFULibrary. framework和Zip.framework可以解决以上问题。 解决方案 Carthage因为这两个库都是通过Swift维护的，所以更新framework最好还是要用适用Swift的方式，包括以后的更新也一样。所以我推荐用Carthage更新这俩库，下面是使用Carthage的简单介绍，详细的可以看这里Carthage的安装和使用。另外OC-nRFTool-box也已经更新，里面的Framework可以直接拿来用。 1、安装brew 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 2、brew更新 1$ brew update 3、安装Carthage 1$ brew install carthage 4、使用Carthage 123456$ cd ~/路径/项目文件夹 /**进入项目文件夹下*/$ touch Cartfile /**创建carthage文件*/$ open Cartfile /**打开carthage文件*/# /**输入以下内容*/$ github \"NordicSemiconductor/IOS-Pods-DFU-Library\" ~&gt; 4.1$ github \"marmelroy/Zip\" ~&gt; 1.1 5、运行Carthage 1$ carthage update --platform iOS /**编译出iOS版本*/ 6、更新framework 1$ cd Carthage/Build/iOS /**framework输出位置，将老的framework替换掉*/ 注意nRF Toolbox项目方法变更 12[initiator withFirmwareFile:selectedFirmware];/** 旧版本方法 */initiator = [initiator withFirmware:selectedFirmware];/** 新版本方法 */ 更新：2019-7-14针对之前常出的这种问题： 123dyld: Library not loaded: @rpath/libswiftCore.dylibReferenced from: /private/var/containers/Bundle/Application/CDB2F4ED-C49C-4303-BE1F-5D9D990380F3/nRF Toolbox.app/Frameworks/Zip.framework/ZipReason: image not found 均是由Swift库版本不一致引起的，iOSDFULibrary目前已经支持到Swift 5，所以我们应该升级一下版本。为了方便使用，我将Carthage集成到了项目里，如果以后需要再升级，更新Cartfile文件里的版本号，执行更新命令： 1$ carthage update --platform iOS 如果你想要将DFU的framework集成到你自己的项目里，可以在Carthage/Build/iOS/中找到iOSDFULibrary.framework, ZIPFoundation.framework 将其拖到项目中即可。 上线注意事项（由@jianxiong1997提供）需要删除ZIPFoundation.framework中的 libswiftRemoteMirror.dylib Frameworks github项目同步更新。","link":"/2016/12/28/nRF-DFU-upgrade/"},{"title":"使用Cocoapods管理私有库组件","text":"CocoaPods是OS X和iOS下的一个第三方开源类库管理工具，通过CocoaPods工具我们可以为项目添加依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。它是目前iOS开发中使用最广泛的开源库管理工具，如果我们内部协作的组件化能够使用这种方式管理的话，那将是很便利的。在通过Cocoapods建立内部私有库之前，我们需要再熟悉下Cocoapods的工作流程，我们创建内部私有库时也会依照这个流程来。 本文目录一、Cocoapods的工作流程二、建立Cocoapods私有库三、使用私有库四、问题总结 Cocoapods工作流程工作流程如图所示： 远程索引库：这里存放了各个框架的描述文件，托管在github上：CocoaPods/Specs 本地索引库：在安装cocoapods时，执行的pod setup就是讲远程索引克隆到本地，本地索引的目录为： 1~/.cocoapods/repos/master 本地索引和远程索引的目录一致，结构如下： 每个库的每个版本都对应一个json格式的描述文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051{&quot;name&quot;: &quot;YYImage&quot;,&quot;summary&quot;: &quot;Image framework for iOS to display/encode/decode animated WebP, APNG, GIF, and more.&quot;,&quot;version&quot;: &quot;1.0&quot;,&quot;license&quot;: {&quot;type&quot;: &quot;MIT&quot;,&quot;file&quot;: &quot;LICENSE&quot;},&quot;authors&quot;: {&quot;ibireme&quot;: &quot;ibireme@gmail.com&quot;},&quot;social_media_url&quot;: &quot;http://blog.ibireme.com&quot;,&quot;homepage&quot;: &quot;https://github.com/ibireme/YYImage&quot;,&quot;platforms&quot;: {&quot;ios&quot;: &quot;6.0&quot;},&quot;source&quot;: {&quot;git&quot;: &quot;https://github.com/ibireme/YYImage.git&quot;,&quot;tag&quot;: &quot;1.0&quot;},&quot;requires_arc&quot;: true,&quot;default_subspecs&quot;: &quot;Core&quot;,&quot;subspecs&quot;: [{&quot;name&quot;: &quot;Core&quot;,&quot;source_files&quot;: &quot;YYImage/*.{h,m}&quot;,&quot;public_header_files&quot;: &quot;YYImage/*.{h}&quot;,&quot;libraries&quot;: &quot;z&quot;,&quot;frameworks&quot;: [&quot;UIKit&quot;,&quot;CoreFoundation&quot;,&quot;QuartzCore&quot;,&quot;AssetsLibrary&quot;,&quot;ImageIO&quot;,&quot;Accelerate&quot;,&quot;MobileCoreServices&quot;]},{&quot;name&quot;: &quot;WebP&quot;,&quot;dependencies&quot;: {&quot;YYImage/Core&quot;: []},&quot;ios&quot;: {&quot;vendored_frameworks&quot;: &quot;Vendor/WebP.framework&quot;}}]} 本地索引文件当执行pod search命令时，如果本地索引不存在，就会创建出来： 12$ pod search afnCreating search index for spec repo 'master'.. 本地索引文件路径为： 1~/Library/Cache/Cocoapods/Pods 远程框架库以YYImage为例，它的远程框架库就是json文件中的source：https://github.com/ibireme/YYImage.git 所以再用文字总结下Cocoapods工作流程大概就是1、本地安装cocoapods，建立本地索引库和远程索引库的映射2、本地项目pod install3、查找本地索引文件，然后找到各个库对应版本的json文件4、通过json文件source字段找到引用库的git地址5、把库文件拉到本地项目 建立Cocoapods私有库（framework）建议采用framework的形式创建私有库，这可以很好的在开发阶段检查出库的不兼容或者文件权限出现的问题，Swift编写的代码通过Cocoapods生成的都是framework。 0、准备工作：如何建立远程索引库首先我们需要建立一个内部的远程索引库，类似Cocoapods/Spec的功能，之后添加的库文件索引文件都会存放到这里：https://zhangferry@bitbucket.org/sealcn/sealrepo.git建立本地和远程索引仓库的关联： 1pod repo add SealRepo https://zhangferry@bitbucket.org/sealcn/sealrepo.git 执行pod repo 可以看到我们有了两个索引仓库，可以去在这个目录~/.cocoapods/repos看到我们刚建立的SealRepo。 如何组织文件结构我们可以看下Alamofire的文件组织结构： 我们看到这几个文件： Source用于存放Framework源文件， Example用于放Demo项目 docs和Documentation放说明文档，这个是可选的， Tests测试文件也是可选。我们制作私有库时会仿照这个格式。一、制作framework 因为是Swift的工程，接口的开放直接通过open、public等关键字指定，所以工程中的ABTest.h头文件可以删除，加入我们自己的库文件。注意：在写公有库文件时，对外界开放的属性，方法需要带上public或者open关键字。 二、添加Example工程通过Xcode菜单栏File-&gt;New-&gt;Target...添加一个Example工程。引入第三方库如果无第三库引用可以跳过这一步。注意：引入Podfile文件，需要framework和Example两个target都添加上。测试项目需要先编译framework，没有问题之后，导入到Demo项目里 1import ABTest 运行Dome，测试开发功能有没有问题。 push项目到远程库如果已经关联过远程私有仓库，这一步可以跳过。在远程配置一个git地址，然后将本地项目关联到远程私有仓库： 1git remote add origin 仓库地址 如过是首次关联远程仓库，在push之前我们一般需要先拉去远程分支 1git pull origin master 如果提示： 1There is no tracking information for the current branch. 那是因为本地库和远程库没有建立联系，git认为这两个仓库可能不是同一个，如果我们确认对应库没问题，可以使用： 1$ git pull origin master --allow-unrelated-histories 将远程库文件强制拉到本地仓库。之后再执行push命令将项目推到远程仓库。 1git push -u origin master 三、Cocoapods配置文件1、添加.swift-version.swift-version文件用来告诉cocoapods当前文件swift的版本，用命令行建立： 1$ echo &quot;3.0&quot; &gt; .swift-version 2、添加LICENSE每个使用cocoapods添加的库都需要准守开源协议，一般是MIT协议，因为bitbucket没法自动生成，我们可以手动生成这个同名文件，然后把协议内容复制进去： 123456789101112131415161718192021MIT LicenseCopyright (c) [year] [fullname]Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE. 3、创建库描述文件可以通过命令行生成描述文件： 1$ pod spec create ABTest 然后我们编辑ABTest.podspec文件，可以仿照下面的写法 12345678910111213141516171819202122232425262728Pod::Spec.new do |s|s.name = &quot;ABTest&quot;s.version = &quot;0.0.1&quot;s.summary = &quot;ABTest with Firebase&quot;s.description = &quot;This is a ABTest Framworks on swift&quot;s.homepage = &quot;https://bitbucket.org/sealcn/remoteabtest/src/master/&quot;s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; }s.author = { &quot;zhangferry&quot; =&gt; &quot;zhangfei@dailyinnovation.biz&quot; }# ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #s.platform = :ios, &quot;8.0&quot;# ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #s.source = { :git =&gt; &quot;https://zhangferry@bitbucket.org/sealcn/remoteabtest.git&quot;, :tag =&gt; s.version }s.source_files = &quot;Source&quot;, &quot;Source/*.swift&quot;# ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― ## s.resource = &quot;icon.png&quot;# s.resources = &quot;Resources/*.png&quot;# ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #s.requires_arc = trues.static_framework = trues.dependency &quot;Firebase/Core&quot;s.dependency &quot;Firebase/RemoteConfig&quot;#s.ios.vendored_frameworks = &quot;ABTest.framework&quot;s.xcconfig = { 'SWIFT_INCLUDE_PATHS' =&gt; '$(PODS_ROOT)/Firebase/CoreOnly/Sources' }end 此时我们的文件目录看起来应该大概是这个样子： 4、验证本地podspec文件 1pod lib lint 该命令用于检查podspec文件书写是否正确，如果有error需要解决，warning可以不用管（可能会遇到较多问题，需耐心解决0。0）。解决之后再次运行检查命令，当命令行显示： 12-&gt; ABTest (0.0.1)ABTest passed validation. 说明我们本地配置成功了，到这里本地的第一个版本就算完成了！然后我们需要将本次修改提交打上tag，提交到远程仓库。 12345git add .git commit -m &quot;build v0.0.1&quot;git push origin mastergit tag 0.0.1git push --tags 5、验证远程索引文件上传代码成功之后，我们需要再次验证它跟远程仓库（ABTest远程库和.podspec）是否匹配正确，执行： 1pod spec lint 当出现： 1ABTest.podspec passed validation 时，说明我们远程仓库匹配正确。 6、提交podspec文件到SpecsRepo 1$ pod repo push SealRepo ABTest.podspec 这个命令会包含pod spec lint命令，验证通过之后，会添加.podspec文件到本地索引库： 和远程索引库： 使用私有库引用私有库我们可以像使用其他库文件一样在Podfile文件中添加使用私有库了，引入方法有两种： 1、全局添加在Podfile文件最上面添加一行： 1source 'https://zhangferry@bitbucket.org/sealcn/sealrepo.git' 注意：如果私有仓库和cocoapods仓库出现同名库，会出现不可预期的情况（随机拉下来公有库或者私有库文件）。这时我们需要使用单独添加的方式。 2、单独添加 1pod 'ABTest', :git =&gt; 'https://zhangferry@bitbucket.org/sealcn/remoteabtest.git' 使用时通过import方法导入库就可以了。 更新私有库当我们需要升级私有库，添加或者修改方法时，只需要： 1、修改.podspec文件中s.version的版本号 2、提交本地修改至远程，打上对应tag 3、使用项目的工程执行pod update 可能遇到的问题1、pod search 查不到本地库这个可能是cocoadpods本身问题，pod install安装没有问题 2、更新了版本，但是pod update没有找到我们可以采用如下形式，手动指定版本号： 1pod 'ABTest', :git =&gt; 'https://zhangferry@bitbucket.org/sealcn/remoteabtest.git', :tag =&gt; '0.0.4' 3、提示The 'Pods-App' target has transitive dependencies that include static binaries这是因为引入的库被编译成了静态库，我们可以在.podspec文件中加入： 1s.static_framework = true 4、引入的第三方库，在pod lint时提示找不到可以手动指定pod目录，将firsebase替换成你的库文件路径: 1s.xcconfig = { 'SWIFT_INCLUDE_PATHS' =&gt; '$(PODS_ROOT)/Firebase/CoreOnly/Sources' } 5、提示source_files对应文件为空每次pod lint时都是根据版本号进行查找的，可以检查下当前修改跟版本号是否对应。","link":"/2018/08/30/private-Cocoapods/"},{"title":"OC项目转Swift指南","text":"运行环境：Xcode 11.1 Swift5.0 最近参与的一个项目需要从Objective-C（以下简称OC）转到Swift，期间遇到了一些坑，于是有了这篇总结性的文档。如果你也有将OC项目Swift化的需求，可以作为参考。 OC转Swift有一个大前提就是你要对Swift有一定的了解，熟悉Swift语法，最好是完整看过一遍官方的Language Guide。 转换的过程分自动化和手动转译，鉴于自动化工具的识别率不能让人满意，大部分情况都是需要手动转换的。 自动化工具有一个比较好的自动化工具Swiftify，可以将OC文件甚至OC工程整个转成Swift，号称准确率能达到90%。我试用了一些免费版中的功能，但感觉效果并不理想，因为没有使用过付费版，所以也不好评价它就是不好。 Swiftify还有一个Xcode的插件Swiftify for Xcode，可以实现对选中代码和单文件的转化。这个插件还挺不错，对纯系统代码转化还算精确，但部分代码还存在一些识别问题，需要手动再修改。 手动Swift化桥接文件如果你是在项目中首次使用Swift代码，在添加Swift文件时，Xcode会提示你添加一个.h的桥接文件。如果不小心点了不添加还可以手动导入，就是自己手动生成一个.h文件，然后在Build Settings &gt; Swift Compiler - General &gt; Objective-C Bridging Header中填入该.h文件的路径。 这个桥接文件的作用就是供Swift代码引用OC代码，或者OC的三方库。 12#import &quot;Utility.h&quot;#import &lt;Masonry/Masonry.h&gt; 在Bridging Header的下面还有一个配置项是Objective-C Generated Interface Header Name，对应的值是ProjectName-Swift.h。这是由Xcode自动生成的一个隐藏头文件，每次Build的过程会将Swift代码中声明为外接调用的部分转成OC代码，OC部分的文件会类似pch一样全局引用这个头文件。因为是Build过程中生成的，所以只有.m文件中可以直接引用，对于在.h文件中的引用下文有介绍。 Appdelegate(程序入口)Swift中没有main.m文件，取而代之的是@UIApplicationMain命令，该命令等效于原有的执行main.m。所以我们可以把main.m文件进行移除。 系统API对于UIKit框架中的大部分代码转换可以直接查看系统API文档进行转换，这里就不过多介绍。 property(属性)Swift没有property，也没有copy，nonatomic等属性修饰词，只有表示属性是否可变的let和var。 注意点一OC中一个类分.h和.m两个文件，分别表示用于暴露给外接的方法，变量和仅供内部使用的方法变量。迁移到Swift时，应该将.m中的property标为private，即外接无法直接访问，对于.h中的property不做处理，取默认的internal，即同模块可访问。 对于函数的迁移也是相同的。 注意点二有一种特殊情况是在OC项目中，某些属性在内部（.m）可变，外部（.h）只读。这种情况可以这么处理： 1private(set) var value: String 就是只对value的set方法就行private标记。 注意点三Swift中针对空类型有个专门的符号?，对应OC中的nil。OC中没有这个符号，但是可以通过在nullable和nonnull表示该种属性，方法参数或者返回值是否可以空。 如果OC中没有声明一个属性是否可以为空，那就去默认值nonnull。 如果我们想让一个类的所有属性，函数返回值都是nonnull，除了手动一个个添加之外还有一个宏命令。 123NS_ASSUME_NONNULL_BEGIN/* code */NS_ASSUME_NONNULL_END enum（枚举）OC代码： 12345678910111213typedef NS_ENUM(NSInteger, PlayerState) { PlayerStateNone = 0, PlayerStatePlaying, PlayerStatePause, PlayerStateBuffer, PlayerStateFailed,};typedef NS_OPTIONS(NSUInteger, XXViewAnimationOptions) { XXViewAnimationOptionNone = 1 &lt;&lt; 0, XXViewAnimationOptionSelcted1 = 1 &lt;&lt; 1, XXViewAnimationOptionSelcted2 = 1 &lt;&lt; 2,} Swift代码 1234567891011121314enum PlayerState: Int { case none = 0 case playing case pause case buffer case failed}struct ViewAnimationOptions: OptionSet { let rawValue: UInt static let None = ViewAnimationOptions(rawValue: 1&lt;&lt;0) static let Selected1 = ViewAnimationOptions(rawValue: 1&lt;&lt;0) static let Selected2 = ViewAnimationOptions(rawValue: 1 &lt;&lt; 2) //...} Swift没有NS_OPTIONS的概念，取而代之的是为了满足OptionSet协议的struct类型。 懒加载OC代码： 123456- (MTObject *)object { if (!_object) { _object = [MTObject new]; } return _object;} Swift代码： 1234lazy var object: MTObject = { let object = MTObject() return imagobjecteView}() 闭包OC代码： 1typedef void (^DownloadStateBlock)(BOOL isComplete); Swift代码： 1typealias DownloadStateBlock = ((_ isComplete: Bool) -&gt; Void) 单例OC代码： 1234567+ (XXManager *)shareInstance { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc] init]; }); return instance;} Swift对单例的实现比较简单，有两种方式： 第一种 123let shared = XXManager()// 声明在全局命名区（global namespace）Class XXManager { } 你可能会疑惑，为什么没有dispatch_once，如何保证多线程下创建的唯一性？其实是这样的，Swift中全局变量是懒加载，在AppDelegate中被初始化，之后所有的调用都会使用该实例。而且全局变量的初始化是默认使用dispatch_once的，这保证了全局变量的构造器（initializer）只会被调用一次，保证了shard的原子性。 第二种 123456Class XXManager { static let shared = XXManager() private override init() { // do something }} Swift 2 开始增加了static关键字，用于限定变量的作用域。如果不使用static，那么每一个shared都会对应一个实例。而使用static之后，shared成为全局变量，就成了跟上面第一种方式原理一致。可以注意到，由于构造器使用了 private 关键字，所以也保证了单例的原子性。 初始化方法和析构函数对于初始化方法OC先调用父类的初始化方法，然后初始自己的成员变量。Swift先初始化自己的成员变量，然后在调用父类的初始化方法。 OC代码： 123456789101112131415161718// 初始化方法@interface MainView : UIView@property (nonatomic, strong) NSString *title;- (instancetype)initWithFrame:(CGRect)frame title:(NSString *)title NS_DESIGNATED_INITIALIZER;@end@implementation MainView- (instancetype)initWithFrame:(CGRect)frame title:(NSString *)title { if (self = [super initWithFrame:frame]) { self.title = title; } return self;}@end// 析构函数- (void)dealloc { //dealloc} Swift代码： 12345678910111213class MainViewSwift: UIView { let title: String init(frame: CGRect, title: String) { self.title = title super.init(frame: frame) } required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } deinit { //deinit }} 函数调用OC代码： 123456// 实例函数（共有方法）- (void)configModelWith:(XXModel *)model {}// 实例函数（私有方法）- (void)calculateProgress {}// 类函数+ (void)configModelWith:(XXModel *)model {} Swift代码： 12345678910// 实例函数（共有方法）func configModel(with model: XXModel) {}// 实例函数（私有方法）private func calculateProgress() {}// 类函数（不可以被子类重写）static func configModel(with model: XXModel) {}// 类函数（可以被子类重写）class func configModel(with model: XXModel) {}// 类函数（不可以被子类重写）class final func configModel(with model: XXModel) {} OC可以通过是否将方法声明在.h文件表明该方法是否为私有方法。Swift中没有了.h文件，对于方法的权限控制是通过权限关键词进行的，各关键词权限大小为：private &lt; fileprivate &lt; internal &lt; public &lt; open 其中internal为默认权限，可以在同一module下访问。 NSNotification(通知)OC代码： 1234// add observer[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(method) name:@&quot;NotificationName&quot; object:nil];// post[NSNotificationCenter.defaultCenter postNotificationName:@&quot;NotificationName&quot; object:nil]; Swift代码： 1234// add observerNotificationCenter.default.addObserver(self, selector: #selector(method), name: NSNotification.Name(rawValue: \"NotificationName\"), object: nil)// postNotificationCenter.default.post(name: NSNotification.Name(rawValue: \"NotificationName\"), object: self) 可以注意到，Swift中通知中心NotificationCenter不带NS前缀，通知名由字符串变成了NSNotification.Name的结构体。 改成结构体的目的就是为了便于管理字符串，原本的字符串类型变成了指定的NSNotification.Name类型。上面的Swift代码可以修改为： 1234567extension NSNotification.Name { static let NotificationName = NSNotification.Name(\"NotificationName\")}// add observerNotificationCenter.default.addObserver(self, selector: #selector(method), name: .NotificationName, object: nil)// postNotificationCenter.default.post(name: .NotificationName, object: self) protocol(协议/代理)OC代码： 123456789@protocol XXManagerDelegate &lt;NSObject&gt;- (void)downloadFileFailed:(NSError *)error;@optional- (void)downloadFileComplete;@end @interface XXManager: NSObject@property (nonatomic, weak) id&lt;XXManagerDelegate&gt; delegate; @end Swift中对protocol的使用拓宽了许多，不光是class对象，struct和enum也都可以实现协议。需要注意的是struct和enum为指引用类型，不能使用weak修饰。只有指定当前代理只支持类对象，才能使用weak。将上面的代码转成对应的Swift代码，就是： 1234567@objc protocol XXManagerDelegate { func downloadFailFailed(error: Error) @objc optional func downloadFileComplete() // 可选协议的实现}class XXManager: NSObject { weak var delegate: XXManagerDelegate? } @objc是表明当前代码是针对NSObject对象，也就是class对象，就可以正常使用weak了。 如果不是针对NSObject对象的delegate，仅仅是普通的class对象可以这样设置代理： 123456protocol XXManagerDelegate: class { func downloadFailFailed(error: Error)}class XXManager { weak var delegate: XXManagerDelegate?} 值得注意的是，仅@objc标记的protocol可以使用@optional。 Swift和OC混编注意事项函数名的变化如果你在一个Swift类里定义了一个delegate方法： 123@objc protocol MarkButtonDelegate { func clickBtn(title: String)} 如果你要在OC中实现这个协议，这时候方法名就变成了： 123- (void)clickBtnWithTitle:(NSString *)title { // code} 这主要是因为Swift有指定参数标签，OC却没有，所以在由Swift方法名生成OC方法名时编译器会自动加一些修饰词，已使函数作为一个句子可以”通顺”。 在OC的头文件里调用Swift类如果要在OC的头文件里引用Swift类，因为Swift没有头文件，而为了让在头文件能够识别该Swift类，需要通过@class的方法引入。 12345@class SwiftClass;@interface XXOCClass: NSObject@property (nonatomic, strong) SwiftClass *object;@end 对OC类在Swift调用下重命名因为Swift对不同的module都有命名空间，所以Swift类都不需要添加前缀。如果有一个带前缀的OC公共组件，在Swift环境下调用时不得不指定前缀是一件很不优雅的事情，所以苹果添加了一个宏命令NS_SWIFT_NAME，允许在OC类在Swift环境下的重命名： 123NS_SWIFT_NAME(LoginManager)@interface XXLoginManager: NSObject@end 这样我们就将XXLoginManager在Swift环境下的类名改为了LoginManager。 引用类型和值类型1、 struct 和 enum 是值类型，类 class 是引用类型。2、String，Array和 Dictionary都是结构体，因此赋值直接是拷贝，而NSString, NSArray 和NSDictionary则是类，所以是使用引用的方式。3、struct 比 class 更“轻量级”，struct 分配在栈中，class 分配在堆中。 id类型和AnyObjectOC中id类型被Swift调用时会自动转成AnyObject，他们很相似，但却其实概念并不一致。AnyObject可以代表任何class类型的实例； 其他语法区别及注意事项（待补充）1、Swift语句中不需要加分号;。2、关于Bool类型更加严格，Swift不再是OC中的非0就是真，真假只对应true和false。3、Swift类内一般不需要写self，但是闭包内是需要写的。4、Swift是强类型语言，必须要指定明确的类型。在Swift中Int和Float是不能直接做运算的，必须要将他们转成同一类型才可以运算。5、Swift抛弃了传统的++，--运算，抛弃了传统的C语言式的for循环写法，而改为for-in。6、Swift的switch操作，不需要在每个case语句结束的时候都添加break。7、Swift对enum的使用做了很大的扩展，可以支持任意类型，而OC枚举仅支持Int类型，如果要写兼容代码，要选择Int型枚举。8、Swift代码要想被OC调用，需要在属性和方法名前面加上@objc。9、Swift独有的特性，如泛型，struct，非Int型的enum等被包含才函数参数中，即使添加@objc也不会被编译器通过。10、Swift支持重载，OC不支持。11、带默认值的Swift函数再被OC调用时会自动展开。 语法检查对于OC转Swift之后的语法变化还有很多细节值得注意，特别是对于初次使用Swift这门语言的同学，很容易遗漏或者待着OC的思想去写代码。这里推荐一个语法检查的框架SwiftLint，可以自动化的检查我们的代码是否符合Swift规范。 可以通过cocoapods进行引入，配置好之后，每次Build的过程，Lint脚本都会执行一遍Swift代码的语法检查操作，Lint还会将代码规范进行分级，严重的代码错误会直接报错，导致程序无法启动，不太严重的会显示代码警告（⚠️）。 如果你感觉SwiftLint有点过于严格了，还可以通过修改.swiftlint.yml文件，自定义属于自己的语法规范。","link":"/2019/12/07/transfom_oc_to_swift/"},{"title":"Runtime内存模型探究","text":"Objective-C是一种通用、高级、面向对象的编程语言。它扩展了标准的ANSI C编程语言，将Smalltalk式的消息传递机制加入到ANSI C中。 可以这么理解，Objective-C = C + Runtime，Runtime是将C语言具有面向对象功能的推动剂，是iOS开发中的核心概念。我们可以在苹果开源的 runtime（当前的最新版本objc4-779.1.tar.gz）中可以发现一些 Objective-C 对象模型的实现细节。 NSObject的实现OC中几乎所有的类都继承自NSObject，OC的动态性也是通过NSObject实现的，那就从NSObject开始探索。 在runtime源码中的NSObject.h中，我们可以找到NSObject的定义： 123@interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY;} 可以看出NSObject里有一个指向Class的isa，其中对于Class的定义在objc.h： 1234567/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY;}; objc_class代表类对象，objc_object代表实例对象，objc_object的isa指向objc_class。这里可以得出一个结论，实例对象的isa是指向类（类对象）的。其实类（objc_class）也有一个isa属性，那它指向什么呢？ Meta Class（元类）这里runtime为了设计上的统一性，引入了元类（meta class）的概念。 对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。 objc_class的isa指向meta class，甚至meta class也有isa指针，它指向根元类（root meta class）。实例对象，类对象，元类和根元类的关系如下图所示： 类和元类形成了一个完整的闭环，其中有两条关系需要注意： 元类的isa均指向根元类，根元类指向自己 根元类继承根类（NSObject） ObjectiveC1.0数据模型我们可以在runtime.h中查看objc_class的定义。 1234567891011121314151617struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 注意这两个宏命令：!__OBJC2__和OBJC2_UNAVAILABLE，他们均是为了提示当前的objc_class结构是Objc2之前的结构设计，即Objc1.0的设计。 从这个objc_class的定义我们可以看出它包含了超类的指针(super_class)，类名(name)，实例大小(instance_size)，objc_ivar_list成员变量列表的指针(ivars)，指向objc_method_list指针的指针(methodLists)。 注意*methodLists是指向方法列表的指针，可以动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。 剩下的objc_cache代表函数的缓存列表，objc_protocol_list代表协议列表。 Objective语言历史我在网上查资料的时候发现关于runtime的文章非常多，但提示数据模型在OC1.0和2.0之间区别的非常少，其实这一点很重要的。这也是为什么我将这段标题命名为Objective-C1.0数据模型的原因。 这里补一点Objective-C语言的发展历史（维基百科）： Objective-C1.0 即Objective-C++ 由Stepstone 公司的布莱德·考克斯（Brad Cox）和 汤姆·洛夫（Tom Love） 在 1980 年代发明。它是GCC的一个前端，它可以编译混合C++与Objective-C语法的源文件。Objective-C++是C++的扩展，类似于Objective-C是C的扩展。 Objective-C2.0 在2006年7月苹果全球开发者会议中，Apple宣布了“Objective-C 2.0”的发布，其增加了“现代的垃圾收集，语法改进，运行时性能改进，以及64位支持”。 Objective2.0数据模型可以在objc-runtim-new.h文件找到新版对objc_class的数据模型定义： 12345678910111213141516171819202122struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() const { return bits.data(); }}struct objc_object {private: isa_t isa;}union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;} 会发现objc_class不再是一个单独的结构体，而是继承于objc_object，objc_object内部的isa变成了isa_t的联合体。 class_data_bits_t我们再回来看类中的其他属性，之前表示类的属性、方法、以及遵循的协议都放在了class_data_bits_t中，更准确的说是放在了class_rw_t。 123456789101112131415161718192021222324252627282930313233343536373839404142struct class_data_bits_t { friend objc_class; // Values are the FAST_ flags above. uintptr_t bits; class_rw_t* data() const { return (class_rw_t *)(bits &amp; FAST_DATA_MASK); }}struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint16_t version; uint16_t witness; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols;}struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties;} 这里面引入了class_rw_t和class_ro_t（rw-readwrite，ro-readonly）两个结构体。可以看到class_rw_t是包含一个常量指针ro，结构体为class_ro_t。这里存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。在 ObjC 运行时的时候会调用 realizeClass 方法，将class_ro_t传入class_rw_t，所以新版的动态性是通过这种方式实现的。 cache_t12345678910111213141516171819struct cache_t { static bucket_t *emptyBuckets(); struct bucket_t *buckets(); mask_t mask(); mask_t occupied();}struct bucket_t { // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ explicit_atomic&lt;uintptr_t&gt; _imp; explicit_atomic&lt;SEL&gt; _sel;#else explicit_atomic&lt;SEL&gt; _sel; explicit_atomic&lt;uintptr_t&gt; _imp;#endif} cache_t是objc_class中的缓存结构体，里面通过bucket_t结构体存储一些最近调用的函数。设置cache最大的原因就是OC为动态语言，函数的执行是通过消息调用实现的，消息调用会首先查找当前类中的方法列表，如果找不到会查找父类，直到检索至NSObject依然找不到函数实现，就会进入消息转发流程。而为了节省每次查找函数表的开销，发明了cache_t。我们从bucket_t的内联函数中可以看出，缓存的SEL和IMP都是在内存中进行加载的。 method_t1234567891011121314struct method_t { SEL name; const char *types; MethodListIMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; { bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) { return lhs.name &lt; rhs.name; } };}; 这是函数的结构体，里面包含3个成员变量。SEL是方法的名字name。types是类型编码，类型可参考Type Encoding。IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。 数据模型对比最后总结下，Objc1.0到2.0的对比：这两张图片引用自寒神博客。 参考链接 深入解析 ObjC 中方法的结构 神经病院 Objective-C Runtime 入院第一天—— isa 和 Class","link":"/2020/02/23/runtime_objc_class/"},{"title":"iOS10本地通知UserNotifications快速入门","text":"iOS10更新变动最大的就是通知这部分了，新版通知变得更加统一，使用更加方便，设计更加自由。以前本地通知和远程推送是分开的，虽然这些到了iOS10都合在一起了，但是为了便于理解，我们还是把他俩分开来进行学习。这节我们学习的是本地通知。 以下的用语，如无特别表述，通知就代表本地通知，推送就代表远程服务器的推送。 ##快速添加一个通知我们先举个完整的代码例子，大家了解下这个流程，然后分步介绍这几项： 12345678910111213141516171819202122232425262728293031323334//第一步：注册通知- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; //请求获取通知权限（角标，声音，弹框） [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) { if (granted) { //获取用户是否同意开启通知 NSLog(@\"request authorization successed!\"); } }]; } //第二步：新建通知内容对象 UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init] content.title = @\"iOS10通知\"; content.subtitle = @\"新通知学习笔记\"; content.body = @\"新通知变化很大，之前本地通知和远程推送是两个类，现在合成一个了。这是一条测试通知，\"; content.badge = @1; UNNotificationSound *sound = [UNNotificationSound soundNamed:@\"caodi.m4a\"]; content.sound = sound; //第三步：通知触发机制。（重复提醒，时间间隔要大于60s） UNTimeIntervalNotificationTrigger *trigger1 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; //第四步：创建UNNotificationRequest通知请求对象 NSString *requertIdentifier = @\"RequestIdentifier\"; UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requertIdentifier content:content trigger:trigger1]; //第五步：将通知加到通知中心 [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) { NSLog(@\"Error:%@\",error); }];} 最终效果如下： 通知内容UNMutableNotificationContent 通知内容就是设定通知的一些展示信息，iOS10之后可以设置subtitle。声音的设置需要借助一个新类UNNotificationSound，通知文件要放到bundle里面。另外在实际的测试过程中发现，添加通知的声音有时候会无效。这应该是iOS10存在的一个bug，删除掉程序，再安装运行就好了。 触发机制UNNotificationTrigger Trigger是新加入的一个功能，通过此类可设置本地通知触发条件。它一共有一下几种类型：1、UNPushNotificaitonTrigger推送服务的Trigger，由系统创建2、UNTimeIntervalNotificaitonTrigger时间触发器，可以设置多长时间以后触发，是否重复。如果设置重复，重复时长要大于60s3、UNCalendarNotificaitonTrigger日期触发器，可以设置某一日期触发。例如，提醒我每天早上七点起床： 123NSDateComponents *components = [[NSDateComponents alloc] init];components.hour = 7;components.minute = 0; // components 日期 UNCalendarNotificationTrigger *calendarTrigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES]; 4、UNLocationNotificaitonTrigger位置触发器，用于到某一范围之后，触发通知。通过CLRegion设定具体范围。 通知请求UNNotificationRequest 通知请求的构造+ (instancetype)requestWithIdentifier:(NSString *)identifier content:(UNNotificationContent *)content trigger:(nullable UNNotificationTrigger *)trigger;就是把上面三项连接起来。它有一个参数identifier，这相当于通知的一个身份。iOS10通知支持更新，就是基于此identifier再发一条通知。 通知中心UNUserNotificationCenter 获取通知[UNUserNotificationCenter currentNotificationCenter]然后通过addNotificaitonRequest:就完成了一个通知的添加。 ##扩展通知的内容通知我们已经添加上了，现在我们需要扩展一下通知的内容，给它加一些内容。扩展的内容需要支持3D-touch的手机（6s以上），重压之后全面显示 添加附件 iOS10之前通知的样式不能更改，在iOS10之后引入了UNNotificationationAttachment，可以在通知中添加图片，音频，视频。苹果对这些附件的大小和类型有一个限制：如果我想在通知里加一个图片，可以这样处理： 1234NSString *imageFile = [[NSBundle mainBundle] pathForResource:@\"sport\" ofType:@\"png\"];UNNotificationAttachment *imageAttachment = [UNNotificationAttachment attachmentWithIdentifier:@\"iamgeAttachment\" URL:[NSURL fileURLWithPath:imageFile] options:nil error:nil];content.attachments = @[imageAttachment];//虽然是数组，但是添加多个只能显示第一个/* add request and notificaiton code ... */ 效果如下： 重压之后： 添加交互 12345678910111213//点击可以显示文本输入框UNTextInputNotificationAction *action1 = [UNTextInputNotificationAction actionWithIdentifier:@\"replyAction\" title:@\"文字回复\" options:UNNotificationActionOptionNone]; //点击进入应用UNNotificationAction *action2 = [UNNotificationAction actionWithIdentifier:@\"enterAction\" title:@\"进入应用\" options:UNNotificationActionOptionForeground]; //点击取消，没有任何操作UNNotificationAction *action3 = [UNNotificationAction actionWithIdentifier:@\"cancelAction\" title:@\"取消\" options:UNNotificationActionOptionDestructive]; //通过UNNotificationCategory对象将这几个action行为添加到通知里去UNNotificationCategory *categroy = [UNNotificationCategory categoryWithIdentifier:@\"Categroy\" actions:@[action1,action2,action3] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; //将categroy赋值到通知内容上 content.categoryIdentifier = @\"Categroy\"; //设置通知代理，用于检测点击方法[[UNUserNotificationCenter currentNotificationCenter] setDelegate:self];/* add request and notificaiton code ... */ 效果如下： 获取通知交互内容： 1234567891011121314151617181920212223//识别通知交互处理的代理方法- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler{ NSString *categoryIdentifier = response.notification.request.content.categoryIdentifier; if ([categoryIdentifier isEqualToString:@\"Categroy\"]) { //识别需要被处理的拓展 if ([response.actionIdentifier isEqualToString:@\"replyAction\"]){ //识别用户点击的是哪个 action UNTextInputNotificationResponse *textResponse = (UNTextInputNotificationResponse*)response; //获取输入内容 NSString *userText = textResponse.userText; //发送 userText 给需要接收的方法 NSLog(@\"要发送的内容是：%@\",userText); //[ClassName handleUserText: userText]; }else if([response.actionIdentifier isEqualToString:@\"enterAction\"]){ NSLog(@\"点击了进入应用按钮\"); }else{ NSLog(@\"点击了取消\"); } } completionHandler();} 由此我们可以知道action，categroy，request这些东西都是通过各自的identifier获取的。这样可以很方便的定位到某一个通知或者action上，为交互的处理提供了很大的便利。##自定义通知样式在Xcode中File-&gt;New-&gt;Targe会出现下面的视图 Notification Content对应的是通知，Notification Service Extension对应的是推送。我们这里要实现通知的自定义，选择左边那个。创建成功之后会在工程里多一个文件件NotificationViewController文件是自动生成的，里面有一个- (void)didReceiveNotification:(UNNotification *)notification可以在这里定义一些通知的显示。 MainInterface.storyboard文件是控制通知的storyboard文件，可以编辑需要的通知样式。我们设计一下文字的颜色和显示位置 接下来你可能会问，怎么把这个自定义的通知样式应用到当前通知里呢？先别急，我们看下一个文件Info.flist里面的内容 第一项UNNotificationExtensionCategory就是UNNotificationCategory的标示，我们把他换成我们通知里使用的标示&quot;Category&quot;，系统就会自动匹配通知显示的样式。第二项UNNotificationExtensionIntialContentSizeRation初始内容 Size 的比例。也可以在 viewDidLoad 中使用 self.preferredContentSize 直接设置 Size。第三项UNNotificationExtensionDefaultContentHidden是否隐藏默认内容，如果设为YES，默认内容会被隐藏。显示的效果： ##总结至此，iOS通知部分的内容就学完了，参考代码：Demo。参考文档：iOS10 User Notificaitons学习笔记活久见的重构-iOS10 UserNotificaiotns框架解析","link":"/2016/09/30/usernotifications-introduction/"},{"title":"iOS蓝牙知识快速入门（详尽版）","text":"以前写过几篇蓝牙相关的文章，但是没有涉及扫描、收发指令这些基础功能的实现。所以打算写一篇尽可能详尽的蓝牙知识汇总，一方面给有需要的同学看，一方面是对自己学习蓝牙的一个总结。 这篇文章的目的：教你实现设备的扫描，连接，数据收发，蓝牙数据解析。如果在实现上面任一功能遇到问题时，欢迎留下你的问题，我将进行补充，对于说法有误的地方也请老司机予以指正。 目录 0、思维导图1、苹果对蓝牙设备有什么要求2、操作蓝牙设备使用什么库3、如何扫描4、如何连接5、如何发送数据和接收数据6、如何解析数据7、扩展 思维导图第一次做图，大家凑合着看哈。这张是我总结的蓝牙知识的结构图，下面的内容将围绕这些东西展开进行。这张是蓝牙连接发送数据的流程图，下文进入coding阶段的讲解顺序，大家先有个大概印象，等阅读完本文再回来看这张图将理解的更深一些。 苹果对蓝牙设备有什么要求BLE：bluetouch low energy，蓝牙4.0设备因为低功耗，所有也叫作BLE。苹果在iphone4s及之后的手机型号开始支持蓝牙4.0，这也是最常见的蓝牙设备。低于蓝牙4.0协议的设备需要进行MFI认证，关于MFI认证的申请工作可以看这里：关于MFI认证你所必须要知道的事情 在进行操作蓝牙设备前，我们先下载一个蓝牙工具LightBlue，它可以辅助我们的开发，在进行蓝牙开发之前建议先熟悉一下LightBlue这个工具。 操作蓝牙设备使用什么库苹果自身有一个操作蓝牙的库CoreBluetooth.framework，这个是大多数人员进行蓝牙开发的首选框架，除此之外目前github还有一个比较流行的对原生框架进行封装的三方库BabyBluetooth，它的机制是将CoreBluetooth中众多的delegate写成了block方法，有兴趣的同学可以了解下。下面主要介绍的是原生蓝牙库的知识。 中心和外围设备 如图所示，电脑、Pad、手机作为中心，心跳监听器作为外设，这种中心外设模式是最常见的。简单理解就是，发起连接的是中心设备（Central），被连接的是外围设备（Peripheral），对应传统的客户机-服务器体系结构。Central能够扫描侦听到，正在播放广告包的外设。 服务与特征外设可以包含一个或多个服务（CBService），服务是用于实现装置的功能或特征数据相关联的行为集合。而每个服务又对应多个特征（CBCharacteristic）,特征提供外设服务进一步的细节，外设，服务，特征对应的数据结构如下所示 如何扫描蓝牙在进行扫描之前我们需要，首先新建一个类作为蓝牙类，例如FYBleManager，写成单例，作为处理蓝牙操作的管理类。引入头文件#import &lt;CoreBluetooth/CoreBluetooth.h&gt;CBCentralManager是蓝牙中心的管理类，控制着蓝牙的扫描，连接，蓝牙状态的改变。 1、初始化dispatch_queue_t centralQueue = dispatch_queue_create(“centralQueue&quot;,DISPATCH_QUEUE_SERIAL); NSDictionary *dic = @{CBCentralManagerOptionShowPowerAlertKey : YES, CBCentralManagerOptionRestoreIdentifierKey : @&quot;unique identifier&quot; }; self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:centralQueue options:dic];CBCentralManagerOptionShowPowerAlertKey对应的BOOL值，当设为YES时，表示CentralManager初始化时，如果蓝牙没有打开，将弹出Alert提示框CBCentralManagerOptionRestoreIdentifierKey对应的是一个唯一标识的字符串，用于蓝牙进程被杀掉恢复连接时用的。 2、扫描//不重复扫描已发现设备 NSDictionary *option = @{CBCentralManagerScanOptionAllowDuplicatesKey : [NSNumber numberWithBool:NO],CBCentralManagerOptionShowPowerAlertKey:YES}; [self.centralManager scanForPeripheralsWithServices:nil options:option]; - (void)scanForPeripheralsWithServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;扫面方法，serviceUUIDs用于第一步的筛选，扫描此UUID的设备options有两个常用参数：CBCentralManagerScanOptionAllowDuplicatesKey设置为NO表示不重复扫瞄已发现设备，为YES就是允许。CBCentralManagerOptionShowPowerAlertKey设置为YES就是在蓝牙未打开的时候显示弹框 3、CBCentralManagerDelegate代理方法在初始化的时候我们调用了代理，在CoreBluetooth中有两个代理， CBCentralManagerDelegate CBPeripheralDelegate iOS的命名很友好，我们通过名字就能看出，上面那个是关于中心设备的代理方法，下面是关于外设的代理方法。我们这里先研究CBCentralManagerDelegate中的代理方法 - (void)centralManagerDidUpdateState:(CBCentralManager *)central;这个方法标了@required是必须添加的，我们在self.centralManager初始换之后会调用这个方法，回调蓝牙的状态。状态有以下几种： typedef NS_ENUM(NSInteger, CBCentralManagerState{ CBCentralManagerStateUnknown = CBManagerStateUnknown,//未知状态 CBCentralManagerStateResetting = CBManagerStateResetting,//重启状态 CBCentralManagerStateUnsupported = CBManagerStateUnsupported,//不支持 CBCentralManagerStateUnauthorized = CBManagerStateUnauthorized,//未授权 CBCentralManagerStatePoweredOff = CBManagerStatePoweredOff,//蓝牙未开启 CBCentralManagerStatePoweredOn = CBManagerStatePoweredOn,//蓝牙启 } NS_DEPRECATED(NA, NA, 5_0, 10_0, &quot;Use CBManagerState instead”);该枚举在iOS10之后已经废除了，系统推荐使用CBManagerState，类型都是对应的 typedef NS_ENUM(NSInteger, CBManagerState{ CBManagerStateUnknown = 0, CBManagerStateResetting, CBManagerStateUnsupported, CBManagerStateUnauthorized, CBManagerStatePoweredOff, CBManagerStatePoweredOn, } NS_ENUM_AVAILABLE(NA, 10_0); - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI;peripheral是外设类advertisementData是广播的值，一般携带设备名，serviceUUIDs等信息RSSI绝对值越大，表示信号越差，设备离的越远。如果想装换成百分比强度，（RSSI+100）/100，（这是一个约数，蓝牙信号值并不一定是-100 - 0的值，但近似可以如此表示） - (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict;在蓝牙于后台被杀掉时，重连之后会首先调用此方法，可以获取蓝牙恢复时的各种状态 如何连接在扫面的代理方法中，我们连接外设名是MI的蓝牙设备 - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{ NSLog(@&quot;advertisementData:%@，RSSI:%@&quot;,advertisementData,RSSI); if([peripheral.name isEqualToString:@&quot;MI&quot;]){ [self.centralManager connectPeripheral:peripheral options:nil];//发起连接的命令 self.peripheral = peripheral; } }连接的状态对应另外的CBCentralManagerDelegate代理方法连接成功的回调 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral;连接失败的回调 - (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error;连接断开的回调 - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error;连接成功之后并没有结束，还记得CBPeripheral中的CBService和CBService中的CBCharacteristic吗，对数据的读写是由CBCharacteristic控制的。我们先用lightblue连接小米手环为例，来看一下，手环内部的数据是不是我们说的那样。 其中ADVERTISEMENT DATA显示的就是广播信息。 iOS蓝牙无法直接获取设备蓝牙MAC地址，可以将MAC地址放到这里广播出来 FEEO是ServiceUUIDs,里面的FF01、FF02是CBCharacteristic的UUID Properties是特征的属性，可以看出FF01具有读的权限，FF02具有读写的权限。特征拥有的权限类别有如下几种： typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties{ CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200};如何发送并接收数据通过上面的步骤我们发现CBCentralManagerDelegate提供了蓝牙状态监测、扫描、连接的代理方法，但是CBPeripheralDelegate的代理方法却还没使用。别急，马上就要用到了，通过名称判断这个代理的作用，肯定是跟Peripheral有关，我们进入系统API，看它的代理方法都有什么，因为这里的代理方法较多，我就挑选几个常用的拿出来说明一下。 1、代理方法//发现服务的回调 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error; //发现特征的回调 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error; //读数据的回调 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //是否写入成功的回调 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error;2、步骤通过这几个方法我们构建一个流程：连接成功-&gt;获取指定的服务-&gt;获取指定的特征-&gt;订阅指定特征值-&gt;通过具有写权限的特征值写数据-&gt;在didUpdateValueForCharacteristic回调中读取蓝牙反馈值 解释一下订阅特征值：特征值具有Notify权限才可以进行订阅，订阅之后该特征值的value发生变化才会回调didUpdateValueForCharacteristic 3、实现上面流程的实例代码//连接成功 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{ //连接成功之后寻找服务，传nil会寻找所有服务 [peripheral discoverServices:nil]; } //发现服务的回调 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ if (!error) { for (CBService *service in peripheral.services) { NSLog(@&quot;serviceUUID:%@&quot;, service.UUID.UUIDString); if ([service.UUID.UUIDString isEqualToString:ST_SERVICE_UUID]) { //发现特定服务的特征值 [service.peripheral discoverCharacteristics:nil forService:service]; } } } } //发现characteristics，由发现服务调用（上一步），获取读和写的characteristics - (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error { for (CBCharacteristic *characteristic in service.characteristics) { //有时读写的操作是由一个characteristic完成 if ([characteristic.UUID.UUIDString isEqualToString:ST_CHARACTERISTIC_UUID_READ]) { self.read = characteristic; [self.peripheral setNotifyValue:YES forCharacteristic:self.read]; } else if ([characteristic.UUID.UUIDString isEqualToString:ST_CHARACTERISTIC_UUID_WRITE]) { self.write = characteristic; } } } //是否写入成功的代理 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{ if (error) { NSLog(@&quot;===写入错误：%@&quot;,error); }else{ NSLog(@&quot;===写入成功&quot;); } } //数据接收 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if([characteristic.UUID.UUIDString isEqualToString:ST_CHARACTERISTIC_UUID_READ]){ //获取订阅特征回复的数据 NSData *value = characteristic.value; NSLog(@&quot;蓝牙回复：%@&quot;,value); } }比如我们要获取蓝牙电量，由硬件文档查询得知该指令是**0x1B9901**,那么获取电量的方法就可以写成 - (void)getBattery{ Byte value[3]={0}; value[0]=x1B; value[1]=x99; value[2]=x01; NSData * data = [NSData dataWithBytes:&amp;value length:sizeof(value)]; //发送数据 [self.peripheral writeValue:data forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse]; }如果写入成功，我们将会在didUpdateValueForCharacteristic方法中获取蓝牙回复的信息。 如何解析蓝牙数据如果你顺利完成了上一步的操作，并且看到了蓝牙返回的数据，那么恭喜你，蓝牙的常用操作你已经了解大半了。因为蓝牙的任务大部分就是围绕发送指令，获取指令，将蓝牙数据呈现给用户。上一步我们已经获取了蓝牙指令，但是获取的却是0x567b0629这样的数据，这是什么意思呢。这时我们参考硬件文档，看到这样一段: 那么我们就可以得出设备电量是 60%。 对数据解析的流程就是：判断校验和是否正确，是不是一条正确的数据-&gt;该条数据是不是我们需要的电量数据，即首字节为0x567b-&gt;根据定义规则解析电量，传给view显示。其中第一步校验数据，视情况而定，也有不需要的情况。 扩展iOS蓝牙中的进制转换蓝牙固件升级nRF芯片设备DFU升级","link":"/2017/01/13/bluetooth-intro/"},{"title":"如何通过静态分析提高iOS代码质量","text":"随着项目的扩大，依靠人工codereview来保证项目的质量，越来越不现实，这时就有必要借助于一种自动化的代码审查工具：程序静态分析。 程序静态分析（Program Static Analysis）是指在不运行代码的方式下，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。（来自百度百科） 词法分析，语法分析等工作是由编译器进行的，所以对iOS项目为了完成静态分析，我们需要借助于编译器。对于OC语言的静态分析可以完全通过Clang，对于Swift的静态分析除了Clange还需要借助于SourceKit。 Swift语言对应的静态分析工具是SwiftLint，OC语言对应的静态分析工具有Infer和OCLitn。以下会是对各个静态分析工具的安装和使用做一个介绍。 SwiftLint对于Swift项目的静态分析可以使用SwiftLint。SwiftLint 是一个用于强制检查 Swift 代码风格和规定的一个工具。它的实现是 Hook 了 Clang 和 SourceKit 从而能够使用 AST 来表示源代码文件的更多精确结果。Clange我们了解了，那SourceKit是干什么用的？ SourceKit包含在Swift项目的主仓库，它是一套工具集，支持Swift的大多数源代码操作特性：源代码解析、语法突出显示、排版、自动完成、跨语言头生成等工作。 安装安装有两种方式，任选其一： 方式一：通过Homebrew 1$ brew install swiftlint 这种是全局安装，各个应用都可以使用。 方式二：通过CocoaPods 1pod 'SwiftLint', :configurations =&gt; ['Debug'] 这种方式相当于把SwiftLint作为一个三方库集成进了项目，因为它只是调试工具，所以我们应该将其指定为仅Debug环境下生效。 集成进Xcode我们需要在项目中的Build Phases，添加一个Run Script Phase。如果是通过homebrew安装的，你的脚本应该是这样的。 12345if which swiftlint &gt;/dev/null; then swiftlintelse echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"fi 如果是通过cocoapods安装的，你得脚本应该是这样的： 1\"${PODS_ROOT}/SwiftLint/swiftlint\" 运行SwiftLint键入CMD + B编译项目，在编译完后会运行我们刚才加入的脚本，之后我们就能看到项目中大片的警告信息。有时候build信息并不能填入项目代码中，我们可以在编译的log日志里查看。 定制SwiftLint规则太多了，如果我们不想执行某一规则，或者想要滤掉对Pods库的分析，我们可以对SwfitLint进行配置。 在项目根目录新建一个.swiftlint.yml文件，然后填入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253disabled_rules: # rule identifiers to exclude from running - colon - trailing_whitespace - vertical_whitespace - function_body_lengthopt_in_rules: # some rules are only opt-in - empty_count # Find all the available rules by running: # swiftlint rulesincluded: # paths to include during linting. `--path` is ignored if present. - Sourceexcluded: # paths to ignore during linting. Takes precedence over `included`. - Carthage - Pods - Source/ExcludedFolder - Source/ExcludedFile.swift - Source/*/ExcludedFile.swift # Exclude files with a wildcardanalyzer_rules: # Rules run by `swiftlint analyze` (experimental) - explicit_self# configurable rules can be customized from this configuration file# binary rules can set their severity levelforce_cast: warning # implicitlyforce_try: severity: warning # explicitly# rules that have both warning and error levels, can set just the warning level# implicitlyline_length: 110# they can set both implicitly with an arraytype_body_length: - 300 # warning - 400 # error# or they can set both explicitlyfile_length: warning: 500 error: 1200# naming rules can set warnings/errors for min_length and max_length# additionally they can set excluded namestype_name: min_length: 4 # only warning max_length: # warning and error warning: 40 error: 50 excluded: iPhone # excluded via string allowed_symbols: [\"_\"] # these are allowed in type namesidentifier_name: min_length: # only min_length error: 4 # only error excluded: # excluded via string array - id - URL - GlobalAPIKeyreporter: \"xcode\" # reporter type (xcode, json, csv, checkstyle, junit, html, emoji, sonarqube, markdown) 一条rules提示如下，其对应的rules名就是function_body_length。 1! Function Body Length Violation: Function body should span 40 lines or less excluding comments and whitespace: currently spans 43 lines (function_body_length) disabled_rules下填入我们不想遵循的规则。 excluded设置我们想跳过检查的目录，Carthage、Pod、SubModule这些一般可以过滤掉。 其他的一些像是文件长度（file_length），类型名长度（type_name），我们可以通过设置具体的数值来调节。 另外SwiftLint也支持自定义规则，我们可以根据自己的需求，定义自己的rule。 生成报告如果我们想将此次分析生成一份报告，也是可以的（该命令是通过homebrew安装的swiftlint）： 12# reporter type (xcode, json, csv, checkstyle, junit, html, emoji, sonarqube, markdown)$ swiftlint lint --reporter html &gt; swiftlint.html xcodebuildxcodebuild是xcode内置的编译命令，我们可以用它来编译打包我们的iOS项目，接下来介绍的Infer和OCLint都是基于xcodebuild的编译产物进行分析的，所以有必要简单介绍一下它。 一般编译一个项目，我们需要指定项目名，configuration，scheme，sdk等信息以下是几个简单的命令及说明。 123456# 不带pod的项目，target名为TargetName，在Debug下，指定模拟器sdk环境进行编译xcodebuild -target TargetName -configuration Debug -sdk iphonesimulator# 带pod的项目，workspace名为TargetName.xcworkspace，在Release下，scheme为TargetName，指定真机环境进行编译。不指定模拟器环境会验证证书xcodebuild -workspace WorkspaceName.xcworkspace -scheme SchemeName Release# 清楚项目的编译产物xcodebuild -workspace WorkspaceName.xcworkspace -scheme SchemeName Release clean 之后对xcodebuild命令的使用都需要将这些参数替换为自己项目的参数。 InferInfer是Facebook开发的针对C、OC、Java语言的静态分析工具，它同时支持对iOS和Android应用的分析。对于Facebook内部的应用像是 Messenger、Instagram 和其他一些应用均是有它进行静态分析的。它主要检测隐含的问题，主要包括以下几条： 资源泄露，内存泄露 变量和参数的非空检测 循环引用 过早的nil操作 暂不支持自定义规则。 安装及使用1$ brew install infer 运行infer 123$ cd projectDir# 跳过对Pods的分析$ infer run --skip-analysis-in-path Pods -- xcodebuild -workspace \"Project.xcworkspace\" -scheme \"Scheme\" -configuration Debug -sdk iphonesimulator 我们会得到一个infer-out的文件夹，里面是各种代码分析的文件，有txt，json等文件格式，当这样不方便查看，我们可以将其转成html格式： 1$ infer explore --html 点击trace，我们会看到该问题代码的上下文。 因为Infer默认是增量编译，只会分析变动的代码，如果我们想整体编译的话，需要clean一下项目： 1$ xcodebuild -workspace \"Project.xcworkspace\" -scheme \"Scheme\" -configuration Debug -sdk iphonesimulator clean 再次运行Infer去编译。 1$ infer run --skip-analysis-in-path Pods -- xcodebuild -workspace \"Project.xcworkspace\" -scheme \"Scheme\" -configuration Debug -sdk iphonesimulator Infer的大致原理Infer的静态分析主要分两个阶段： 1、捕获阶段 Infer 捕获编译命令，将文件翻译成 Infer 内部的中间语言。 这种翻译和编译类似，Infer 从编译过程获取信息，并进行翻译。这就是我们调用 Infer 时带上一个编译命令的原因了，比如: infer -- clang -c file.c, infer -- javac File.java。结果就是文件照常编译，同时被 Infer 翻译成中间语言，留作第二阶段处理。特别注意的就是，如果没有文件被编译，那么也没有任何文件会被分析。 Infer 把中间文件存储在结果文件夹中，一般来说，这个文件夹会在运行 infer 的目录下创建，命名是 infer-out/。 2、分析阶段 在分析阶段，Infer 分析 infer-out/ 下的所有文件。分析时，会单独分析每个方法和函数。 在分析一个函数的时候，如果发现错误，将会停止分析，但这不影响其他函数的继续分析。 所以你在检查问题的时候，修复输出的错误之后，需要继续运行 Infer 进行检查，知道确认所有问题都已经修复。 错误除了会显示在标准输出之外，还会输出到文件 infer-out/bug.txt 中，我们过滤这些问题，仅显示最有可能存在的。 在结果文件夹中（infer-out），同时还有一个 csv 文件 report.csv，这里包含了所有 Infer 产生的信息，包括：错误，警告和信息。 OCLintOCLint是基于Clange Tooling编写的库，它支持扩展，检测的范围比Infer要大。不光是隐藏bug，一些代码规范性的问题，例如命名和函数复杂度也均在检测范围之内。 安装OCLintOCLint一般通过Homebrew安装 12$ brew tap oclint/formulae $ brew install oclint 通过Hombrew安装的版本为0.13。 12345678910$ oclint --versionLLVM (http://llvm.org/): LLVM version 5.0.0svn-r313528 Optimized build. Default target: x86_64-apple-darwin19.0.0 Host CPU: skylakeOCLint (http://oclint.org/): OCLint version 0.13. Built Sep 18 2017 (08:58:40). 我分别用Xcode11在两个项目上运行过OCLint，一个实例项目可以正常运行，另一个复杂的项目却运行失败，报如下错误： 12341 error generated1 error generated...oclint: error: cannot open report output file ..../onlintReport.html 我并不清楚原因，如果你想试试0.13能否使用的话，直接跳到安装xcpretty。如果你也遇到了这个问题，可以回来安装oclint0.15版本。 OCLint0.15我在oclint issuse #547这里找到了这个问题和对应的解决方案。 我们需要更新oclint至0.15版本。brew上的最新版本是0.13，github上的最新版本是0.15。我下载github上的release0.15版本，但是这个包并不是编译过的，不清楚是不是官方自己搞错了，只能手动编译了。因为编译要下载llvm和clange，这两个包较大，所以我将编译过后的包直接传到了这里CodeChecker。 如果不关心编译过程，可以下载编译好的包，跳到设置环境变量那一步。 编译OCLint 1、安装CMake和Ninja这两个编译工具 1$ brew install cmake ninja 2、clone OCLint项目 1$ git clone https://github.com/oclint/oclint 3、进入oclint-scripts目录，执行make命令 1$ ./make 成功之后会出现build文件夹，里面有个oclint-release就是编译成功的oclint工具。 设置oclint工具的环境变量 设置环境变量的目的是为了我们能够快捷访问。然后我们需要配置PATH环境变量，注意OCLint_PATH的路径为你存放oclint-release的路径。将其添加到.zshrc，或者.bash_profile文件末尾: 12OCLint_PATH=/Users/zhangferry/oclint/build/oclint-releaseexport PATH=$OCLint_PATH/bin:$PATH 执行source .zshrc，刷新环境变量，然后验证oclint是否安装成功： 1234$ oclint --versionOCLint (http://oclint.org/):OCLint version 0.15.Built May 19 2020 (11:48:49). 出现这个介绍就说明我们已经完成了安装。 安装xcprettyxcpretty是一个格式化xcodebuild输出内容的脚本工具，oclint的解析依赖于它的输出。它的安装方式为： 1$ gem install xcpretty OCLint的使用在使用OCLint之前还需要一些准备工作，需要将编译项COMPILER_INDEX_STORE_ENABLE设置为NO。 将 Project 和 Targets 中 Building Settings 下的 COMPILER_INDEX_STORE_ENABLE 设置为 NO 在 podfile 中 target ‘target’ do 前面添加下面的脚本，将各个pod的编译配置也改为此选项 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['COMPILER_INDEX_STORE_ENABLE'] = \"NO\" end endend 使用方式1、进入项目根目录，运行如下脚本： 1$ xcodebuild -workspace ProjectName.xcworkspace -scheme ProjectScheme -configuration Debug -sdk iphonesimulator | xcpretty -r json-compilation-database -o compile_commands.json 会将xcodebuild编译过程中的一些信息记录成一个文件compile_commands.json，如果我们在项目根目录看到了该文件，且里面是有内容的，证明我们完成了第一步。 2、我们将这个json文件转成方便查看的html，过滤掉对Pods文件的分析，为了防止行数上限，我们加上行数的限制： 1$ oclint-json-compilation-database -e Pods -- -report-type html -o oclintReport.html -rc LONG_LINE=9999 -max-priority-1=9999 -max-priority-2=9999 -max-priority-3=9999 最终会产生一个oclintReport.html文件。 OCLint支持自定义规则，因为其本身规则已经很丰富了，自定义规则的需求应该很小，也就没有尝试。 封装脚本 OCLint跟Infer一样都是通过运行几个脚本语言进行执行的，我们可以将这几个命令封装成一个脚本文件，以OCLint为例，Infer也类似： 123456789101112131415161718192021222324252627#!/bin/bash# mark sure you had install the oclint and xcpretty# You need to replace these values with your own project configurationworkspace_name=\"WorkSpaceName.xcworkspace\"scheme_name=\"SchemeName\"# remove historyrm compile_commands.jsonrm oclint_result.xml# clean project# -sdk iphonesimulator means run simulatorxcodebuild -workspace $workspace_name -scheme $scheme_name -configuration Debug -sdk iphonesimulator clean || (echo \"command failed\"; exit 1);# export compile_commands.jsonxcodebuild -workspace $workspace_name -scheme $scheme_name -configuration Debug -sdk iphonesimulator \\| xcpretty -r json-compilation-database -o compile_commands.json \\|| (echo \"command failed\"; exit 1);# export report html# you can run `oclint -help` to see all USAGEoclint-json-compilation-database -e Pods -- -report-type html -o oclintReport.html \\-disable-rule ShortVariableName \\-rc LONG_LINE=1000 \\|| (echo \"command failed\"; exit 1);open -a \"/Applications/Safari.app\" oclintReport.html oclint-json-compilation-database命令的几个参数说明： -e 需要忽略分析的文件，这些文件的警告不会出现在报告中 -rc 需要覆盖的规则的阀值，这里可以自定义项目的阀值，默认阀值 -enable-rule 支持的规则，默认是oclint提供的都支持，可以组合-disable-rule来过滤掉一些规则 规则列表 -disable-rule 需要忽略的规则，根据项目需求设置 在Xcode中使用OCLint因为OCLint提供了xcode格式的输出样式，所以我们可以将它作为一个脚本放在Xcode中。 1、在项目的 TARGETS 下面，点击下方的 “+” ，选择 cross-platform 下面的 Aggregate。输入名字，这里命名为 OCLint 2、选中该Target，进入Build Phases，添加Run Script，写入下面脚本： 123456# Type a script or drag a script file from your workspace to insert its path.# 内置变量cd ${SRCROOT}xcodebuild clean xcodebuild | xcpretty -r json-compilation-databaseoclint-json-compilation-database -e Pods -- -report-type xcode 可以看出该脚本跟上面的脚本一样，只不过 将oclint-json-compilation-database命令的-report-type由html改为了xcode。而OCLint作为一个target本身就运行在特定的环境下，所以xcodebuild可以省去配置参数。 3、通过CMD + B我们编译一下项目，执行脚本任务，会得到能够定位到代码的warning信息： 总结以下是对这几种静态分析方案的对比，我们可以根据需求选择适合自己的静态分析方案。 SwiftLint Infer OCLint 支持语言 Swift C、C++、OC、Java C、C++、OC 易用性 简单 较简单 较简单 能否集成进Xcode 可以 不能集成进xcode 可以 自带规则丰富度 较多，包含代码规范 相对较少，主要检测潜在问题 较多，包含代码规范 规则扩展性 可以 不可以 可以 参考OCLint 实现 Code Review - 给你的代码提提质量 Using OCLint in Xcode Infer 的工作机制 LLVM &amp; Clang 入门","link":"/2020/05/22/ios_code_checker/"},{"title":"iOS开发图片格式选择","text":"图片是如何显示的在讲解如何选择图片格式之前，我感觉有必要先了解下，图片是如何展示的。如果我们要展示一张图片，一般步骤是这样的： 12345/// Assets.xcassets中的图片，不需要后缀let image = UIImage(named: \"icon\")let imageView = UIImageView(frame: rect)imageView.image = imageview.addSubview(imageView) 运行程序，我们就可以在指定位置看到这个icon。看似简单的代码背后隐藏了很多细节工作。一张图片的展示，从代码执行到展示出来大致经历了这些步骤： 1. 加载图片 从磁盘中加载一张图片； 然后将生成的 UIImage 赋值给 UIImageView ； 接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化； 分配内存缓冲区用于管理文件 IO 和解压缩操作，将文件数据从磁盘读到内存中； 2. 图片解码（解压） 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作，默认在主线程进行； 3. 图片渲染 Core Animation 中CALayer使用解压（解码）的位图数据渲染 UIImageView 的图层； CPU计算好图片的Frame，对图片解压之后，就会交给GPU来做图片渲染渲染流程； GPU获取获取图片的坐标，将坐标交给顶点着色器(顶点计算)，将图片光栅化(获取图片对应屏幕上的像素点)，片元着色器计算(计算每个像素点的最终显示的颜色值)； 从帧缓存区中渲染到屏幕上； 这其中有个关键步骤是图片解码。那为什么要解码呢，这是因为我们平常使用的图片一般为了节约空间都会经过一些压缩算法进行封装，而使用时屏幕要精确的渲染到每个像素点，这就需要把压缩的图片解码展开，便于系统处理。 名词解释有损vs无损有损压缩：指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量，并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。 无损压缩：只在压缩文件大小的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。 索引色vs直接色索引色：用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。 直接色：使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多。 点阵图vs矢量图点阵图：也叫做位图，像素图。构成点阵图的最小单位是象素，位图就是由象素阵列的排列来实现其显示效果的，每个象素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个象素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。点阵图缩放会失真，用最近非常流行的沙画来比喻最恰当不过，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒的颜色。 矢量图：也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一张矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。 几种格式的对比一张图片，如果我们将它的每一个像素及其对应的颜色都存储起来（BMP格式），是会很大的。为了减小图片占用的存储空间，派生出了各种不同压缩算法所代表的图片格式。常见的图片格式有png、jpeg、heic、gif、webp，svg等。 PNGPNG有两种类型：PNG-8和PNG-24。 PNG-8是无损的、索引色、点阵图。它支持透明度的调节。 PNG-24是无损的、直接色、点阵图。因为使用直接色，颜色范围更大，也占用更大的空间。他的目标是替代JPEG，但一般而言，PNG-24的文件大小是JPEG的五倍之多，而显示效果则通常只能获得一点点提升。所以如果不是对图片质量要求特别高，不建议使用PNG-24 PNG是苹果推荐的图片格式，而且这些图片会被一个叫pngcrush的开源工具优化，这样iOS设备就能在显示时更快的解压和渲染图片。该工具位于目录： 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin JPEGJPEG是有损的、采用直接色的、点阵图压缩方式。JEPG目标是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。一般都是用于相机图片的格式。但因为有损，会导致图片失真。iOS可以通过以下方式压缩图片： 12// 压缩比范围从0到1func jpegData(compressionQuality: CGFloat) -&gt; Data? 题外话一般来说，相同的图片采用JPEG的压缩方式会比png得到更小的尺寸，但也有例外。 在网上查了资料说是JEPG更适合处理带有很多杂色的风景图，而对于使用数位板等电子绘制的纯色卡通系风格图片，JEPG的压缩方式会适得其反，导致体积更大。 HEICHEIC是HEIF（High Efficiency Image Format 高效率图像文件格式）的一种。它并非苹果开发，而是由运动图像专家组（MPEG）开发。它同时支持有损压缩、无损压缩、透明度等特性。HEIF规范的完成是在2015年，是这几种图片格式中最新的一种了，目前除了苹果，还没有哪家大厂去拥抱这种格式。 在iOS 11更新后，iPhone 7及其后硬件，在拍摄照片时的默认图像存储格式。与JPG相比，它占用的空间更小，画质更加无损。HEIC的目的就是作为JPEG的继任者，以后或许会成为一种趋势。目前可以想到的在开发中的应用是，对于一些需要下载的大图可以转成HEIC格式，供客户端使用。但是当前却很少应用，大概率是考虑到图片兼容问题吧。 题外话 一个有趣的现象，我用相机（iPhoneXR）拍摄一张照片，通过AirDrop传到电脑，显示为HEIC格式。当我在拍照时选择系统自带的任意一种滤镜，图片格式就变成了JPEG。这是为什么？ 有小伙伴解答： iOS拍照选择滤镜会“转”为JPEG，是因为拍照的格式还是HEIF，加滤镜和编辑图片都是相当于复制了一份再做操作的，点击复原又会“转”为HEIF。 经过测试确实是这样的，而且既然苹果提供复原的操作，说明原图（HEIF）并没有被覆盖。那为什么滤镜不能直接在HEIF格式下操作，猜测可能是跟滤镜的算法相关，该算法只能对JEPG格式编码的图片进行渲染，所以需要中间转成JEPG。 Live Photo Live图片的实质是：一张heic格式封面图 + mov格式视频。 对于Live Photo的展示，在原生应用中可以使用PHLivePhotoView，在Web应用中可以使用LivePhotosKit JS。 WebPWebP最初由Google发布于2010年，图片格式派生自VP8视频编码，也同时支持有损压缩、无损压缩、透明度等特性。2013年低，推出了Animated WebP，还可以支持动图。 WebP 集合了多种图片文件格式的特点。它像 JPEG 一样适合压缩照片和其他细节丰富的图片，像 GIF 一样可以显示动态图片，像 PNG 一样支持透明图像。根据 Google 的测试，WebP 无损压缩图片比 PNG 图片少了 45％ 的文件体积，即使这些 PNG 图片在使用 pngcrush 和 PNGOUT 处理后，WebP 依旧可以减少 28％ 的文件体积。可以在点击这里查看WebP对其它格式转换的效果。 小是WebP的最大优点，小意味着更少的流量，这也是各大流量入口在意的地方。目前Google、Facebook、阿里等大厂已经在广泛使用WebP格式，国内的一些图床服务（七牛、又拍云）也支持将图片自动转成WebP格式。 诚然WebP非常优秀，独自完成了图片格式”大一统”的任务。但苹果对WebP的支持却很少，只Safari目前还不支持WebP显示就阻断了很多人应用WebP的决心。 如果我们需要在项目中显示WebP格式图片就不得不导入Google的libwebp解码库。当然WebP的解码任务在iOS端有些库已经封装好了，OC端可以用SDWebImageWebPCoder，Swift端可以用KingfisherWebP。以下是使用Kingfisher展示WebP图像的事例： 1234567891011121314151617181920// 全局配置对WebP图片的解码（仅针对WebP格式）KingfisherManager.shared.defaultOptions += [ .processor(WebPProcessor.default), .cacheSerializer(WebPSerializer.default)]// 本地webp图片解码let localUrl = Bundle.main.url(forResource: \"sunset\", withExtension: \"webp\")let dataProvider = LocalFileImageDataProvider.init(fileURL: localUrl!)imageView.kf.setImage(with: dataProvider)// 远程webp图片解码。一些图像服务器可能期望“Accept”标头包含“image/webp”，我们还需要加上let modifier = AnyModifier { request in var req = request req.addValue(\"image/webp */*\", forHTTPHeaderField: \"Accept\") return req}KingfisherManager.shared.defaultOptions += [ .requestModifier(modifier), // ... other options] PDFpdf图片通常是矢量的，它的导入方式有些特殊。我们需要在Assets.xcassets文件，创建一个New Image Set，然后将该文件的Scales设置为Single Scale，拖入1x尺寸的pdf文件即可： 使用时我们可以把它当做普通图片对待： 1let image = UIImage(named: \"sunset\") 在运行期间Xcode会根据屏幕的比例因子生成对应尺寸的png图像。比如导入一张100x100的pdf图片，在2x和3x的机型里面会生成对应的200x200，300x300的png（可以在Assets.car中找到）。所以pdf只不过是Xcode处理图片的中间状态，下载到手机的应用包里面是没有这张pdf的。 这种处理方式有一个好处就是，当苹果以后发布一款4x屏幕的手机时，使用pdf处理的图片会自适应生成对应的4x资源，不需要再手动导入。但相比优点，pdf作为图片资源的缺点更多。 首先是尺寸上，因为是自动生成对应的png，并没有任何优化和压缩，而且我们也并不能在这中间做什么。对比相同尺寸经过ImageOptim压缩过的png，在大小上后者会是前者的1/2，甚至1/4。 另外pdf对阴影和渐变的处理会存在失真的情况： 左边是png，右边是pdf。在一些渐变和光影的图像部分可以看出明显的失真。 更多关于pdf和png的差别，可以看这篇：Why I don’t use PDFs for iOS assets: https://bjango.com/articles/idontusepdfs/ SVG/SF SymbolSVG是一种无损的矢量图，是众多矢量图中的一种，它的特点是使用XML来描述图片。使用XML的优点是，任何时候你都可以把它当做一个文本文件来对待，也就是说，你可以非常方便的修改SVG图片，你所需要的只需要一个文本编辑器。 在iOS13之前应用中直接使用SVG的场景非常少，但从iOS13开始，苹果推出了SF Symbol，一种svg格式的矢量符号集。而且苹果还提供了多于1500多种icon模板，我们可以在这里下载查看。 我们可以从中选择适合自己的icon，选中之后，从File &gt; Export Custom Symbol Templete中导出svg格式图片集，然后拖到Xcode的Assets.xcassets。 SF Symbol有9种粗细的调节——从ultralight到black——每一种都相当于San Francisco系统字体的重量（weight）。(SF Symbol中的SF是San Francisco（旧金山）的缩写)。这种对应使您能够在符号和相邻文本之间实现精确的权重匹配，同时支持不同大小和上下文的灵活性。 当然如果这些图标都不能满足需求，我们还可以自定义SF图标，然后通过SF Symbol App进行验证和导出。操作细节可以看这里：Creating Custom Symbol Images for Your App。 SF Symbol使用起来也很简单： 12let configuration = UIImage.SymbolConfiguration.init(scale: .small)imageView.image = UIImage(systemName: \"alarm\", withConfiguration: configuration) SF Symbol可以一次性解决相同icon，不同尺寸，不同粗细的问题，它让我们处理图片像处理字体一样方便。可以想象这就是应用图标的未来。 当看到SF Symbol仅支持iOS13+，watchOS6+，我又不得不退回到现实，png也挺好的。 题外话 我在测试SF Symbol图标时，从生成的应用包中查看图片，会得到这样的结果： 代码中的我将图片设置为100x100，仅有这一处地方使用。跟pdf类似我们找不到svg源文件，这好理解，svg只是中间状态，我们最终使用的还是png，但为什么会有多个小尺寸的png图像呢？ 如何选择图片格式我们平常开发时，使用最多的就是png了，甚至可能是不加考虑的全部使用png。其实这样是不好的，我们应该充分发挥不同格式图片的优点，从兼容性、空间占用、展示效果三方面考量选取最佳格式。 关于图片格式的选择，苹果的Human Interface Guidelines有以下说法： 一般情况下，使用PNG图片，因为PNG支持透明性，而且是无损的，压缩工件不会模糊重要的细节或改变颜色。对于需要阴影、纹理和高光效果的复杂艺术品来说，这是一个不错的选择。使用8位的PNG图形，不需要完全24位的颜色。8位PNG可以在不降低图像质量的情况下减小文件大小。精致的应用图标最好使用png。 对于照片应该使用JPEG格式，它的压缩算法通常比无损格式产生更小的尺寸，而且很难在照片中辨别出来。应该尝试优化JPEG文件，在大小和质量之间找到平衡。大多数JPEG文件可以被压缩而不会导致图像明显的退化。即使是少量的压缩也可以节省大量的磁盘空间。 使用PDF处理字形和其他需要高分辨率缩放的平面矢量图形。 最终可以做以下总结。 图片格式 适用范围 注意事项 png 应用icon，界面icon，卡通风格的背景图 导入项目前可以使用ImageOptim进行压缩 jpeg 尺寸较大的风景图，照片 不支持透明度；因为可以调节压缩比，可以在大小和质量之间寻找最佳平衡。 webp 支持有损、无损压缩、透明度、动图等特性，因为苹果本身不支持一般只应用于服务端返回来的图片 无法在xcode预览，不建议内置该类型图片 pdf 字形，高分辨率的矢量图 存在展开尺寸较大，光效失真的情况 svg（sf symbol） 指示性icon 仅支持iOS13及以上，系统sf符号是有版权的，使用时要注意应用范围和苹果要求 引用谈谈 iOS 中图片的解压缩 图片格式那么多，哪种更适合你 iOS图片格式选择 Why I don’t use PDFs for iOS assets SF Symbols: The benefits and how to use them guide WebP 的前世今生","link":"/2020/04/05/ios_photo_format_compare/"},{"title":"【译】iOS 架构模式--浅析MVC, MVP, MVVM 和 VIPER","text":"作者：Bohdan Orlov原文地址：https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52 在iOS开发过程中你是否对MVC的使用感觉很别扭？你是否对转向MVVM有疑惑？你听说过VIPER，但不清楚这个东西是否值得一试。 接着读下去，你会找到上面这些问题的答案。如果读完仍不能解惑，欢迎到评论区捶我。 接下来你将在iOS环境下构建关于架构模式的知识体系。我们将简要构建一些经典的例子，并在理论和实践上进行比较他们的不同。如果你需要更多关于任何一个特定的细节，请关注我。 掌握设计模式容易让人上瘾，所以要注意：阅读本文之前要问自己几个问题： 谁应该持有网络请求：Model还是Controller? 如何在一个新的View中向ViewModel传递Model 谁创建了一个新的VIPER模块：Router还是Presenter 为什么应该关心选用何种架构因为如果你不这么做的话，总有一天，等这个类庞大到同时处理十几种事务，你会发现你根本无法从中找到对应代码并修改bug。当然，将这整个类了然于心是很难的，你会常常忘记一些重要的细节。如果你的程序已经处于这种状态了，那它很可能具有下面这些特征： 这个类是UIViewController的子类 你的数据直接在UIViewController中进行存储 你的UIView基本什么都没做 你的Model只是一个单纯的数据结构 你的单元测试没有覆盖任何代码 即使你认为自己遵守了苹果的指导，并按照苹果推荐的MVC设计规范进行开发，但还是遇到了这些问题。不要担心，这是因为苹果的MVC本身就存在一些问题，我们稍后会再来讨论它。 让我们定义一下好的架构应该具备的特点：1、平衡的分配实体和具体角色的职责2、把可测试性放在第一位（通过合适的架构，这将很容易实现）3、易用性和低维护成本 为什么要分配职责职责的分配能让我们在尝试搞清楚事情如何运作这一过程中保持一个正常的负荷。你可能会认为你投入的精力越多你的大脑越能适应更加复杂的东西，这没错。但是这个能力是非线性的，而且会很快达到临界点。所以降低复杂性的最好的方式是，根据职责单一原则将它的功能（职责）分配到多个实体中。 为什么要可测试性对于那些已经添加了单元测试的项目来说，当他们增加一个新的功能或者重构一个复杂的类时会由单元测试告知失败与否，这多让人很放心啊。同时这也意味着这些测试项将在运行时帮助开发者找到问题，而如果这些问题发生在用户设备上的，解决他们通常会花费一周。 为什么要易用性这并不需要答案，但值得一提的是，最好的代码是那些从未写过的代码。所以，代码越少，bug就越少。这意味着，编写更少代码的愿望不应该仅仅由开发人员的懒惰来解释，而且你不应该为了采用更好的解决方案，而对其维护成本视而不见。 MV(X)的要素如今我们又很多可选的架构方案： MVC MVP MVVM VIPER前三项方案是把应用程序的实体分为三类： Modes – 负责数据域和操作数据的数据访问层，例如’Person’类, ‘PersonDataProvider‘类。 Views – 负责展示层（GUI），对于iOS环境就是指所有已‘UI’开头的类。 Controller/Presenter/ViewModel – 是Model和View的中介，通常的职责是通过响应用户在View的操作改变Model，然后根据Model的变化更新View。 这些实体的分割帮助我们： 更好的理解他们 重用他们（通常是View和Model） 单独测试他们 让我们开始讲解MV(X)模式，随后是VIPER MVC它原本是什么样的在讨论苹果的MVC版本之前，让我们看一下传统的MVC模式： 这个模式下，View是无状态的。它只是简单的被Controller渲染当Model变化的时候。想一下Web页面，当你点一个链接尝试跳转时，整个页面都会重新渲染。尽管可以在iOS应用程序中实现传统的MVC，但由于架构问题，这并没有多大意义—— 所有三个实体都是紧密耦合的，每个实体都知道其他两个。这正好降低了他们的重用性，而这又是你在程序中不想看到的。因为这个原因，我们将跳过编写传统MVC代码的示例。 传统的MVC似乎不适合现代的iOS开发 苹果的MVC预期效果Controller是View和Model的中介，因此它俩互相不知道对方。可重用性最差的就是Controller，因为我们必须为复杂的业务逻辑提供一个位置，Model又不适合。 理论上，这看起来很简单，但是你总感觉有什么地方不对，是吧？你甚至听到人们解读MVC为Massive View Controller。也因此，视图控制器的简化成了iOS开发一个重要的课题。苹果只是采用传统的MVC并对其进行一些改进，为什么会出现这种情况呢? 现实情况 Cocoa MVC鼓励你编写大量的视图控制器，因为它们是视图生命周期的一部分，很难说它们是独立的。尽管你有能力转移一些业务逻辑和数据转换工作到Model中，当需要转移工作到View时你仍然没有太多选择，因为大多数情况View的职责就是发送行为到Controller。视图控制器最终将成为一个所有东西的委托、数据源、负责调度和取消网络请求，等等。 这种代码，你肯定见过很多少次了： 12var userCell = tableView.dequeueReusableCellWithIdentifier(\"identifier\") as UserCelluserCell.configureWithUser(user) 这个cell是View，直接通过Model进行配置，这明显违反了MVC的要求，但这种事情却经常发生，而且认为还不认为这是错的。如果你严格按照MVC的 做法，你应该在Controller里面配置cell，而不是将Model直接传递给View，但这样就会增加Controller的大小。 Cocoa MVC 被称为 Massive View Controller是多么合理啊。 这个问题还不是那么明显，直到提到单元测试（希望它存在于你的项目）。因为你的视图控制器跟View是紧耦合的，这将使得测试非常困难。所以你应该让你的业务逻辑和视图布局代码尽可能分割开来。 让我们看一个简单的例子： 123456789101112131415161718192021222324252627import UIKitstruct Person { // Model let firstName: String let lastName: String}class GreetingViewController : UIViewController { // View + Controller var person: Person! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self, action: \"didTapButton:\", forControlEvents: .TouchUpInside) } func didTapButton(button: UIButton) { let greeting = \"Hello\" + \" \" + self.person.firstName + \" \" + self.person.lastName self.greetingLabel.text = greeting } // layout code goes here}// Assembling of MVClet model = Person(firstName: \"David\", lastName: \"Blaine\")let view = GreetingViewController() 这样根本没法测试，对吧？我们可以把greeting的赋值移到一个新的类GreetingModel中，然后分开测试它。但是我们无法在不直接调用UIView相关方法（viewDidLoad, didTapButton）的情况下测试任何外在的逻辑，而如果这样做，这些方法就导致所有view的刷新，所以这本身就是一个不好的单元测试。 事实上，在一个模拟器上加载和测试UIViews表现正常，不代表它在别的设备依然这样。所以我建议测试时移除单元测试对“宿主程序”的依赖，而直接测试代码。 View和Controller之间的交互行为无法通过Unit Tests进行。 根据上面的说法，Cocoa MVC是一个相当不好的架构方案。让我们再来根据文章开头定义的好架构应有的特性来评价下它： 职责分离 – View和Model是分离的，但View和Controller是紧耦合关系。 可测试性 – 由于不好的职责分离特性，只有Model层是可以测试的。 易用性 – 这几种架构模式中它的代码量是最少的。每个人都很熟悉这种模式，即使是一个经验有限的开发者也可以很容易的维护这份代码。 如果你不打算投入很多事情在架构上，或者你感觉对于你们的小项目来说不值得投入过多维护成本，那你应该选择Cocoa MVC。 Cocoa MVC 是开发速度最快的一种架构。 MVP 这是不是更苹果的MVC非常像？确实是这样的，它的名字叫做MVP。等一下，这是不是意味着苹果的MVC事实上就是MVP？不。你可以再观察下这个结构，View和Controller是紧耦合关系，作为MVP的中介者 – Presenter并没有管理视图控制器的生命周期，它里面也不含有布局代码，它的职责是根据数据的状态变化更新View，所以呢，View这一层就可以很简单的抽出来。 我会告诉你，UIViewController也是View 在MVP模式下，UIViewController的子类实际上是Views而不是Presenters。这种区别提供了极好的可测试性，但这是以开发速度为代价的，因为你必须手动绑定数据和时间，就像这个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import UIKitstruct Person { // Model let firstName: String let lastName: String}protocol GreetingView: class { func setGreeting(greeting: String)}protocol GreetingViewPresenter { init(view: GreetingView, person: Person) func showGreeting()}class GreetingPresenter : GreetingViewPresenter { unowned let view: GreetingView let person: Person required init(view: GreetingView, person: Person) { self.view = view self.person = person } func showGreeting() { let greeting = \"Hello\" + \" \" + self.person.firstName + \" \" + self.person.lastName self.view.setGreeting(greeting) }}class GreetingViewController : UIViewController, GreetingView { var presenter: GreetingViewPresenter! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self, action: \"didTapButton:\", forControlEvents: .TouchUpInside) } func didTapButton(button: UIButton) { self.presenter.showGreeting() } func setGreeting(greeting: String) { self.greetingLabel.text = greeting } // layout code goes here} 关于装配（assembly）的重要说明MVP是第一个揭露三层模型装配问题的模式。我们不想让View和Model互通，因为在试图控制器（View）中执行装配操作是明显不对的，所以我们只能换个地方放装配的代码。例如，我们可以做一个应用范围的Router服务，它负责装配工作和View到View的展示。这个问题的出现不仅要在MVP中解决，在以下的几个模式中也都要解决。 我们看下MVP的特性： 职责分离 – 我们将大部分职责分配给了Presenter和Model，而视图则什么都不需要做（上面的Model也是什么都不用做） 可测试性 – 非常好，我们可以通过静态的View测试大多数逻辑。 易用性 – 在我们上个简单示例中，代码量是MVC的两倍，但是它的逻辑是很清晰的。 在iOS中MVP模式意味着良好的可测试性和大量代码。 MVP这是另一个MVP的样式 – 由视同控制器担当管理的MVP。这个变体中，View和Model是直接绑定的，Presenter(担当管理的控制器)仍然处理着来自View的操作，并且能够改变View。 但是通过上面的学习我们已经知道了，将View和Model紧耦合处理，这种不明确的职责分离是很糟糕的。这与Cocoa桌面开发中的工作原理类似。 跟传统MVC一样，我找不到要为这个有缺陷的架构写示例的理由。 MVVM最新而且是最好的一个MV(X)类型MVVM是最新的MV(X)类型，希望它能解决我们之前讨论过的问题。 MVVM理论上看起来是很好的，View和Model我们已经很熟悉了，它俩之间的中介者由View Model表示。 这和MVP很像： MVVM也是把视图控制器当做View 在View和Model之间没有紧耦合关系 此外它的绑定逻辑很像MVP的监管版本；但是这次不是View和Model，而是View和View Model之间的绑定。 所以iOS当中的View Model到底是什么呢？它是UIKit独立于视图及其状态的表示。View Model调用Model执行更改，然后根据Model的更新再更新自己，因为我们绑定了View和View Model，第一个模型将相应的更新。 绑定我在MVP部分明确提到过绑定，这次让我们再来讨论一下。绑定出自于MacOS开发，在iOS中是没有的。我们虽然可以通过KVO和通知完成这一过程，但是这样的绑定方式并不方便。 如果我们不想自己实现的话，有两个选项可供参考： 一个是基于KVO的绑定库像RZDataBinding,SwiftBond 完整的函数式编程工具，像ReactiveCocoa, RxSwift, PromiseKit。 如今当你听到“MVVM”，就应该想到ReactiveCocoa。因为它可以让你用很简单的绑定方式构建MVVM，几乎涵盖所有MVVM中的逻辑。 但是使用响应式框架会面临一个不好的现实：能力越大责任越大。使用reactive很容易将事情复杂化。也就是说，如果发生了一处错误，你需要花费很多时间去调试问题，可以简单看下响应式的调用堆栈。 在我们的示例中，响应式框架甚至KVO都是多余的，我们将使用showGreeting方法显式地要求View Model更新，并使用greetingDidChange回调函数的简单属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import UIKitstruct Person { // Model let firstName: String let lastName: String}protocol GreetingViewModelProtocol: class { var greeting: String? { get } var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? { get set } // function to call when greeting did change init(person: Person) func showGreeting()}class GreetingViewModel : GreetingViewModelProtocol { let person: Person var greeting: String? { didSet { self.greetingDidChange?(self) } } var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? required init(person: Person) { self.person = person } func showGreeting() { self.greeting = \"Hello\" + \" \" + self.person.firstName + \" \" + self.person.lastName }}class GreetingViewController : UIViewController { var viewModel: GreetingViewModelProtocol! { didSet { self.viewModel.greetingDidChange = { [unowned self] viewModel in self.greetingLabel.text = viewModel.greeting } } } let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self.viewModel, action: \"showGreeting\", forControlEvents: .TouchUpInside) } // layout code goes here}// Assembling of MVVM 再次回来用这三个特征验证一下： 职责分离 – 这在我们的小示例还无法体现，但是MVVM的View比着MVP的View有着更多的职责。因为前者通过View Model建立绑定更新它的状态，后者仅仅是把所有事件都交给Presenter，不更新自己。 可测试性 – View Model是不知道View的，这可以让我们很容易的对它进行测试。View可能也需要测试，但因为它依赖UIKit，你可能想跳过它。 易用性 – 它有河MVP模式相同的代码量，但是实际项目中，你不得不把所有事件通过View传给Presenter，然后还要手动更新View，比较而言，MVVM使用绑定将更加简洁。 MVVM是很有吸引力的，因为它包含了前面提到的优点，此外通过View层的绑定，也不需要额外的代码处理View更新。测试性也还不错。 VIPER把乐高的搭建流程应用到iOS设计模式VIPER是我们最后一个候选模式，有趣的一点是它不属于MV(X)类型。 目前为止，你必须同意职责的粒度是很重要的。VIPER在划分职责层面又做了一次迭代，它将项目划分成5层。 Interactor– 包含跟数据（Entities）和网络相关的业务逻辑，像是创建新的实例对象后者从服务器拉取数据。出于这些目的，你也可以使用Services和Mananger类完成功能，但这就不属于VIPER模块，而是外部依赖类。 Presenter – 包含UI相关的业务逻辑，调用Interactor中的方法。 Entities – 普通的数据对象，不是数据访问层，因为这是Interactor的责任。 Router – 负责VIPER模块之间的切换。 基本上，VIPER模块可以是一整屏内容，也可以是你应用中完整的用户行为 – 想一下授权行为，它可以在一个或者几个相关联的界面。“乐高”方块应该多小呢？这取决于你。 如果我们将它和MV(X)类比，会发现一些在职责划分上的区别： Model(数据交互)逻辑转移到了包含Entities数据结构的Interactor中。 只有Controller/Presenter/ViewModel这种UI表示层的职责转移到了Presenter中，不包含数据。 VIPER是第一个明确导航职责的模式，并通过Router解决这个问题。 在iOS应用中用一个优雅的方式处理跳转问题确实是一个挑战，MV(X)模式没有处理这个问题。 该示例不涉及模块之间的路由或交互，因为MV(X)模式根本不涉及这些主题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import UIKitstruct Person { // Entity (usually more complex e.g. NSManagedObject) let firstName: String let lastName: String}struct GreetingData { // Transport data structure (not Entity) let greeting: String let subject: String}protocol GreetingProvider { func provideGreetingData()}protocol GreetingOutput: class { func receiveGreetingData(greetingData: GreetingData)}class GreetingInteractor : GreetingProvider { weak var output: GreetingOutput! func provideGreetingData() { let person = Person(firstName: \"David\", lastName: \"Blaine\") // usually comes from data access layer let subject = person.firstName + \" \" + person.lastName let greeting = GreetingData(greeting: \"Hello\", subject: subject) self.output.receiveGreetingData(greeting) }}protocol GreetingViewEventHandler { func didTapShowGreetingButton()}protocol GreetingView: class { func setGreeting(greeting: String)}class GreetingPresenter : GreetingOutput, GreetingViewEventHandler { weak var view: GreetingView! var greetingProvider: GreetingProvider! func didTapShowGreetingButton() { self.greetingProvider.provideGreetingData() } func receiveGreetingData(greetingData: GreetingData) { let greeting = greetingData.greeting + \" \" + greetingData.subject self.view.setGreeting(greeting) }}class GreetingViewController : UIViewController, GreetingView { var eventHandler: GreetingViewEventHandler! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self, action: \"didTapButton:\", forControlEvents: .TouchUpInside) } func didTapButton(button: UIButton) { self.eventHandler.didTapShowGreetingButton() } func setGreeting(greeting: String) { self.greetingLabel.text = greeting } // layout code goes here}// Assembling of VIPER module, without Routerlet view = GreetingViewController()let presenter = GreetingPresenter()let interactor = GreetingInteractor()view.eventHandler = presenterpresenter.view = viewpresenter.greetingProvider = interactor 让我们再一次对比那几个特征： 职责分离 – 毫无疑问，VIPER是职责分离做的最好的。 可测试性 – 职责分离越好，可测试性当然也会更好 易用性 – 你可能已经猜到了，上面两项意味着维护成本的提升。你必须写很多处理各个类之间交互的代码。 所有这个乐高模式到底怎么样呢？当使用VIPER时，如果你感觉就像是通过乐高方块搭建帝国大厦，这就意味着出现了问题。不应该过早在你的应用中使用VIPER，你需要考虑简便性。有些人不注意简便性，直接使用VIPER，会有点大材小用。我猜测很多人是这么想的，他们的应用迟早都会发展到适用VIPER的复杂程度，所以早晚都会做的事，即使现在维护成本高也应该继续做下去。如果你就是这么想的，我推荐你试一下Generamba – 一个生成VIPER组件的工具。虽然对我个人来说，这感觉就像使用自动瞄准系统而不是简单的弹射。 总结我们已经讲解了几个架构模式，希望你能解答曾经困扰你的问题。我敢肯定你也意识到了架构模式的选择没有最好这一说，它取决于你在特定环境下权衡利弊之后做的选择。 所以，在一个应用中出现混合一种混合的架构模式也是很常见的。例如，你一开始使用MVC，然后你发现有一个界面的逻辑变得很复杂，然后你转向了MVVM，但也是仅限于这个界面。你不必重构别的使用MVC的界面，因为它原本就是工作的好好的，而且这两个架构模式是很容易兼容的。 事情应该力求简单，不过不能过于简单 – 阿尔伯特·爱因斯坦","link":"/2019/11/22/ios_architecture_patterns/"},{"title":"iOS国际化及本地化（一）不同语言的差异处理及测试","text":"国际化及本地化概念将标题取名为国际化及本地化（internationalization and localization），是因为这两个概念是有差异的，而这个差异常常被我们忽略，以下是维基百科的解释： 国际化是指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。本地化则是指当移植软件时，加上与特定区域设置有关的信息和翻译文件的过程。 国际化和本地化之间的区别虽然微妙，但却很重要。国际化意味着产品有适用于任何地方的“潜力”；本地化则是为了更适合于“特定”地方的使用，而另外增添的特色。用一项产品来说，国际化只需做一次，但本地化则要针对不同的区域各做一次。这两者之间是互补的，并且两者合起来才能让一个系统适用于各地。 有些时候我们也会用国际化或者全球化代替这两者含义。 作为一款优秀的产品我们做多语言版本时不应仅仅考虑到翻译这一层面，还有更多本地化相关内容需要我们注意，这篇文章主要涉及的也是本地化这一块。 国际化工作流程 本篇文章主要介绍Internationalize和Test这两步。 本文目录为： 1.增加多语言 2.UI元素的本地化 3.资源文件本地化 4.字符串相关的本地化 5.使用NSLocal进行本地化 6.从右到左语言的处理 7.本地化测试 增加多语言1、在项目导航栏选择项目（不是target） 2、在Localizations一栏，点击“+”号，添加语言每个条目都是由语言名称和语言id构成，例如Chinese(Simplified)(zh-Hans), Japanese(ja)至此我们的项目就开启了对应语言的本地化支持。 3、在对话框中选中你想本地化的文件。 语言和区域的影响通过观察系统日历，我们可以看到即使语言一样，国家区域的不一致也会有一些约定上的区别，关于日期和时间的本地化会在下面介绍。 1、语言设置：Setting -&gt; General -&gt; Language &amp; Region同样的，关于Region和Calendar的设置也在该页面。 资源文件的本地化storyboard, xib文件对于sotryboard和xib文件的本地化是Xcode直接支持的。在添加语言时会提示我们自动选择创建本地化文件，如果是在添加语言之后创建的IB文件，可以通过xcode右侧属性栏中点击Localize...生成本地化文件。 图片文件1、方法一对于图片内容我们可以通过同IB文件的方式进行本地化，但是有一个限制就是图片要是放到项目文件层级的，而不能放到Assets文件夹中。好消息是Xcode 11将放开这种限制，对于Assets引入的图片也可以做本地化处理。 2、方法二除了Xcode本身支持的方式，我们还可以通过命名来区分图片内容，把图片名当做需要本地化的字符串，各个语言对应不同版本的图片名，这样也可以实现图片文件的本地化。 音视频及其他资源文件如果是内置的像是音视频，json或者其他类型的配置文件这类内容，可以使用图片文件的方法二进行引入。 更多详细的设置可以参考这个文章：iOS语言国际化/本地化-实践总结 UI元素的本地化使用Auto layoutAuto layout是相对布局，它有能力在语言和区域变化时进行自适应。以下有几点使用auto layout的技巧： 1、移除宽度的约束相同含义下不同语言宽度往往不一样，应该让控件能够自适应。 2、使用内容内部大小fields和label默认是自动调整大小的，如果一个显示本地化内容的视图需要这个功能，选择该view，选择Editor &gt; Size To Fit Content 3、使用leading和trailing属性正常leading和trailing对应left和right，他们含义相同。但是有些国家，像是希伯来和阿拉伯的人使用习惯是从右往左。如果你是使用leading和trailing，在该环境下将自动对应right和left。 4、将视图固定到相邻视图就是定义相邻约束，避免某一视图变化导致重叠。 使用伪本地化发现问题这个功能只支持使用storyboard和xib进行布局的UI。1、选中需要测试的.storyboard或者.xib文件2、选择菜单栏 View &gt; Assistant Editor &gt; Show Assistant Editor 字符串相关的本地化使用Unicode字符串对于所有面向用户的字符串都要使用NSString, NSAttributedString，对于Swift就是String, AttributedString，因为他们支持Unicode，Unicode是世界上所有书写系统的字符编码标准。 对于一些特殊的字符串需求：1、访问字符串中的字符使用NSString中的rangeOfComposedCharacterSequenceAtIndex:和 rangeOfComposedCharacterSequencesForRange:方法，他们会确保你在取字符串时不会破坏原文本。看一个例子你可能会明白： 这两个文字无论是在UTF-16还是UTF-32编码的情况下都是不同的长度，所以我们不能通过长度而要通过以上的两种方式取目标字符串。 2、遍历字符串 如果我们要遍历展示下面的字符串：可以通过enumerateSubstringsInRange:options:usingBlock:方法，其中options参数如果传递NSStringEnumerationByComposedCharacterSequences将会按照最小字符进行遍历，如果选用NSStringEnumerationByWords将会按照词语进行遍历。以上例子使用该值遍历的结果是： 更多关于字符串相关的本地化问题可以参照该条视频：WWDC 2013 Making Your App World-Ready 3、关于人名，邮寄地址，电话号码的检测因为不同国家对于人名和电话号码的规则差别较大，我们可以针对不同国家写正则进行检测，也可以使用苹果提供的一个特殊含义字符的检测类：NSDataDetector 支持检测的类型包括日期，地址，链接，手机号，交通信息。 获取当前语言将语言设置为English(United Kingdom)，区域设置成United States，通过以下API获取到： 12//enNSString *languageID = [[NSBundle mainBundle] preferredLocalizations].firstObject; 一般获取语言所用的方式是通过Bundle也就是第一种方式。 使用NSLocal进行本地化NSLocale对象封装关于特定区域格式化标准的信息，包括日期，时间，测量，数字，货币等一系列内容。 将语言设置为English(United Kingdom)，区域设置成United States，通过以下API获取到： 1234//en-GB_US[NSLocale currentLocale].localeIdentifier;//en[NSLocale currentLocale].languageCode; 其中languageCode跟通过Bundle获取到的是一样的。 其中localIdentifier表示为en-GB_US，对应为：语言id-国家id_区域码，这几个内容都可以通过NSLocal对象取到。 获取特定语言的引号因为每种语言对于引号的使用是不一样的，我们可以通过NSLocal获取到引号 123456789//1.Get the language that the app is using.NSString *languageID = [[NSBundle mainBundle] preferredLocalizations].firstObject;//2.Get the associated locale object.NSLocale *locale = [NSLocale localeWithLocaleIdentifier:languageID];//3.Get the beginning and ending symbols for quotes from the locale object.bQuote = [locale objectForKey:NSLocaleQuotationBeginDelimiterKey];eQuote = [locale objectForKey:NSLocaleQuotationEndDelimiterKey];//4.Format a string using the locale-sensitive quotes.quotedString = [NSString stringWithFormat:@\"%@%@%@\", bQuote, myText, eQuote]; 以下展示了不同区域对于myText为@&quot;iPhone&quot;时的字符串效果。 字符串的本地化1、创建格式化字符串应该使用localizedStringWithFormat:而不是stringWithFormat:。 1NSString *localizedString = [NSString localizedStringWithFormat:@\"%3.2f\", myNumber]; 此方法会根据系统Local进行显示。 日期时间本地化2、日期和时间转字符串使用NSDateFormatter表示NSDate对象。推荐使用这个方法：localizedStringFromDate:dateStyle:timeStyle:。 12//14 Aug 2019 at 11:19NSString *localizedDateTime = [NSDateFormatter localizedStringFromDate:[NSDate date] dateStyle:NSDateFormatterMediumStyle timeStyle:NSDateFormatterShortStyle]; 下表展示了语言为英语，区域是美国时的日期和时间格式：下表展示了dateStyle为NSDateFormatterMediumStyle，timeStyle为NSDateFormatterShortStyle在不同语言和地区时的表现形式： 3、使用自定义日期和时间格式 12345678//1.Create an NSDateFormatter object.NSDateFormatter *dateFormatter = [NSDateFormatter new];//2.get a localized format string from a template that you provide.NSString *localeFormatString = [NSDateFormatter dateFormatFromTemplate:@\"MMM d\" options:0 locale:dateFormatter.locale];//3.Set the format of the NSDateFormatter instance to the locale-sensitive format string.dateFormatter.dateFormat = localeFormatString;//4.Use the stringFromDate: method to get a localized string representation of the date.NSString *localizedString = [dateFormatter stringFromDate:[NSDate date]]; 在不同语言和区域下localizedString对应的内容为： 3、解析日期字符串 12345678910//1.Create a date formatter object.NSDateFormatter *dateFormatter = [NSDateFormatter new];//2.Set the formatter’s style to a preset style.dateFormatter.dateStyle = NSDateFormatterMediumStyle;//3.If the input string is not expected to contain a time, set the time style to none.dateFormatter.timeStyle = NSDateFormatterNoStyle;//4.Set the leniency to YES (enables the heuristics).dateFormatter.lenient = YES;//5.Convert the string to a date object.NSDate *date = [dateFormatter dateFromString:inputString]; 我们输入的字符串是9/3/14，dateStyle设为NSDateFormatterShortStyle，如果区域为美国，我们得到的NSDate信息为：2014-09-03 07:00:00 +0000，如果区域为德国，我们将得到2014-03-09 08:00:00 +0000。 数字本地化本地化设置会影响小数点符号，千分符，货币符等内容，比如数字1,234.56在意大利应该表示为1.234,56，所以对于数字的格式化我们应该用NSNumberFormatter处理。注意：NSNumberFormatter不是现成安全的1、将Number转成本地化的字符串可以使用NSNumberFormatter的localizedStringFromNumber:numberStyle:方式 1NSString *localizedString = [NSNumberFormatter localizedStringFromNumber:myNumber numberStyle:NSNumberFormatterDecimalStyle]; 以下是不同语言和区域关于数字的显示效果，左侧的style及numberStyle：2、将字符串转成NSNumber对象这个类似日期的转换 12345678//1.Create a number formatter object.NSNumberFormatter *numberFormatter = [NSNumberFormatter new];//2.Set the formatter’s style to a preset style.numberFormatter.numberStyle = NSNumberFormatterDecimalStyle;//3.Set the leniency to YES (enables the heuristics).numberFormatter.lenient = YES;//4.Convert the string to a number object.NSNumber *number = [numberFormatter numberFromString:inputString]; 3、通过NSCalendar计算日期NSCalendar类封装了日历的所有区域差异和复杂性。说他具有复杂性是因为在不同国家，一年之中的月份可能是12或者13，一月中的天数可能是5到31的任意值，每周第一天可能是周六，周日或者周一。可以看下表因此使用NSCalendar取这些值将会很方便。获取Calendar unit的方式为 123456789//1.Create an NSDateComponents object.NSDateComponents *components = [[NSCalendar currentCalendar] components:NSDayCalendarUnit | NSMonthCalendarUnit | NSYearCalendarUnit | NSEraCalendarUnit fromDate:[NSDate date]];//2.Access the values for day, month, year, and era.NSInteger day = [components day];NSInteger month = [components month];NSInteger year = [components year];NSInteger era = [components era]; 4、监听本地化信息或者时区修改可以通过NSCurrentLocaleDidChangeNotification监听区域的改变 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(localeDidChange:) name:NSCurrentLocaleDidChangeNotification object:nil]; 同样的监听时区变化可以通过NSSystemTimeZoneDidChangeNotification。 从右到左语言的处理创建从右到左语言的交互界面支持从右到左向的语言，在约束层面应该使用Auto layout中的leading和trailing属性，而不是right和right。可以通过以下对比看到区别整体像是做了水平的翻转，有很多控件像是segmented控件, 进度指示器系统会自动做翻转。但是有些情况是不需要翻转的： 视频控制和时间线指示器 图片，除非他们传达方向感，如箭头 时钟 乐谱 图表（x轴和y轴总是在一致的方向） 获取布局的方向性如果我们想获取当前语言是否应该是从右到左项的语言可以通过以下方法： 1234//right-to-left languageif ([UIView userInterfaceLayoutDirectionForSemanticContentAttribute:view.semanticContentAttribute] == UIUserInterfaceLayoutDirectionRightToLeft) { …} 设置文本的对齐方式在iOS中默认的文本对齐方式是“natural”，在OS X中默认方式是“left”。natural的含义就是会感觉语言的方向自动调整为left或者right。如果你想NSMutableParagraphStyle对象的对齐方式为自然的方向，可以： 1[[(NSMutableParagraphStyle *)paraStyle setAlignment:NSNaturalTextAlignment]; 对双向文本的处理双向文本就是一段文本中及含有从右往左的文本还含有从左往右的文本。是不是感觉很诧异？因为即使像阿拉伯和希伯来国家这些书写习惯为从右往左，但是对于数字和拉丁文是从左往右写的。如果你使用的是标准控件，像Label，TextView，Textfiled他们会自动处理双向文本内容。如果你是使用自定义控件，那这些问题就需要你手动处理。 向双向文本添加Unicode标记在某些特殊的时候，系统默认的行为可能会导致一些不正确的结果，这时我们可以通过添加Unicode标记进行纠正。 例如，手机号在所有语言中都是从左往右读的，如果一个需要本地化的字符串变量表示一个手机号，如果我们需要保证他是从左往右的顺序展示，需要再字符串首部增加一个从左往右的嵌入字符（LRE）：U+202A，在字符尾部增加定向格式字符（PDF）:U+202C。 123// Wrap the plus (+) prefix and phone number in left-to-right directional markersNSString *phoneNumber = @\"408-555-1212\";NSString *localizedPhoneNumber = [NSString stringWithFormat:@\"\\u202A%@\\u202C\", phoneNumber]; 翻转Cocoa Touch视图有些视图是不应该翻转的，在iOS9之后可以通过UIView的semanticContentAttribute属性手动指定视图应该是从左到后还是从右往左的方式展示。 如果是想翻转图片可以通过UIImage的imageFlippedForRightToLeftLayoutDirection方法。 本地化测试通过IB预览测试本地化这个功能只能在.storyboard和.xib文件实现。选中preview之后我们可以通过其右下角的语言选项切换不同语言，然后我们可以实时观察调换语言之后的效果。 通过伪语言功能测试通过Edit Schema &gt; Run &gt; Options 然后点开语言选项，除了各种系统支持语言外，翻到最下面可以看到这几个选项。1.Double-Length Pseudolanguage可以将文本内容变成两倍长度。 2.Right-to-Left Pseudolanguage将语言方向改成从右往左，也可以将语言改成阿拉伯文或者希伯来文。 3.Accented Pseudolanguage带重音符号。 4.Bounded String Pseudolanguage带边界的字符串。 5.Right-to-Left Pseudolanguage With Right-to-Left Strings同从右往左语言。 引用苹果文档：Internationzlization and Localization Guide","link":"/2019/08/19/localization_guide/"},{"title":"面试题总结（From J_Knight）","text":"前一段时间看了J_Knight的2017年5月iOS找人心得（附面试题）。作为一个在编程前线奋斗了将近两年的iOS从业人员，面对这些题目时，有些竟感觉生疏，甚至答不上来，很是惭愧。个人感觉，像runtime、线程、信号量相关的偏底层知识虽然平时基本用不到。特别是很多人可能都没参与过稍复杂项目的开发，优化，这些内容对于很多新手iOS开发来说只存在于理论。但并不是说这些知识不重要，相反，它是我们进阶的必经之路。此篇文章的目的一方面自己整理，一方面希望和大家共同学习进步。以下内容多数为整理，时间仓促可能有不准确的地方，如果缺漏，欢迎指正。 部分答案出处：iOSInterviewQuestions 基础为什么说Objective-C是一门动态语言？动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。比如Ruby、Python等就是动态语言，而C、C++等语言则不属于动态语言。所谓的动态类型语言，意思就是类型的检查是在运行时做的。 1、动态类型。 如id类型。实际上静态类型因为其固定性和可预知性而使用得更加广泛。静态类型是强类型，而动态类型属于弱类型。运行时决定接收者。 2、动态绑定。让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。 3、动态载入。让程序在运行时添加代码模块以及其他资源。用户可以根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件。可执行代码中可以含有和程序运行时整合的新类。 讲一下MVC和MVVM,MVPiOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构 为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?防止循环引用。 另外，不建议使用assignweak 当计数器为0 时对象被释放，地址指针就置为了nil 了。assign 当计数器为0 时 对象被释放，地址指针还是指向那个地址，就会产生野指针 datasource协议里面东西是跟内容有关的，主要是cell的构造函数，各种属性delegate协议里面的方法主要是操作相关的，移动编辑之类的，你都写上要用什么方法自己去翻就是了delegate控制的是UI，是上层的东西；而datasource控制的是数据。他们本质都是回调，只是回调的对象不同。 block 和 delegate 都可以通知外面。block 更轻型，使用更简单，能够直接访问上下文，这样类中不需要存储临时数据，使用 block 的代码通常会在同一个地方，这样读代码也连贯。delegate 更重一些，需要实现接口，它的方法分离开来，很多时候需要存储一些临时数据，另外相关的代码会被分离到各处，没有 block 好读。 多个相关方法，避免循环引用，建议用delegate。临时性的，只在栈中，需要存储，只调用一次，一个完成周期用block 属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？属性的本质就是实现实例变量和存取方法。 @property = ivar + getter + setter; 对应基本数据类型默认关键字是atomic,readwrite,assign 对于普通的 Objective-C 对象atomic,readwrite,strong @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 NSString为什么要用copy关键字，如果用strong会有什么问题？因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. 如何令自己所写的对象具有拷贝功能?若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？1234[immutableObject copy] // 浅复制[immutableObject mutableCopy] //深复制[mutableObject copy] //深复制[mutableObject mutableCopy] //深复制 但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制 为什么IBOutlet修饰的UIView也适用weak关键字？因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系 nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？atomic会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。 一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。 UICollectionView自定义layout如何实现？ 新建一个类继承UICollectionViewFlowLayout，实现prepareLayout方法。 新建UICollectionViewFlowLayout类，设置属性。 实现UICollectionViewDelegateFlowLayout方法。 用StoryBoard开发界面有什么弊端？如何避免？ 难以维护 性能瓶颈 错误定位不准确 解决多Storyboard协作弊端，就是尽量将项目的界面分割在多个Storyboard文件中。一个最佳实践是，按照项目功能模块来区分故事板，例如Login.Storyboard,Chat.Storyboard,Person.Storyboard等。尽量把每个Storyboard的Scene数量控制在20个以内 进程和线程的区别？同步异步的区别？并行和并发的区别？一个进程可以包括多个线程。一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。一个程序至少有一个进程,一个进程至少有一个线程. 线程只能归属于一个进程并且它只能访问该进程所拥有的资源。 同步会造成阻塞，异步非阻塞，网络请求操作。 一个形象的例子：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。“并行”概念是“并发”概念的一个子集 线程间的通信NSThread可以先将自己的当前线程对象注册到某个全局的对象中去，这样相互之间就可以获取对方的线程对象，然后就可以使用下面的方法进行线程间的通信了，由于主线程比较特殊，所以框架直接提供了在主线程执行的方法 GCD的一些常用的函数？（group，barrier，信号量，线程同步） group队列组通知监听函数(异步函数)dispatch_group_notify队列组等待函数(同步函数)dispatch_group_wait应用场景:下载两张图片，拼接图片后到主线程中刷新 barrier栅栏函数执行顺序：栅栏函数之前的任务(执行完毕)–&gt; 栅栏函数的任务(执行完毕)–&gt; 栅栏函数之后的任务栅栏函数前面和后面追加的操作执行顺序都不固定，但是前面的三个输出操作必然先执行，然后再执行栅栏函数中的操作，最后执行后面的三个输出操作。栅栏函数 信号量信号量大小是用于控制并发数量的信号量就是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的：设信号量值为1， 当一个进程1运行是，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这是信号量值为0。系统中规定当信号量值为0是，必须等待，知道信号量值不为零才能继续操作。 这时如果进程2想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就到到了进程1排他访问。 当进程1运行结束后，释放资源，进行V操作。资源数重新加1，这是信号量的值变为1. 这时进程2发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0.次数进程2咱有资源，排他访问资源。 这就是信号量来控制互斥的原理 线程同步：线程同步：@synchronized NSLock dispatch_semaphore(信号量设置为1) 如何使用队列来避免资源抢夺？当我们使用多线程来访问同一个数据的时候，就有可能造成数据的不准确性。这个时候我么可以使用线程锁的来来绑定。也是可以使用串行队列来完成。如：fmdb就是使用FMDatabaseQueue，来解决多线程抢夺资源。 数据持久化的几个方案（fmdb用没用过） plist CoreData FMDB 说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？12345678didFinishLaunchingWithOptions:applicationDidBecomeActive://前台到后台：applicationWillResignActive:applicationDidEnterBackground://后台到前台：applicationWillEnterForeground:applicationDidBecomeActive:NSCache优于NSDictionary的几点？ 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。 NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。 NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。 知不知道Designated Initializer？使用它的时候有什么需要注意的问题？便利初始化函数只能调用自己类中的其他初始化方法指定初始化函数才有资格调用父类的指定初始化函数构造便利函数 实现description方法能取到什么效果？description方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)，可定义输出自己想要的内容。 objc使用什么机制管理对象内存？1.Objective-C中所有对象都在堆区建立，由程序员负责释放对象所占用的内存。内存管理机制由3种：垃圾回收、引用计数、C语言方式。 2.垃圾回收是Mac OS10.5提供的新方案，在系统存在一个垃圾收集器。如果发现某个对象没有被任何对象使用，该对象被自动释放。 3.C语言方式，原始内存管理方式。用户手动调用malloc、calloc函数分配内存，free回收内存。 4.引用计数机制：对象创建后，运行时系统通过对象维护的一个计数器来描述有多少个其他对象在使用自己，当计数器为0时，释放该对象占用的内存空间（该对象调用dealloc方法）。 5,内存管理规则：当使用alloc，new或copy创建一个对象时，对象的引用计数被设置为1.；向对象发送retain消息，对象引用计数加1；向对象发送release消息时，对象引用计数减1；当对象引用计数为0时，运行时系统向对象发送dealloc消息并回收对象所占用的内存。 中级Blockblock的实质是什么？一共有几种block？都是什么情况下生成的？Block是iOS开发中一种比较特殊的数据结构，它可以保存一段代码，在合适的地方再调用，具有语法简介、回调方便、编程思路清晰、执行效率高等优点，受到众多猿猿的喜爱。 _NSConcreteGlobalBlock: 存储在全局数据区 _NSConcreteStackBlock: 存储在栈区 _NSConcreteMallocBlock: 存储在堆区其中，_NSConcreteGlobalBlock 和 _NSConcreteStackBlock 可以由程序创建，而 _NSConcreteMallocBlock 则无法由程序创建，只能由 _NSConcreteStackBlock 通过拷贝生成。 为什么在默认情况下无法修改被block捕获的变量？ __block都做了什么？Block不允许修改外部变量的值。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。将变量由栈区移到堆区。 模拟一下循环引用的一个情况？block实现界面反向传值如何实现？一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。解决方法是将该对象使用__weak或者__block修饰符修饰之后再在block中使用.id weak weakSelf = self; 或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏id __block weakSelf = self;或者将其中一方强制制空 xxx = nil。 Runtimeobjc在向一个对象发送消息时，发生了什么？ 通过对象的isa指针获取类的结构体。 在结构体的方法表里查找方法的selector。 如果没有找到selector，则通过objc_msgSend结构体中指向父类的指针找到父类，并在父类的方法表里查找方法的selector。 依次会一直找到NSObject。 一旦找到selector，就会获取到方法实现IMP。 传入相应的参数来执行方法的具体实现。 如果最终没有定位到selector，就会走消息转发流程。 什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？找不到执行方法。 动态方法解析对象接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或 者+resolveClassMethod:(类方法)。 备用接收者如果这个方法返回一个对象，则这个对象会作为消息的新接收者。注意这个对象不能是self自身，否则就是出现无限循环。如果没有指定对象来处理aSelector，则应该 return [super forwardingTargetForSelector:aSelector]。 完整消息转发这是最后一次机会将消息转发给其它对象。创建一个表示消息的NSInvocation对象，把与消息的有关全部细节封装在anInvocation中，包括selector，目标(target)和参数。在forwardInvocation 方法中将消息转发给其它对象。 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？不能向编译后得到的类中增加实例变量；能向运行时创建的类中添加实例变量；解释下：因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量； 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair之前，原因同上。 runtime如何实现weak变量的自动置nil？runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。 给类添加一个属性后，在类结构体里哪些元素会发生变化？ instance_size ：实例的内存大小objc_ivar_list *ivars:属性列表 RunLooprunloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？循环检测线程任务。为了在我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。 主线程的run loop默认是启动的。 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。 NSRunLoop *runloop = [NSRunLoop currentRunLoop]; runloop的mode是用来做什么的？有几种mode？model 主要是用来指定事件在运行循环中的优先级的，分为： NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态UITrackingRunLoopMode：ScrollView滑动时UIInitializationRunLoopMode：启动时NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合苹果公开提供的 Mode 有两个： NSDefaultRunLoopMode（kCFRunLoopDefaultMode） NSRunLoopCommonModes（kCFRunLoopCommonModes）为什么把NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环以后，滑动scrollview的时候NSTimer却不动了？RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。 如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。 同时因为mode还是可定制的，所以： Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。 //将timer添加到NSDefaultRunLoopMode中 [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES]; //然后再添加到NSRunLoopCommonModes里 NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];苹果是如何实现Autorelease Pool的？autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成. objc_autoreleasepoolPushobjc_autoreleasepoolPopobjc_autorelease看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。 举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：备注：Objective-C Autorelease Pool 的实现原理 可能苹果在ARC的处理上又优化了，或者变更了。我自己测试的结果跟以上分析不一致，但原理可以参考。 类结构isa指针？（对象的isa，类对象的isa，元类的isa都要说）每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中） 成员变量的列表, 属性列表,它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。 类方法和实例方法有什么区别？ 类方法：类方法是属于类对象的类方法只能通过类对象调用类方法中的self是类对象类方法可以调用其他的类方法类方法中不能访问成员变量类方法中不能直接调用对象方法 实例方法：实例方法是属于实例对象的实例方法只能通过实例对象调用实例方法中的self是实例对象实例方法中可以访问成员变量实例方法中直接调用实例方法实例方法中也可以调用类方法(通过类名) 介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？分类可以在不知道系统类源代码的情况下，为这个类添加新的方法。分类只能用来添加方法，不能添加成员变量。通过分类增加的方法，系统会认为是该类类型的一部分Category实现原理 运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？可以添加属性，不可以添加成员变量。OC类成员变量深度剖析 objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如： Person *motherInlaw = [[aPerson spouse] mother]; 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。 高级UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）一般在网络请求结束后，在更新界面之前就把每个 cell 的高度算好，缓存到相对应的 model 中。 另外绘制 cell 不建议使用 UIView，建议使用 CALayer。简单的形式参考： 12345678910111213141516dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ CGRect rect = CGRectMake(0, 0, 100, 100); UIGraphicsBeginImageContextWithOptions(rect.size, YES, 0); CGContextRef context = UIGraphicsGetCurrentContext(); [[UIColor lightGrayColor] set]; CGContextFillRect(context, rect); //将绘制的内容以图片的形式返回，并调主线程显示 UIImage *temp = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); // 回到主线程 dispatch_async(dispatch_get_main_queue(), ^{ //code });});CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。","link":"/2017/06/29/interview-question/"},{"title":"Swift进阶黄金之路（二）","text":"Swift进阶黄金之路（一） 上期遗留一个问题：为什么 rethrows 一般用在参数中含有可以 throws 的方法的高阶函数中。 我们可以结合Swift的官方文档对rethrows再做一遍回顾： A function or method can be declared with the rethrows keyword to indicate that it throws an error only if one of its function parameters throws an error. These functions and methods are known as rethrowing functions and rethrowing methods. Rethrowing functions and methods must have at least one throwing function parameter. 返回rethrows的函数要求至少有一个可抛出异常的函数式参数，而有以函数作为参数的函数就叫做高阶函数。 这期分两方面介绍Swift：特性修饰词和一些重要的Swift概念。 特性修饰词在Swift语法中有很多@符号，这些@符号在Swift4之前的版本大多是兼容OC的特性，Swift4及之后则出现越来越多搭配@符号的新特性。以@开头的修饰词，在官网中叫Attributes，在SwiftGG的翻译中叫特性，我并没有找到这一类被@修饰的符号的统称，就暂且叫他们特性修饰词吧，如果有清楚的小伙伴可以告知我。 从Swift5的发布来看（@dynamicCallable,@State），之后将会有更多的特性修饰词出现，在他们出来之前，我们有必要先了解下现有的一些特性修饰词以及它们的作用。 参考：Swift Attributes @available@available： 可用来标识计算属性、函数、类、协议、结构体、枚举等类型的生命周期。（依赖于特定的平台版本 或 Swift 版本）。它的后面一般跟至少两个参数，参数之间以逗号隔开。其中第一个参数是固定的，代表着平台和语言，可选值有以下这几个： iOS iOSApplicationExtension macOS macOSApplicationExtension watchOS watchOSApplicationExtension tvOS tvOSApplicationExtension swift 可以使用*指代支持所有这些平台。 有一个我们常用的例子，当需要关闭ScrollView的自动调整inset功能时： 123456// 指定该方法仅在iOS11及以上的系统设置if #available(iOS 11.0, *) { scrollView.contentInsetAdjustmentBehavior = .never} else { automaticallyAdjustsScrollViewInsets = false} 还有一种用法是放在函数、结构体、枚举、类或者协议的前面，表示当前类型仅适用于某一平台： 123456789101112@available(iOS 12.0, *)func adjustDarkMode() { /* code */}@available(iOS 12.0, *)struct DarkModeConfig { /* code */}@available(iOS 12.0, *)protocol DarkModeTheme { /* code */} 版本和平台的限定可以写多个： 12@available(OSX 10.15, iOS 13, tvOS 13, watchOS 6, *)public func applying(_ difference: CollectionDifference&lt;Element&gt;) -&gt; ArraySlice&lt;Element&gt;? 注意：作为条件语句的available前面是#，作为标记位时是@ 刚才说了，available后面参数至少要有两个，后面的可选参数这些： deprecated：从指定平台标记为过期，可以指定版本号 obsoleted=版本号：从指定平台某个版本开始废弃（注意弃用的区别，deprecated是还可以继续使用，只不过是不推荐了，obsoleted是调用就会编译错误）该声明 message=信息内容：给出一些附加信息 unavailable：指定平台上是无效的 renamed=新名字：重命名声明 我们看几个例子，这个是Array里flatMap的函数说明： 12@available(swift, deprecated: 4.1, renamed: \"compactMap(_:)\", message: \"Please use compactMap(_:) for the case where closure returns an optional value\")public func flatMap&lt;ElementOfResult&gt;(_ transform: (Element) throws -&gt; ElementOfResult?) rethrows -&gt; [ElementOfResult] 它的含义是针对swift语言，该方式在swift4.1版本之后标记为过期，对应该函数的新名字为compactMap(_:)，如果我们在4.1之上的版本使用该函数会收到编译器的警告，即⚠️Please use compactMap(_:) for the case where closure returns an optional value。 在Realm库里，有一个销毁NotificationToken的方法，被标记为unavailable： 1234extension RLMNotificationToken { @available(*, unavailable, renamed: \"invalidate()\") @nonobjc public func stop() { fatalError() }} 标记为unavailable就不会被编译器联想到。这个主要是为升级用户的迁移做准备，从可用stop()的版本升上了，会红色报错，提示该方法不可用。因为有renamed，编译器会推荐你用invalidate()，点击fix就直接切换了。所以这两个标记参数常一起出现。 @discardableResult带返回的函数如果没有处理返回值会被编译器警告⚠️。但有时我们就是不需要返回值的，这个时候我们可以让编译器忽略警告，就是在方法名前用@discardableResult声明一下。可以参考Alamofire中request的写法： 1234567891011121314151617@discardableResultpublic func request( _ url: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoding: ParameterEncoding = URLEncoding.default, headers: HTTPHeaders? = nil) -&gt; DataRequest{ return SessionManager.default.request( url, method: method, parameters: parameters, encoding: encoding, headers: headers )} @inlinable这个关键词是可内联的声明，它来源于C语言中的inline。C中一般用于函数前，做内联函数，它的目的是防止当某一函数多次调用造成函数栈溢出的情况。因为声明为内联函数，会在编译时将该段函数调用用具体实现代替，这么做可以省去函数调用的时间。 内联函数常出现在系统库中，OC中的runtim中就有大量的inline使用： 12345678static inline id autorelease(id obj){ ASSERT(obj); ASSERT(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); ASSERT(!dest || dest == EMPTY_POOL_PLACEHOLDER || *dest == obj); return obj;} Swift中的@inlinable和C中的inline基本相同，它在标准库的定义中也广泛出现，可用于方法，计算属性，下标，便利构造方法或者deinit方法中。 例如Swift对Array中map函数的定义： 1@inlinable public func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T] 其实Array中声明的大部分函数前面都加了@inlinable，当应用某一处调用该方法时，编译器会将调用处用具体实现代码替换。 需要注意内联声明不能用于标记为private或者fileprivate的地方。 这很好理解，对私有方法的内联是没有意义的。内联的好处是运行时更快，因为它省略了从标准库调用map实现的步骤。但这个快也是有代价的，因为是编译时做替换，这增加了编译的开销，会相应的延长编译时间。 内联更多的是用于系统库的特性，目前我了解的Swift三方库中仅有CocoaLumberjack使用了@inlinable这个特性。 @warn_unqualified_access通过命名我们可以推断出其大概含义：对“不合规”的访问进行警告。这是为了解决对于相同名称的函数，不同访问对象可能产生歧义的问题。 比如说，Swift 标准库中Array和Sequence均实现了min()方法，而系统库中也定义了min(::)，对于可能存在的二义性问题，我们可以借助于@warn_unqualified_access。 12345678extension Array where Self.Element : Comparable { @warn_unqualified_access @inlinable public func min() -&gt; Element?}extension Sequence where Self.Element : Comparable { @warn_unqualified_access @inlinable public func min() -&gt; Self.Element?} 这个特性声明会由编译器在可能存在二义性的场景中对我们发出警告。这里有一个场景可以便于理解它的含义，我们自定义一个求Array中最小值的函数： 12345extension Array where Element: Comparable { func minValue() -&gt; Element? { return min() }} 我们会收到编译器的警告：Use of 'min' treated as a reference to instance method in protocol 'Sequence', Use 'self.' to silence this warning。它告诉我们编译器推断我们当前使用的是Sequence中的min()，这与我们的想法是违背的。因为有这个@warn_unqualified_access限定，我们能及时的发现问题，并解决问题：self.min()。 @objc把这个特性用到任何可以在 Objective-C 中表示的声明上——例如，非内嵌类，协议，非泛型枚举（原始值类型只能是整数），类和协议的属性、方法（包括 setter 和 getter ），初始化器，反初始化器，下标。 objc 特性告诉编译器，这个声明在 Objective-C 代码中是可用的。 用 objc 特性标记的类必须继承自一个 Objective-C 中定义的类。如果你把 objc 用到类或协议中，它会隐式地应用于该类或协议中 Objective-C 兼容的成员上。如果一个类继承自另一个带 objc 特性标记或 Objective-C 中定义的类，编译器也会隐式地给这个类添加 objc 特性。标记为 objc 特性的协议不能继承自非 objc 特性的协议。 @objc还有一个用处是当你想在OC的代码中暴露一个不同的名字时，可以用这个特性，它可以用于类，函数，枚举，枚举成员，协议，getter，setter等。 12345678// 当在OC代码中访问enabled的getter方法时，是通过isEnabledclass ExampleClass: NSObject { @objc var enabled: Bool { @objc(isEnabled) get { // Return the appropriate value } }} 这一特性还可以用于解决潜在的命名冲突问题，因为Swift有命名空间，常常不带前缀声明，而OC没有命名空间是需要带的，当在OC代码中引用Swift库，为了防止潜在的命名冲突，可以选择一个带前缀的名字供OC代码使用。 Charts作为一个在OC和Swift中都很常用的图标库，是需要较好的同时兼容两种语言的使用的，所以也可以看到里面有大量通过@objc标记对OC调用时的重命名代码： 12345@objc(ChartAnimator)open class Animator: NSObject { }@objc(ChartComponentBase)open class ComponentBase: NSObject { } @objcMembers因为Swift中定义的方法默认是不能被OC调用的，除非我们手动添加@objc标识。但如果一个类的方法属性较多，这样会很麻烦，于是有了这样一个标识符@objcMembers，它可以让整个类的属性方法都隐式添加@objc，不光如此对于类的子类、扩展、子类的扩展都也隐式的添加@objc，当然对于OC不支持的类型，仍然无法被OC调用： 12345678910111213141516171819@objcMembersclass MyClass : NSObject { func foo() { } // implicitly @objc func bar() -&gt; (Int, Int) // not @objc, because tuple returns // aren't representable in Objective-C}extension MyClass { func baz() { } // implicitly @objc}class MySubClass : MyClass { func wibble() { } // implicitly @objc}extension MySubClass { func wobble() { } // implicitly @objc} 参考：Swift3、4中的@objc、@objcMembers和dynamic @testable@testable是用于测试模块访问主target的一个关键词。 因为测试模块和主工程是两个不同的target，在swift中，每个target代表着不同的module，不同module之间访问代码需要public和open级别的关键词支撑。但是主工程并不是对外模块，为了测试修改访问权限是不应该的，所以有了@testable关键词。使用如下： 123456import XCTest@testable import Projectclass ProjectTests: XCTestCase { /* code */} 这时测试模块就可以访问那些标记为internal或者public级别的类和成员了。 @frozen 和@unknown defaultfrozen意为冻结，是为Swift5的ABI稳定准备的一个字段，意味向编译器保证之后不会做出改变。为什么需要这么做以及这么做有什么好处，他们和ABI稳定是息息相关的，内容有点多就不放这里了，之后会单独出一篇文章介绍，这里只介绍这两个字段的含义。 123456789101112131415@frozen public enum ComparisonResult : Int { case orderedAscending = -1 case orderedSame = 0 case orderedDescending = 1}@frozen public struct String {}extension AVPlayerItem { public enum Status : Int { case unknown = 0 case readyToPlay = 1 case failed = 2 }} ComparisonResult这个枚举值被标记为@frozen即使保证之后该枚举值不会再变。注意到String作为结构体也被标记为@frozen，意为String结构体的属性及属性顺序将不再变化。其实我们常用的类型像Int、Float、Array、Dictionary、Set等都已被“冻结”。需要说明的是冻结仅针对struct和enum这种值类型，因为他们在编译器就确定好了内存布局。对于class类型，不存在是否冻结的概念，可以想下为什么。 对于没有标记为frozen的枚举AVPlayerItem.Status，则认为该枚举值在之后的系统版本中可能变化。 对于可能变化的枚举，我们在列出所有case的时候还需要加上对@unknown default的判断，这一步会有编译器检查： 12345678910switch currentItem.status { case .readyToPlay: /* code */ case .failed: /* code */ case .unknown: /* code */ @unknown default: fatalError(\"not supported\")} @State、@Binding、@ObservedObject、@EnvironmentObject这几个是SwiftUI中出现的特性修饰词，因为我对SwiftUI的了解不多，这里就不做解释了。附一篇文章供大家了解。 [译]理解 SwiftUI 里的属性装饰器@State, @Binding, @ObservedObject, @EnvironmentObject 几个重要关键词lazylazy是懒加载的关键词，当我们仅需要在使用时进行初始化操作就可以选用该关键词。举个例子： 12345678class Avatar { lazy var smallImage: UIImage = self.largeImage.resizedTo(Avatar.defaultSmallSize) var largeImage: UIImage init(largeImage: UIImage) { self.largeImage = largeImage }} 对于smallImage，我们声明了lazy，如果我们不去调用它是不会走后面的图片缩放计算的。但是如果没有lazy，因为是初始化方法，它会直接计算出smallImage的值。所以lazy很好的避免的不必要的计算。 另一个常用lazy的地方是对于UI属性的定义： 12345lazy var dayLabel: UILabel = { let label = UILabel() label.text = self.todayText() return label}() 这里使用的是一个闭包，当调用该属性时，执行闭包里面的内容，返回具体的label，完成初始化。 使用lazy你可能会发现它只能通过var初始而不能通过let，这是由 lazy 的具体实现细节决定的：它在没有值的情况下以某种方式被初始化，然后在被访问时改变自己的值，这就要求该属性是可变的。 另外我们可以在Sequences中使用lazy，在讲解它之前我们先看一个例子： 123456789func increment(x: Int) -&gt; Int { print(\"Computing next value of \\(x)\") return x+1}let array = Array(0..&lt;1000)let incArray = array.map(increment)print(\"Result:\")print(incArray[0], incArray[4]) 在执行print(&quot;Result:&quot;)之前，Computing next value of ...会被执行1000次，但实际上我们只需要0和4这两个index对应的值。 上面说了序列也可以使用lazy，使用的方式是： 1234567let array = Array(0..&lt;1000)let incArray = array.lazy.map(increment)print(\"Result:\")print(incArray[0], incArray[4])// Result:// 1 5 在执行print(&quot;Result:&quot;)之前，并不会打印任何东西，只打印了我们用到的1和5。就是说这里的lazy可以延迟到我们取值时才去计算map里的结果。 我们看下这个lazy的定义： 1@inlinable public var lazy: LazySequence&lt;Array&lt;Element&gt;&gt; { get } 它返回一个LazySequence的结构体，这个结构体里面包含了Array，而map的计算在LazySequence里又重新定义了一下： 1234/// Returns a `LazyMapSequence` over this `Sequence`. The elements of/// the result are computed lazily, each time they are read, by/// calling `transform` function on a base element.@inlinable public func map&lt;U&gt;(_ transform: @escaping (Base.Element) -&gt; U) -&gt; LazyMapSequence&lt;Base, U&gt; 这里完成了lazy序列的实现。LazySequence类型的lazy只能被用于map、flatMap、compactMap这样的高阶函数中。 参考： “懒”点儿好 纠错：参考文章中说：”这些类型（LazySequence）只能被用在 map，flatMap，filter这样的高阶函数中” 其实是没有filter的，因为filter是过滤函数，它需要完整遍历一遍序列才能完成过滤操作，是无法懒加载的，而且我查了LazySequence的定义，确实是没有filter函数的。 unowned weakSwift开发过程中我们会经常跟闭包打交道，而用到闭包就不可避免的遇到循环引用问题。在Swift处理循环引用可以使用unowned和weak这两个关键词。看下面两个例子： 12345678910111213141516171819202122232425class Dog { var name: String init (name: String ) { self.name = name } deinit { print(\"\\(name) is deinitialized\") }}class Bone { // weak 修饰词 weak var owner: Dog? init(owner: Dog?) { self.owner = owner } deinit { print(\"bone is deinitialized\" ) }}var lucky: Dog? = Dog(name: \"Lucky\")var bone: Bone? = Bone(owner: lucky!)lucky = nil// Lucky is deinitialized 这里Dog和Bone是相互引用的关系，如果没有weak var owner: Dog?这里的weak声明，将不会打印Lucky is deinitialized。还有一种解决循环应用的方式是把weak替换为unowned关键词。 weak相当于oc里面的weak，弱引用，不会增加循环计数。主体对象释放时被weak修饰的属性也会被释放，所以weak修饰对象就是optional。 unowned相当于oc里面的unsafe_unretained，它不会增加引用计数，即使它的引用对象释放了，它仍然会保持对被已经释放了的对象的一个 “无效的” 引用，它不能是 Optional 值，也不会被指向 nil。如果此时为无效引用，再去尝试访问它就会crash。 这两者还有一个更常用的地方是在闭包里面： 12345lazy var someClosure: () -&gt; Void = { [weak self] in // 被weak修饰后self为optional，这里是判断self非空的操作 guard let self = self else { retrun } self.doSomethings()} 这里如果是unowned修饰self的话，就不需要用guard做解包操作了。但是我们不能为了省略解包的操作就用unowned，也不能为了安全起见全部weak，弄清楚两者的适用场景非常重要。 根据苹果的建议： Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time. 当闭包和它捕获的实例总是相互引用，并且总是同时释放时，即相同的生命周期，我们应该用unowned，除此之外的场景就用weak。 img 参考：内存管理，WEAK 和 UNOWNED Unowned 还是 Weak？生命周期和性能对比 KeyPathKeyPath是键值路径，最开始是用于处理KVC和KVO问题，后来又做了更广泛的扩展。 123456789101112131415161718192021// KVC问题，支持struct、classstruct User { let name: String var age: Int}var user1 = User()user1.name = \"ferry\"user1.age = 18 //使用KVC取值let path: KeyPath = \\User.nameuser1[keyPath: path] = \"zhang\"let name = user1[keyPath: path]print(name) //zhang// KVO的实现还是仅限于继承自NSObject的类型// playItem为AVPlayerItem对象playItem.observe(\\.status, changeHandler: { (_, change) in /* code */ }) 这个KeyPath的定义是这样的： 12345678public class AnyKeyPath : Hashable, _AppendKeyPath {}/// A partially type-erased key path, from a concrete root type to any/// resulting value type.public class PartialKeyPath&lt;Root&gt; : AnyKeyPath {}/// A key path from a specific root type to a specific resulting value type.public class KeyPath&lt;Root, Value&gt; : PartialKeyPath&lt;Root&gt; {} 定义一个KeyPath需要指定两个类型，根类型和对应的结果类型。对应上面示例中的path： 1let path: KeyPath&lt;User, String&gt; = \\User.name 根类型就是User，结果类型就是String。也可以不指定，因为编译器可以从\\User.name推断出来。那为什么叫根类型的？可以注意到KeyPath遵循一个协议_AppendKeyPath，它里面定义了很多append的方法，KeyPath是多层可以追加的，就是如果属性是自定义的Address类型，形如： 1234struct Address { var country: String = \"\"}let path: KeyPath&lt;User, String&gt; = \\User.address.country 这里根类型为User，次级类型是Address，结果类型是String。所以path的类型依然是KeyPath。 明白了这些我们可以用KeyPath做一些扩展： 123456789extension Sequence { func sorted&lt;T: Comparable&gt;(by keyPath: KeyPath&lt;Element, T&gt;) -&gt; [Element] { return sorted { a, b in return a[keyPath: keyPath] &lt; b[keyPath: keyPath] } }}// users is Array&lt;User&gt;let newUsers = users.sorted(by: \\.age) 这个自定义sorted函数实现了通过传入keyPath进行升序排列功能。 参考：The power of key paths in Swift somesome是Swift5.1新增的特性。它的用法就是修饰在一个 protocol 前面，默认场景下 protocol 是没有具体类型信息的，但是用 some 修饰后，编译器会让 protocol 的实例类型对外透明。 可以通过一个例子理解这段话的含义，当我们尝试定义一个遵循Equatable协议的value时： 12345678// Protocol 'Equatable' can only be used as a generic constraint because it has Self or associated type requirementsvar value: Equatable { return 1}var value: Int { return 1} 编译器提示我们Equatable只能被用来做泛型的约束，它不是一个具体的类型，这里我们需要使用一个遵循Equatable的具体类型（Int）进行定义。但有时我们并不想指定具体的类型，这时就可以在协议名前加上some，让编译器自己去推断value的类型： 123var value: some Equatable { return 1} 在SwiftUI里some随处可见： 12345struct ContentView: View { var body: some View { Text(\"Hello World\") }} 这里使用some就是因为View是一个协议，而不是具体类型。 当我们尝试欺骗编译器，每次随机返回不同的Equatable类型： 1234567var value: some Equatable { if Bool.random() { return 1 } else { return \"1\" }} 聪明的编译器是会发现的，并警告我们Function declares an opaque return type, but the return statements in its body do not have matching underlying types。 参考：SwiftUI 的一些初步探索 (一)","link":"/2020/05/31/swift_advance_2/"},{"title":"Swift进阶黄金之路","text":"Swift进阶黄金之路（二） 这篇是对一文鉴定是Swift的王者，还是青铜文章中问题的解答。这些问题仅仅是表层概念，属于知识点，在我看来即使都很清楚也并不能代表上了王者，如果非要用段位类比的话，黄金还是合理的😄。 Swift是一门上手容易，但是精通较难的语言。即使下面这些内容都不清楚也不妨碍你开发业务需求，但是了解之后它能够帮助我们写出更加Swifty的代码。 一、 协议 ProtocolExpressibleByDictionaryLiteralExpressibleByDictionaryLiteral是字典的字面量协议，该协议的完整写法为： 12345678public protocol ExpressibleByDictionaryLiteral { /// The key type of a dictionary literal. associatedtype Key /// The value type of a dictionary literal. associatedtype Value /// Creates an instance initialized with the given key-value pairs. init(dictionaryLiteral elements: (Self.Key, Self.Value)...)} 首先字面量（Literal）的意思是：用于表达源代码中一个固定值的表示法（notation）。 举个例子，构造字典我们可以通过以下两种方式进行： 123456// 方法一：var countryCodes = Dictionary&lt;String, Any&gt;()countryCodes[\"BR\"] = \"Brazil\"countryCodes[\"GH\"] = \"Ghana\"// 方法二：let countryCodes = [\"BR\": \"Brazil\", \"GH\": \"Ghana\"] 第二种构造方式就是通过字面量方式进行构造的。 其实基础类型基本都是通过字面量进行构造的： 1234let num: Int = 10let flag: Bool = truelet str: String = \"Brazil\"let array: [String] = [\"Brazil\", \"Ghana\"] 而这些都有对应的字面量协议： 123456ExpressibleByNilLiteral // nil字面量协议ExpressibleByIntegerLiteral // 整数字面量协议ExpressibleByFloatLiteral // 浮点数字面量协议ExpressibleByBooleanLiteral // 布尔值字面量协议ExpressibleByStringLiteral // 字符串字面量协议ExpressibleByArrayLiteral // 数组字面量协议 SequenceSequence翻译过来就是序列，该协议的目的是一系列相同类型的值的集合，并且提供对这些值的迭代能力，这里的迭代可以理解为遍历，也即for-in的能力。可以看下该协议的定义： 1234protocol Sequence { associatedtype Iterator: IteratorProtocol func makeIterator() -&gt; Iterator} Sequence又引入了另一个协议IteratorProtocol，该协议就是为了提供序列的迭代能力。 1234public protocol IteratorProtocol { associatedtype Element public mutating func next() -&gt; Self.Element?} 我们通常用for-in实现数组的迭代： 1234let animals = [\"Antelope\", \"Butterfly\", \"Camel\", \"Dolphin\"]for animal in animals { print(animal)} 这里的for-in会被编译器翻译成： 1234var animalIterator = animals.makeIterator()while let animal = animalIterator.next() { print(animal)} CollectionCollection译为集合，其继承于Sequence。 12345678910public protocol Collection : Sequence { associatedtype Index : Comparable var startIndex: Index { get } var endIndex: Index { get } var isEmpty: Bool { get } var count: Int { get } subscript(position: Index) -&gt; Element { get } subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }} 是一个元素可以反复遍历并且可以通过索引的下标访问的有限集合，注意Sequence可以是无限的，Collection必须是有限的。 Collection在Sequence的基础上扩展了下标访问、元素个数能特性。我们常用的集合类型Array，Dictionary，Set都遵循该协议。 CustomStringConvertible这个协议表示自定义类型输出的样式。先来看下它的定义： 123public protocol CustomStringConvertible { var description: String { get }} 只有一个description的属性。它的使用很简单： 123456789101112struct Point: CustomStringConvertible { let x: Int, y: Int var description: String { return \"(\\(x), \\(y))\" }}let p = Point(x: 21, y: 30)print(p) // (21, 30)//String(describing: &lt;#T##CustomStringConvertible#&gt;)let s = String(describing: p)print(s) // (21, 30) 如果不实现CustomStringConvertible，直接打印对象，系统会根据默认设置进行输出。我们可以通过CustomStringConvertible对这一输出行为进行设置，还有一个协议是CustomDebugStringConvertible： 123public protocol CustomDebugStringConvertible { var debugDescription: String { get }} 跟CustomStringConvertible用法一样，对应debugPrint的输出。 Hashable我们常用的Dictionary，Set均实现了Hashable协议。Hash的目的是为了将查找集合某一元素的时间复杂度降低到O(1)，为了实现这一目的需要将集合元素与存储地址之间建议一种尽可能一一对应的关系。 我们再看Hashable`协议的定义： 12345678public protocol Hashable : Equatable { var hashValue: Int { get } func hash(into hasher: inout Hasher)}public protocol Equatable { static func == (lhs: Self, rhs: Self) -&gt; Bool} 注意到func hash(into hasher: inout Hasher)，Swift 4.2 通过引入 Hasher 类型并采用新的通用哈希函数进一步优化 Hashable。 如果你要自定义类型实现 Hashable 的方式，可以重写 hash(into:) 方法而不是 hashValue。hash(into:) 通过传递了一个 Hasher 引用对象，然后通过这个对象调用 combine(_:) 来添加类型的必要状态信息。 1234567891011121314151617181920// Swift &gt;= 4.2struct Color: Hashable { let red: UInt8 let green: UInt8 let blue: UInt8 // Synthesized by compiler func hash(into hasher: inout Hasher) { hasher.combine(self.red) hasher.combine(self.green) hasher.combine(self.blue) } // Default implementation from protocol extension var hashValue: Int { var hasher = Hasher() self.hash(into: &amp;hasher) return hasher.finalize() }} 参考：Hashable / Hasher CodableCodable是可Decodable和Encodable的类型别名。它能够将程序内部的数据结构序列化成可交换数据，也能够将通用数据格式反序列化为内部使用的数据结构，大大提升对象和其表示之间互相转换的体验。处理的问题就是我们经常遇到的JSON转模型，和模型转JSON。 12345678public typealias Codable = Decodable &amp; Encodablepublic protocol Decodable { init(from decoder: Decoder) throws}public protocol Encodable { func encode(to encoder: Encoder) throws} 这里只举一个简单的解码过程： 12345678910111213141516//json数据{ \"id\": \"1283984\", \"name\": \"Mike\", \"age\": 18}// 定义对象struct Person: Codable{ var id: String var name: String var age: Int}// json为网络接口返回的Data类型数据let mike = try! JSONDecoder().decode(Person.self, from: json)print(mike)//输出：Student(id: \"1283984\", name: \"Mike\", age: 18) 是不是非常简单，Codable还支持各种自定义解编码过程，完全可以取代SwiftyJSON，HandyJSON等编解码库。 Comparable这个是用于实现比较功能的协议，它的定义如下： 12345678910public protocol Comparable : Equatable { static func &lt; (lhs: Self, rhs: Self) -&gt; Bool static func &lt;= (lhs: Self, rhs: Self) -&gt; Bool static func &gt;= (lhs: Self, rhs: Self) -&gt; Bool static func &gt; (lhs: Self, rhs: Self) -&gt; Bool} 其继承于Equatable，即判等的协议。可以很清楚的理解实现了各种比较的定义就具有了比较的功能。这个不做比较。 RangeReplaceableCollectionRangeReplaceableCollection支持用另一个集合的元素替换元素的任意子范围的集合。 看下它的定义： 1234567891011public protocol RangeReplaceableCollection : Collection where Self.SubSequence : RangeReplaceableCollection { associatedtype SubSequence mutating func append(_ newElement: Self.Element) mutating func insert&lt;S&gt;(contentsOf newElements: S, at i: Self.Index) where S : Collection, Self.Element == S.Element /* 拼接、插入、删除、替换的方法，他们都具有对组元素的操作能力 */ override subscript(bounds: Self.Index) -&gt; Self.Element { get } override subscript(bounds: Range&lt;Self.Index&gt;) -&gt; Self.SubSequence { get }} 举个例子，Array支持该协议，我们可以进行如下操作： 12345var bugs = [\"Aphid\", \"Damselfly\"]bugs.append(\"Earwig\")bugs.insert(contentsOf: [\"Bumblebee\", \"Cicada\"], at: 1)print(bugs)// Prints \"[\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\" 这里附一张Swift中Array遵循的协议关系图，有助于大家理解上面讲解的几个协议之间的关系： 图像来源：https://swiftdoc.org/v3.1/type/array/hierarchy/ 二、@propertyWrapper 阅读以下代码，print 输出什么 1234567891011121314151617@propertyWrapperstruct Wrapper&lt;T&gt; { var wrappedValue: T var projectedValue: Wrapper&lt;T&gt; { return self } func foo() { print(\"Foo\") }}struct HasWrapper { @Wrapper var x = 0 func foo() { print(x) // 0 print(_x) // Wrapper&lt;Int&gt;(wrappedValue: 0) print($x) // Wrapper&lt;Int&gt;(wrappedValue: 0) }} 这段代码看似要考察对@propertyWrapper的理解，但是有很多无用内容，导致代码很奇怪。 @propertyWrapper的意思就是属性包装，它可以将一系列相似的属性方法进行统一处理。举个例子，如果我们需要在UserDefaults中加一个是否首次启动的值，正常可以这样处理： 12345678910111213extension UserDefaults { enum Keys { static let isFirstLaunch = \"isFirstLaunch\" } var isFirstLaunch: Bool { get { return bool(forKey: Keys.isFirstLaunch) } set { set(newValue, forKey: Keys.isFirstLaunch) } }} 如果我们需要加入很多这样属性的话，就需要写大量的get 、set方法。而@propertyWrapper的作用就是为属性的这种设置提供一个模板写法，以下是使用属性包装的写法。 1234567891011121314151617181920212223@propertyWrapperstruct UserDefaultWrapper&lt;T&gt; { private let key: String private let defaultValue: T init(key: String, defaultValue: T) { self.key = key self.defaultValue = defaultValue } var wrappedValue: T { get { UserDefaults.standard.object(forKey: key) as? T ?? defaultValue } set { UserDefaults.standard.set(newValue, forKey: key) } }}class UserDefaults { @UserDefaultWrapper(key: Keys.isFirstLaunch, defaultValue: false) var isFirstLaunch: Bool} @propertyWrapper约束的对象必须要定义wrappedValue属性，因为该对象包裹的属性会走到wrappedValue的实现。 回到实例代码，定义了wrappedValue却并没有添加任何实现，这是允许的。所以访问x的时候其实是访问Wrapper的wrappedValue，因为没有给出任何实现所以直接打印出0。而_x和$x对应的就是Wrapper自身。 参考：Swift Property Wrappers 三、关键字public openpublic open为权限关键词。对于一个严格的项目来说，精确的最小化访问控制级别对于代码的维护来说相当重要的。完整的权限关键词，按权限大小排序如下： open &gt; public &gt; internal &gt; fileprivate &gt; private open权限最大，允许外部module访问，继承，重写。 public允许外部module访问，但不允许继承，重写。 internal为默认关键词，在同一个module内可以共用。 fileprivate表示代码可以在当前文件中被访问，而不做类型限定。 private表示代码只能在当前作用域或者同一文件中同一类型的作用域中被使用。 这些权限关键词可以修饰，属性，方法和类型。需要注意：当一个类型的某一属性要用public修饰时，该类型至少要用public（或者open）权限的关键词修复。可以理解为数据访问是分层的，我们为了获取某一属性或方法需要先获取该类型，所以外层（类型）的访问权限要满足大于等于内层（类型、方法、属性）权限。 参考：Swift AccessControl static class final原文中final跟权限关键词放在一起了，其实是不合理的，就将其放到这里来讨论。 static静态变量关键词，来源于C语言。 在Swift中常用语以下场景： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 仅用于类名前，表示该类不能被继承。仅支持class类型final class Manager { // 单例的声明 static let shared = Manager() // 实例属性，可被重写 var name: String = \"Ferry\" // 实例属性，不可被重写 final var lastName: String = \"Zhang\" // 类属性，不可被重写 static var address: String = \"Beijing\" // 类属性，可被重写。注意只能作为计算属性，而不能作为存储属性 class var code: String { return \"0122\" } // 实例函数，可被重写 func download() { /* code... */ } // 实例函数，不可被重写 final func download() { /* code... */ } // 类函数，可被重写 class func removeCache() { /* code... */ } // 类函数，不可被重写 static func download() { /* code... */ }}struct Manager { // 单例的声明 static let shared = Manager() // 类属性 static var name: String = \"Ferry\" // 类函数 static func download() { /* code... */ }} struct和enum因为不能被继承，所以也就无法使用class和final关键词，仅能通过static关键词进行限定 mutating inoutmutating用于修饰会改变该类型的函数之前，基本都用于struct对象的修改。看下面例子： 1234567891011121314151617181920212223242526272829303132333435struct Point { var x: CGFloat var y: CGFloat // 因为该方法改变了struct的属性值（x），所以必须要加上mutating mutating func moveRight(offset: CGFloat) { x += offset } func normalSwap(a: CGFloat, b: CGFloat) { let temp = a a = b b = temp } // 将两个值交换，需传入对象地址。注意inout需要加载类型名前 func inoutSwap(a: inout CGFloat, b: inout CGFloat) { let temp = a a = b b = temp }}var location1: CGFloat = 10var location2: CGFloat = -10var point = Point.init(x: 0, y: 0)point.moveRight(offset: location1)print(point) //Point(x: 10.0, y: 0.0)point.normalSwap(a: location1, b: location2)print(location1) //10print(location2) //-10// 注意需带取址符&amp;point.inoutSwap(a: &amp;location1, b: &amp;location2)print(location1) //-10print(location2) //10 inout需要传入取值符，所以它的改变会导致该对象跟着变动。可以再回看上面说的Hashable的一个协议实现： 12345func hash(into hasher: inout Hasher) { hasher.combine(self.red) hasher.combine(self.green) hasher.combine(self.blue)} 只有使用inout才能修改传入的hasher的值。 infix operatorinfix operator即为中缀操作符，还有prefix、postfix后缀操作符。 它的作用是自定义操作符。比如Python里可以用**进行幂运算，但是Swift里面，我们就可以利用自定义操作符来定义一个用**实现的幂运算。 12345678// 定义中缀操作符infix operator **// 实现该操作符的逻辑，中缀需要两个参数func ** (left: Double, right: Double) -&gt; Double { return pow(left, right)}let number = 2 ** 3print(value) //8 同理我们还可以定义前缀和后缀操作符： 1234567891011121314151617181920212223//定义阶乘操作，后缀操作符postfix operator ~!postfix func ~! (value: Int) -&gt; Int { func factorial(_ value: Int) -&gt; Int { if value &lt;= 1 { return 1 } return value * factorial(value - 1) } return factorial(value)}//定义输出操作，前缀操作符prefix operator &lt;&lt;prefix func &lt;&lt; (value: Any) { print(value)}let number1 = 4~!print(number1) // 24&lt;&lt;number1 // 24&lt;&lt;\"zhangferry\" // zhangferry 前缀和后缀仅需要一个操作数，所以只有一个参数即可。 关于操作符的更多内容可以查看这里：Swift Operators。 注意，因为该文章较早，其中对于操作符的一些定义已经改变。 @dynamicMemberLookup，@dynamicCallable这两个关键词我确实没有用过，看到dynamic可以知道这两个特性是为了让Swift具有动态性。 @dynamicMemberLookup中文叫动态查找成员。在使用@dynamicMemberLookup标记了对象后（对象、结构体、枚举、protocol），实现了subscript(dynamicMember member: String)方法后我们就可以访问到对象不存在的属性。如果访问到的属性不存在，就会调用到实现的 subscript(dynamicMember member: String)方法，key 作为 member 传入这个方法。 举个例子： 123456789101112@dynamicMemberLookupstruct Person { subscript(dynamicMember member: String) -&gt; String { let properties = [\"nickname\": \"Zhuo\", \"city\": \"Hangzhou\"] return properties[member, default: \"undefined\"] }}//执行以下代码let p = Person()print(p.city) //Hangzhouprint(p.nickname) //Zhuoprint(p.name) //undefined 我们没有定义Person的city、nickname，name属性，却可以用点语法去尝试访问它。如果没有@dynamicMemberLookup这种写法会被编译器检查出来并报错，但是加了该关键词编译器就不会管它是不是存在都予以通过。 123456789101112131415161718192021222324@dynamicCallablestruct Person { // 实现方法一 func dynamicallyCall(withArguments: [String]) { for item in withArguments { print(item) } } // 实现方法二 func dynamicallyCall(withKeywordArguments: KeyValuePairs&lt;String, String&gt;){ for (key, value) in withKeywordArguments { print(\"\\(key) --- \\(value)\") } }}let p = Person()p(\"zhangsan\")// 等于 p.dynamicallyCall(withArguments: [\"zhangsan\"])p(\"zhangsan\", \"20\", \"男\")// 等于 p.dynamicallyCall(withArguments: [\"zhangsan\", \"20\", \"男\"])p(name: \"zhangsan\")// 等于 p.dynamicallyCall(withKeywordArguments: [\"name\": \"zhangsan\"])p(name: \"zhangsan\", age:\"20\", sex: \"男\")// 等于 p.dynamicallyCall(withKeywordArguments: [\"name\": \"zhangsan\", \"age\": \"20\", \"sex\": \"男\"]) @dynamicCallable可以理解成动态调用，当为某一类型做此声明时，需要实现dynamicallyCall(withArguments:)或者dynamicallyCall(withKeywordArguments:)。编译器将允许你调用并为定义的方法。 一个动态查找成员变量，一个动态方法调用，带上这两个特性Swift就可以变成彻头彻尾的动态语言了。所以作为静态语言的Swift也是可以具有动态特性的。 更多关于这两个动态标记的讨论可以看卓同学的这篇：细说 Swift 4.2 新特性：Dynamic Member Lookup wherewhere一般用作条件限定。它可以用在for-in、swith、do-catch中： 12345678910111213let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]for item in numbers where item % 2 == 1 { print(\"odd: \\(item)\") // 将输出1，3，5，7，9等数}numbers.forEach { (item) in switch item { case let x where x % 2 == 0: print(\"even: \\(x)\") // 将输出2，4，6，8等数 default: break }} where也可以用于类型限定。 我们可以扩展一个字典的merge函数，它可以将两个字典进行合并，对于相同的Key值以要合并的字典为准。并且该方法我只想针对Key和Value都是String类型的字典使用，就可以这么做： 1234567// 这里的Key Value来自于Dictionary中定义的泛型extension Dictionary where Key == String, Value == String { //同一个key操作覆盖旧值 func merge(other: Dictionary) -&gt; Dictionary { return self.merging(other) { _, new in new } }} @autoclosure@autoclosure 是使用在闭包类型之前，做的事情就是把一句表达式自动地封装成一个闭包 (closure)。 比如我们有一个方法接受一个闭包，当闭包执行的结果为 true 的时候进行打印，分别使用普通闭包和加上autoclosure的闭包实现： 1234567891011121314func logIfTrueNormal(predicate: () -&gt; Bool) { if predicate() { print(\"True\") }}// 注意@autoclosure加到闭包的前面func logIfTrueAutoclosure(predicate: @autoclosure () -&gt; Bool) { if predicate() { print(\"True\") }}// 调用方式logIfTrueNormal(predicate: {3 &gt; 1})logIfTrueAutoclosure(predicate: 3 &gt; 1) 编译器会将logIfTrueAutoclosure函数参数中的3 &gt; 1这个表达式转成{3 &gt; 1}这种尾随闭包样式。 那这种写法有什么用处呢？我们可以从一个示例中体会一下，在Swift系统提供的几个短路运算符（即表达式左边如果已经确定结果，右边将不再运算）中均采用了@autoclosure标记的闭包。那??运算符举例，它的实现是这样的： 123456789101112public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; T { switch optional { case .some(let value): return value case .none: return try defaultValue() }}// 使用var name: String? = \"ferry\"let currentName = name ?? getDefaultName() 因为使用了@autoclosure标记闭包，所以??的defaultValue参数我们可以使用表达式，又因为是闭包，所以当name非空时，直接返回了该值，不会调用getDefaultName()函数，减少计算。 参考：@AUTOCLOSURE 和 ??，注意因为Swift版本问题，实例代码无法运行。 @escaping@escaping也是闭包修饰词，用它标记的闭包被称为逃逸闭包，还有一个关键词是@noescape，用它修饰的闭包叫做非逃逸闭包。在Swift3及之后的版本，闭包默认为非逃逸闭包，在这之前默认闭包为逃逸闭包。 这两者的区别主要在于声明周期的不同，当闭包作为参数时，如果其声明周期与函数一致就是非逃逸闭包，如果声明周期大于函数就是逃逸闭包。结合示例来理解： 1234567891011121314// 非逃逸闭包func logIfTrueNormal(predicate: () -&gt; Bool) { if predicate() { print(\"True\") }}// 逃逸闭包func logIfTrueEscaping(predicate: @escaping () -&gt; Bool) { DispatchQueue.main.async { if predicate() { print(\"True\") } }} 第二个函数的闭包为逃逸闭包是因为其是异步调用，在函数退出时，该闭包还存在，声明周期长于函数。 如果你无法判断出应该使用逃逸还是非逃逸闭包，也无需担心，因为编译器会帮你做出判断。第二个函数，如果我们不声明逃逸闭包编译器会报错，警告我们：Escaping closure captures non-escaping parameter 'predicate'。当然我们还是应该理解两者的区别。 四、高阶函数Filter, Map, Reduce, flatmap, compactMap这几个高阶函数都是对数组对象使用的，我们通过示例去了解他们吧： 123456789101112131415161718192021222324252627282930313233343536let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]// filter 过滤let odd = numbers.filter { (number) -&gt; Bool in return number % 2 == 1}print(odd) // [1, 3, 5, 7, 9]//map 转换let maps = odd.map { (number) -&gt; String in return \"\\(number)\"}print(maps) // [\"1\", \"3\", \"5\", \"7\", \"9\"]// reduce 累计运算let result = odd.reduce(0, +)print(result) // 25// flatMap 1.数组展开let numberList = [[1, 2, 3], [4, 5]， [[6]]]let flatMapNumber = numberList.flatMap { (value) in return value}print(flatMapNumber) // [1, 2, 3, 4, 5, [6]]// flatMap 2.过滤数组中的nillet country = [\"cn\", \"us\", nil, \"en\"]let flatMap = country.flatMap { (value) in return value}print(flatMap) //[\"cn\", \"us\", \"en\"]// compactMap 过滤数组中的nillet compactMap = country.compactMap { (value) in return value}print(compactMap) // [\"cn\", \"us\", \"en\"] filter，reduce其实很好理解，map、flatMap、compactMap刚开始接触时确实容易搞混，这个需要多加使用和练习。 注意到flatMap有两种用法，一种是展开数组，将二维数组降为一维数组，一种是过滤数组中的nil。在Swift4.1版本已经将flatMap过滤数组中nil的函数标位deprecated，所以我们过滤数组中nil的操作应该使用compactMap函数。 参考：Swift 烧脑体操（四） - map 和 flatMap 五、几个Swift中的概念柯里化什么意思柯里化指的是从一个多参数函数变成一连串单参数函数的变换，这是实现函数式编程的重要手段，举个例子： 12345678910// 该函数返回类型为（Int） -&gt; Boolfunc greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool { return { number in return number &gt; comparer }}// 定义一个greaterThan10的函数let greaterThan10 = greaterThan(10)greaterThan10(13) // =&gt; truegreaterThan10(9) // =&gt; false 所以柯里化也可以理解为批量生成一系列相似的函数。 参考：柯里化 (CURRYING) POP 与 OOP的区别OOP(object-oriented programming)面向对象编程： 在面向对象编程世界里，一切皆为对象，它的核心思想是继承、封装、多态。 POP(protocol-oriented programming)面向协议编程： 面向协议编程则主要通过协议，又或叫做接口对一系列操作进行定义。面向协议也有继承封装多态，只不过这些不是针对对象建立的。 为什么Swift演变成了一门面向协议的编程语言。这是因为面向对象存在以下几个问题： 1、动态派发的安全性（这应该是OC的困境，在Swift中Xcode是不可能让这种问题编译通过的） 2、横切关注点（Cross-Cutting Concerns）问题。面向对象无法描述两个不同事物具有某个相同特性这一点。 3、菱形问题（比如C++中）。C++可以多继承，在多继承中，两个父类实现了相同的方法，子类无法确定继承哪个父类的此方法，由于多继承的拓扑结构是一个菱形，所以这个问题有被叫做菱形缺陷（Diamond Problem）。 参考文章： Swift 中的面向协议编程：是否优于面向对象编程？ 面向协议编程与 Cocoa 的邂逅 (上) Any 与AnyObject 区别AnyObject： 是一个协议，所有class都遵守该协议，常用语跟OC对象的数据转换。 Any：它可以代表任何型別的类(class)、结构体 (struct)、枚举 (enum)，包括函式和可选型，基本上可以说是任何东西。 rethrows 和 throws 有什么区别呢？throws是处理错误用的，可以看一个往沙盒写入文件的例子： 123456789// 写入的方法定义public func write(to url: URL, options: Data.WritingOptions = []) throws// 调用do { let data = Data() try data.write(to: localUrl)} catch let error { print(error.localizedDescription)} 将一个会有错误抛出的函数末尾加上throws，则该方法调用时需要使用try语句进行调用，用于提示当前函数是有抛错风险的，其中catch句柄是可以忽略的。 rethrows与throws并没有太多不同，它们都是标记了一个方法应该抛出错误。但是 rethrows 一般用在参数中含有可以 throws 的方法的高阶函数中（想一下为什么是高阶函数？下期给出答案）。 查看map的方法声明，我们能同时看到 throws,rethrows： 1@inlinable public func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T] 不知道你们第一次见到map函数本体的时候会不会疑惑，为什么map里的闭包需要抛出错误？为什么我们调用的时候并没有用try语法也可以正常通过？ 其实是这样的，transform是需要我们定义的闭包，它有可能抛出异常，也可能不抛出异常。Swift作为类型安全的语言就需要保证在有异常的时候需要使用try去调用，在没有异常的时候要正常调用，那怎么兼容这两种情况呢，这就是rethrows的作用了。 1234567891011121314151617func squareOf(x: Int) -&gt; Int {return x * x}func divideTenBy(x: Int) throws -&gt; Double { guard x != 0 else { throw CalculationError.DivideByZero } return 10.0 / Double(x)}let theNumbers = [10, 20, 30]let squareResult = theNumbers.map(squareOf(x:)) // [100, 400, 9000]do { let divideResult = try theNumbers.map(divideTenBy(x:))} catch let error { print(error)} 当我们直接写let divideResult = theNumbers.map(divideTenBy(x:))时，编译器会报错：Call can throw but is not marked with 'try'。这样就实现了根据情况去决定是否需要用try-catch去捕获map里的异常了。 参考：错误和异常处理 break return continue fallthough 在语句中的含义（switch、while、for）这个比较简单，只说相对特别的示例吧，在Swift的switch语句，会在每个case结束的时候自动退出该switch判断，如果我们想不退出，继续进行下一个case的判断，可以加上fallthough。","link":"/2020/05/10/swift_advance_1/"},{"title":"iOS面试篇-多线程","text":"iOS面试中多线程绝对是最重要的知识点之一，它在日常开发中会被广泛使用，而且多线程是有很多区分度很高的题目可供考察的。这篇文章会梳理下多线程和GCD相关的概念和几个典型问题。因为GCD相关的API用OC看着更直管一些，所以这期实例就都用OC语言书写。 概念篇在面对一些我们常见的概念时，我们常有种这个东西我熟的感觉，但是如果没有深入研究它们的概念和区别，还是很容易弄混或者讲不清楚的。所以这里单独抽一节讲下多线程中的概念。 进程，线程，任务，队列进程：资源分配的最小单位。在iOS中一个应用的启动就是开启了一个进程。 线程：CPU调度的最小单位。一个进程里会有多个线程。 大家可以思考下，进程和线程为什么是从资源分配和CPU调度层面进行定义的。 任务：每次执行的一段代码，比如下载一张图片，触发一个网络请求。 队列：队列是用来组织任务的，一个队列包含多个任务。 GCDGCD（Grand Central Dispatch）是异步执行任务的技术之一。开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程执行该任务。这里的线程管理是由系统处理的，我们不必关心线程的创建销毁，这大大方便了我们的开发效率。也可以说GCD是一种简化线程操作的多线程使用技术方案。 安卓没有跟GCD完全相同的一套技术方案的，虽然它可以处理GCD实现的一系列效果。 串行，并行，并发GCD的使用都是通过调度队列（Dispatch Queue）的形式进行的，调度队列有以下 几种形式： 串行（serial）：多任务中某时刻只能有一个任务被运行； 并行（parallel）：相对于串行，某时刻有多个任务同时被执行，需要多核能力； 并发（concurrent）：引入时间片和抢占之后才有了并发的说法，某个时间片只有一个任务在执行，执行完时间片后进行资源抢占，到下一个任务去执行，即“微观串行，宏观并发”，所以这种情况下只有一个空闲的某核，多核空闲就又可以实现并行运行了； 我们常用的调度队列有以下几种： 12345678// 串行队列dispatch_queue_t serialQueue = dispatch_queue_create(\"com.gcd.serialQueue\", DISPATCH_QUEUE_SERIAL);// 并发队列dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.gcd.concurrentQueue\", DISPATCH_QUEUE_CONCURRENT);// 全局并发队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 主队列let mainQueue = DispatchQueue.main 注意GCD创建的是并发队列而不是并行队列。但这里的并发队列是一个相对宽泛的定义，它包含并行的概念，GCD作为一个智能的中心调度系统会根据系统情况判断当前能否使用多核能力分摊多个任务，如果满足的话此时就是在并行的执行队列中的任务。 同步，异步 同步：函数会阻塞当前线程直到任务完成返回才能进行其它操作； 异步：在任务执行完成之前先将函数值返回，不会阻塞当前线程； 串行、并发和同步、异步相互结合能否开启新线程 串行队列 并发队列 主队列 同步 不开启新线程 不开启新线程 不开启新线程 异步 开启新线程 开启新线程 不开启新线程 主线程和主队列主线程是一个线程，主队列是指主线程上的任务组织形式。 主队列只会在主线程执行，但主线程上执行的不一定就是主队列，还有可能是别的同步队列。因为前说过，同步操作不会开辟新的线程，所以当你自定义一个同步的串行或者并行队列时都是还在主线程执行。 判断当前是否是主线程： 1BOOL isMainThread = [NSThread isMainThread]; 判断当前是否在主队列上： 123static void *mainQueueKey = \"mainQueueKey\";dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, &amp;mainQueueKey, NULL);BOOL isMainQueue = dispatch_get_specific(mainQueueKey)); 队列与线程的关系 队列是对任务的描述，它可以包含多个任务，这是应用层的一种描述。线程是系统级的调度单位，它是更底层的描述。一个队列（并行队列）的多个任务可能会被分配到多个线程执行。 问题代码分析1、分析下面代码的执行逻辑 123456789101112- (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. [self syncMainTask];}- (void)syncMainTask { dispatch_queue_main_t mainQueue = dispatch_get_main_queue(); dispatch_sync(mainQueue, ^{ NSLog(@\"main queue task\"); });} 这段代码会输出task1，然后发生死锁，导致crash。 追加问题一：为什么会死锁？死锁就会导致crash？ 我们先分析crash的情况，正常死锁应该就是卡死的情况，不应该导致carsh。那为什么会carsh呢，看崩溃信息： 是一个EXC_BAD_INSTRUCTION类型的crash，执行了一个出错的命令。 然后看__DISPATCH_WAIT_FOR_QUEUE__的调用栈信息： 右侧汇编代码给出了更详细的crash信息：BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread。 在当前线程已经拥有的队列中执行dispatch_sync同步操作会导致crash。 在libdispatch的源码中我们可以找到该函数的定义： 123456789101112DISPATCH_NOINLINEstatic void__DISPATCH_WAIT_FOR_QUEUE__(dispatch_sync_context_t dsc, dispatch_queue_t dq){ uint64_t dq_state = _dispatch_wait_prepare(dq); if (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) { DISPATCH_CLIENT_CRASH((uintptr_t)dq_state, \"dispatch_sync called on queue \" \"already owned by current thread\"); } /*...*/} 所以我们知道了，这个carsh是libdispatch内部抛出的，当它检测到可能发生死锁时，就直接触发崩溃，事实上它不能完全判断出所有死锁的情况。 我们分析这里为什么会发生死锁。首先syncMainTask就是在主队列中的，我们在主队列先添加dispatch_sync然后再添加其内部的block。主队列FIFO，只有sync执行完了才会执行内部的block，而此时是一个同步队列，block执行完才会退出sync，所以导致了死锁。 对于死锁的解释我也查了好几篇文章，有些说法其实是经不起推敲的，这个解释是我认为相对合理的。 附一篇参考文章：GCD死锁 引出问题二：什么情况下会发生死锁？ GCD中发生死锁需要满足两个条件： 同步执行串行队列 执行sync的队列和block所在队列为同一个队列 引出问题三：如何避免死锁？这段代码应该如何修改？ 根据上面提到的条件，我们可以将任务异步执行，或者换成一个并发队列。另外将block放到一个非主队列里执行也是可以的。 2、分析一下代码执行结果 12345678int a = 0;dispatch_queue_t queue = dispatch_get_global_queue(0, 0);while (a &lt; 2) { dispatch_async(queue, ^{ a++; });}NSLog(@\"a = %d\", a); 首先该段代码会编译不过，编译器检测到变量a被block截获，并尝试修改就报以下错误： Variable is not assignable (missing __block type specifier)。如果我们要在block里对外界变量重新复制，需要添加__block的声明：__block int a = 0; 我们分析这段代码，在开始while之后加入一个异步任务，再之后呢，这个是不确定了，可能是执行a++也可能是因不满足退出条件再次执行加入异步任务，直到满足a&lt;2才会退出while循环。那输出结果也就是不确定了，因为可能在判断跳出循环和输出结果的时候另外的线程又执行了一次a++。 再扩展下，如果将那个并发队列改成主队列，执行逻辑还是一样的吗？ 首先主队列是不会开启新线程的，主队列上的异步操作执行时机是等别的任务都执行完了，再来执行添加的a++。显然在while循环里，主队列既有任务还未执行完毕，所以就不会执行a++，也就导致while循环不会退出，形成死循环。 其它问题什么是线程安全，为什么UI操作必须在主线程执行线程安全：当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。 为什么UI操作必须放到主线程：首先UIKit不是线程安全的，多线程访问会导致UI效果不可预期，所以我们不能使用多个线程去处理UI。那既然要单线程处理UI为什么是在主线程呢，这是因为UIApplication作为程序的起点是在主线程初始化的，所以我们后续的UI操作也都要放到主线程处理。 关于这个问题展开讨论可以参阅这篇文章：iOS拾遗——为什么必须在主线程操作UI ###开启新的线程有哪些方法 1、NSThread 2、NSOperationQueue 3、GCD 4、NSObject的performSelectorInBackground方法 5、pthread 多线程任务要实现顺序执行有哪些方法1、dispatch_group 2、dispatch_barrier 3、dispatch_semaphore_t 4、NSOperation的addDependency方法 如何实现一个多读单写的功能？多读单写的意思就是可以有多个线程同时参与读取数据，但是写数据时不能有读操作的参与切只有一个线程在写数据。 我们写一个示例程序，看下在不做限制的多读多写程序中会发生什么。 1234567891011121314151617181920212223242526272829303132// 计数器self.count = 0;// 并发队列self.concurrentQueue = dispatch_get_global_queue(0, 0);for (int i = 0; i&lt; 10; i++) { dispatch_async(self.concurrentQueue, ^{ [self read]; }); dispatch_async(self.concurrentQueue, ^{ [self write]; });}// 读写操作- (void)read { NSLog(@\"read---- %d\", self.count);}- (void)write { self.count += 1; NSLog(@\"write---- %d\", self.count);}// 输出内容2020-07-18 11:47:03.612175+0800 GCD_OC[76121:1709312] read---- 02020-07-18 11:47:03.612273+0800 GCD_OC[76121:1709311] read---- 12020-07-18 11:47:03.612230+0800 GCD_OC[76121:1709314] write---- 12020-07-18 11:47:03.612866+0800 GCD_OC[76121:1709312] write---- 22020-07-18 11:47:03.612986+0800 GCD_OC[76121:1709311] write---- 32020-07-18 11:47:03.612919+0800 GCD_OC[76121:1709314] read---- 22020-07-18 11:47:03.613252+0800 GCD_OC[76121:1709312] read---- 32020-07-18 11:47:03.613346+0800 GCD_OC[76121:1709314] write---- 42020-07-18 11:47:03.613423+0800 GCD_OC[76121:1709311] read---- 4 每次运行的输出结果都会不一样，根据这个输出内容，我们可以看到在还没有执行到输出write—-1的时候，就已经执行了read—-1，在write—- 3之后 read的结果却是2。这绝对是我们所不期望的。其实在程序设计中我们是不应该设计出多读多写这种行为，因为这个结果是不可控。 解决方案之一是对读写操作都加上锁做成单独单写，这样是没问题但有些浪费性能，正常写操作确定之后结果就确定了，读的操作可以多线程同时进行，而不需要等别的线程读完它才能读，所以有了多读单写的需求。 解决多读单写常见有两种方案，第一种是使用读写锁pthread_rwlock_t。 读写锁具有一些几个特性： 同一时间，只能有一个线程进行写的操作 同一时间，允许有多个线程进行读的操作。 同一时间，不允许既有写的操作，又有读的操作。 这跟我们的多读单写需求完美吻合，也可以说读写锁的设计就是为了实现这一需求的。它的实现方式如下： 1234567891011121314151617181920212223242526// 执行读写操作之前需要定义一个读写锁@property (nonatomic,assign) pthread_rwlock_t lock;pthread_rwlock_init(&amp;_lock,NULL);// 读写操作- (void)read { pthread_rwlock_rdlock(&amp;_lock); NSLog(@\"read---- %d\", self.count); pthread_rwlock_unlock(&amp;_lock);}- (void)write { pthread_rwlock_wrlock(&amp;_lock); _count += 1; NSLog(@\"write---- %d\", self.count); pthread_rwlock_unlock(&amp;_lock);}// 输出内容2020-07-18 12:00:29.363875+0800 GCD_OC[77172:1722472] read---- 02020-07-18 12:00:29.363875+0800 GCD_OC[77172:1722471] read---- 02020-07-18 12:00:29.364195+0800 GCD_OC[77172:1722469] write---- 12020-07-18 12:00:29.364325+0800 GCD_OC[77172:1722472] write---- 22020-07-18 12:00:29.364450+0800 GCD_OC[77172:1722470] read---- 22020-07-18 12:00:29.364597+0800 GCD_OC[77172:1722471] write---- 32020-07-18 12:00:29.366490+0800 GCD_OC[77172:1722469] read---- 32020-07-18 12:00:29.366703+0800 GCD_OC[77172:1722472] write---- 42020-07-18 12:00:29.366892+0800 GCD_OC[77172:1722489] read---- 4 我们查看输出日志，所以的读操作结果都是最近一次写操作所赋的值，这是符合我们预期的。 还有一种实现多读单写的方案是使用GCD中的栅栏函数dispatch_barrier。栅栏函数的目的就是保证在同一队列中它之前的操作全部执行完毕再执行后面的操作。为了保证写操作的互斥行，我们要对写操作执行「栅栏」： 123456789101112131415// 我们定义一个用于读写的并发对列self.rwQueue = dispatch_queue_create(\"com.rw.queue\", DISPATCH_QUEUE_CONCURRENT);- (void)read { dispatch_sync(self.rwQueue, ^{ NSLog(@\"read---- %d\", self.count); });}- (void)write { dispatch_barrier_async(self.rwQueue, ^{ self.count += 1; NSLog(@\"write---- %d\", self.count); });} 这个输出结果跟读写锁实现是一样的，也是符合预期的。 这里多说几句，这里的读和写分别使用sync和async。读操作要用同步是为了阻塞线程尽快返回结果，不用担心无法实现多读，因为我们使用了并发队列，是可以实现多读的。至于写操作使用异步的栅栏函数，是为了写时不阻塞线程，通过栅栏函数实现单写。如果我们将读写都改成sync或者async，由于栅栏函数的机制是会顺序先读后写。如果反过来，读操作异步，写操作同步也是可以达到多读单写的目的的，但读的时候不立即返回结果，网上有人说只能使用异步方式，防止发生死锁，这个说法其实不对，因为同步队列是不会发生死锁的。 用GCD如何实现一个控制最大并发数且执行任务FIFO的功能？这个相对简单，通过信号量实现并发数的控制，通过并发队列实现任务的FIFO的执行 12345678int maxConcurrent = 3;dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_semaphore_t semaphore = dispatch_semaphore_create(maxConcurrent);dispatch_async(queue, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // task dispatch_semaphore_signal(semaphore);});","link":"/2020/07/19/interview-multithreading/"},{"title":"iOS面试篇","text":"计算机网络是计算机科学与技术专业的必修课，也是移动端，前端，后端都会涉及到的知识点，同时它也是iOS面试中大概率会出现的问题。所以准备面试的话，网络相关的知识点一定不能错过。这里总结了一些我认为有用的和最近面试遇到的网络相关知识点。 去年写过一篇《图解TCP/IP》总结的文章，也可以对着看下。 计算机网络是如何分层的网络有两种分层模型，一种是ISO（国际标准化组织）制定的OSI（Open System Interconnect）模型，它将网络分为七层。一种是TCP/IP的四层网络模型。OSI是一种学术上的国际标准，理想概念，TCP/IP是事实上的国际标准，被广泛应用于现实生活中。两者的关系可以看这个图： 注：也有说五层模型的，它跟四层模型的区别就是，在OSI模型中的数据链路层和物理层，前者将其作为两层，后者将其合并为一层称为网络接口层。一般作为面试题的话都是需要讲出OSI七层模型的。 各个层的含义以及它们之间的关系可以看这张图： Http协议http协议特性 HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无状态：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。 请求方法 GET：请求获取Request-URI标识的资源，请求参数附加在url上，明文展示。 POST：在Request-URI所标识的资源后附加新的数据，常用于修改服务器资源或者提交资源到服务器。POST请求体是放到body中的，可以指定编码方式，更加安全。 HEAD：请求获取由Request-URI所标识的资源的响应消息报头。 PUT：请求服务器存储一个资源，并用Request-URI作为其标识。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断。 OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求。 请求和响应报文以该链接为例：https://zhangferry.com/2019/08/31/diagram_tcpip_concepts/ 在Chrome查看其请求的Headers信息。 General 这里标记了请求的URL，请求方法为GET。状态码为304，代表文件未修改，可以直接使用缓存的文件。远程地址为185.199.111.153:443，此IP为Github 服务器地址，是因为我的博客是部署在GitHub上的。 除了304还有别的状态码，分别是： 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 Response Headers： content-encoding：用于指定压缩算法 content-length：资源的大小，以十进制字节数表示。 content-type：指示资源的媒体类型。图中所示内容类型为html的文本类型，文字编码方式为utf-8 last-modified：上次内容修改的日期，为6月8号 status：304 文件未修改状态码 注：其中content-type在响应头中代表，需要解析的格式。在请求头中代表上传到服务器的内容格式。 Request Headers： :method：GET请求 :path：url路径 :scheme：https请求 accept：通知服务器可以返回的数据类型。 accept-encoding：编码算法，通常是压缩算法，可用于发送回的资源 accept-language：通知服务器预期发送回的语言类型。这是一个提示，并不一定由用户完全控制:服务器应该始终注意不要覆盖用户的显式选择(比如从下拉列表中选择语言)。 cookie：浏览器cookie user-agent：用户代理，标记系统和浏览器内核 更多请求头的字段含义可以参考这里：HTTP headers TCP三次握手和四次挥手的过程以及为什么要有三次和四次在了解TCP握手之前我们先看下TCP的报文样式： 其中控制位（Control Flag）标记着握手阶段的各个状态。 TCP三次握手示意图如下： 三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送3个数据包。 1、第一次握手（SYN=1, seq=x） 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 2、第二次握手（SYN=1, ACK=1, seq=y, ACKnum=x+1） 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 3、第三次握手（ACK=1, ACKnum=y+1） 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 问题一：为什么需要三次握手呢？ 在谢希仁著的《计算机网络》里说，『为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误』。怎么理解呢，我们假设一种情况，有一个建立连接的第一次握手的报文段因为滞留到网络中过了较长时间才发送到服务端。这时服务器是要做ACK应答的，如果只有两次握手就代表连接建立，那服务器此时就要等待客户端发送建立连接之后的数据。而这只是一个因滞留而废弃的请求，是不是白白浪费了很多服务器资源。 从另一个角度看这个问题，TCP是全双工的通信模式，需要保证两端都已经建立可靠有效的连接。在三次握手过程中，我们可以确认的状态是： 第一次握手：服务器确认自己接收OK，服务端确认客户端发送OK。 第二次握手：客户端确认自己发送OK，客户端确认自己接收OK，客户端确认服务器发送OK，客户端确认服务器接收OK。 第三次握手：服务器确认自己发送OK，服务器确认客户端接收OK。 只有握手三次才能达到全双工的目的：确认自己和对方都能够接收和发送消息。 TCP四次挥手示意图如下： 四次挥手表示要发送四个包，挥手的目的是断开连接。 1、第一次挥手（FIN=1, seq=x） 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 2、第二次挥手（ACK=1，ACKnum=x+1） 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 3、第三次挥手（FIN=1，seq=y） 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 4、第四次挥手（ACK=1，ACKnum=y+1） 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 问题一：为什么挥手需要四次呢？为什么不能将ACK和FIN报文一起发送？ 当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端『你发的FIN我收到了』。只有等到服务端所有的报文都发送完了，才能发FIN报文，所以要将ACK和FIN分开发送，这就导致需要四次挥手。 问题二：为什么TIMED_WAIT之后要等2MSL才进入CLOSED状态？ MSL是TCP报文的最大生命周期，因为TIME_WAIT持续在2MSL就可以保证在两个传输方向上的尚未接收到或者迟到的报文段已经消失，同时也是在理论上保证最后一个报文可靠到达。假设最后一个ACK丢失，那么服务器会再重发一个FIN，这是虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK。 ###HTTPS的流程 HTTPS = HTTP + TLS/SSL，它的建立可以用以下示意图表示： 1、客户端首次请求服务器，告诉服务器自己支持的协议版本，支持的加密算法及压缩算法，并生成一个随机数（client random）告知服务器。 2、服务器确认双方使用的加密方法，并返回给客户端证书以及一个服务器生成的随机数（server random） 3、客户端收到证书后，首先验证证书的有效性，然后生成一个新的随机数（premaster secret），并使用数字证书中的公钥，加密这个随机数，发送给服务器。 4、服务器接收到加密后的随机数后，使用私钥进行解密，获取这个随机数（premaster secret 5、服务器和客户端根据约定的加密方法，使用前面的三个随机数（client random, server random, premaster secret），生成『对话密钥』（session key），用来加密接下来的整个对话过程（对称加密）。 有一篇由浅入深介绍HTTPS的文章可以阅读一下：看图学HTTPS 问题一：为什么握手过程需要三个随机数，而且安全性只取决于第三个随机数？ 前两个随机数是明文传输，存在被拦截的风险，第三个随机数是通过证书公钥加密的，只有它是经过加密的，所以它保证了整个流程的安全性。前两个随机数的目的是为了保证最终对话密钥的『更加随机性』。 问题二：Charles如何实现HTTPS的拦截？ Charles要实现对https的拦截，需要在客户端安装Charles的证书并信任它，然后Charles扮演中间人，在客户端面前充当服务器，在服务器面前充当客户端。 问题三：为什么有些HTTPS请求（例如微信）抓包结果仍是加密的，如何实现的？ 我在聊天过程中并没有抓到会话的请求，在小程序启动的时候到是抓到了一个加密内容。我手动触发该链接会下载一个加密文件，我猜测这种加密是内容层面的加密，它的解密是由客户端完成的，而不是在HTTPS建立过程完成的。 另外在研究这个问题的过程中，又发现了一些有趣的问题： 1、图中所示的三个https请求分别对应三个不同类型的图标，它们分别代表什么意思呢？ 感谢iOS憨憨的回答。 第一个图标含义是HTTP/2.0，第二个图标含义是HTTP/1.1，第三个图标加锁是因为我用charles只抓取了443端口的请求，该请求端口为5228，所以不可访问。 2、第三个请求https://mtalk.google.com:5228图标和请求内容都加了锁，这个加锁是在https之上又加了一层锁吗？ 这些问题暂时没有确切的答案，希望了解的小伙伴告知一下哈。 DNS解析流程DNS（Domain name system）域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户通过域名访问到对应的服务器（IP地址）。具体的解析流程是这样的： 1、浏览器中输入想要访问的网站域名，操作系统会检查本地hosts文件是否有这个网址的映射关系，如果有就调用这个IP地址映射，完成域名解析。没有的话就走第二步。 2、客户端回向本地DNS服务器发起查询，如果本地DNS服务器收到请求，并可以在本地配置区域资源中查到该域名，就将对应结果返回为给客户端。如果没有就走第三步。 3、根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。 其中递归查询和迭代查询可以用如下两图表示。 递归查询如图所示，递归查询是由DNS服务器一级一级查询传递的。 迭代查询如果所示，迭代查询是找到指定DNS服务器，由客户端发起查询。 DNS劫持DNS劫持发生在DNS服务器上，当客户端请求解析域名时将其导向错误的服务器（IP）地址。 常见的解决办法是使用自己的解析服务器或者是将域名以IP地址的方式发出去以绕过DNS解析。 Cookie和Session的区别HTTP 是无状态协议，说明它不能以状态来区分和管理请求和响应。也就是说，服务器单从网络连接上无从知道客户身份。 可是怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。 Cookie：Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在本地机器上存储的一小段文本，并随着每次请求发送到服务器。Cookie技术通过请求和响应报文中写入Cookie信息来控制客户端的状态。 Session：Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。当有用户请求创建一个session时，服务器会先检查这个客户端里是否已经包含了一个Session标识（session id），如果有就通过session id把session检索出来。如果没有就创建一个对应此Session的session id。这个session id会在本次响应中返回给客户端。 两者有以下区别： 1、存储位置：Cookie存放在客户端上，Session数据存放在服务器上。 2、Session 的运行依赖 session id，而 session id 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie ，同时 Session 也会失效 3、安全性：Cookie存在浏览器中，可能会被一些程序复制，篡改；而Session存在服务器相对安全很多。 4、性能：Session会在一定时间内保存在服务器上，当访问增多，会对服务器造成一定的压力。考虑到减轻服务器压力，应当使用Cookie CDNCDN（Content Delivery Network），根本作用是将网站的内容发布到最接近用户的网络『边缘』，以提高用户访问速度。概括的来说：CDN = 镜像（Mirror） + 缓存（Cache） + 整体负载均衡（GSLB）。 目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。 CDN工作流程一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。 参考：深入理解Http请求、DNS劫持与解析 Socketsocket位于应用层和传输层之间： 它的作用是为了应用层能够更方便的将数据经由传输层来传输。所以它的本质就是对TCP/IP的封装，然后应用程序直接调用socket API即可进行通信。上文中说的三次握手和四次挥手即是通过socket完成的。 我们可以从iOS中网络库分层找到BSD Sockets，它是位于CFNetwork之下。在CFNetwork中还有一个CFSocket，推测是对BSD Sockets的封装。 WebRTCWebRTC是一个可以用在视频聊天，音频聊天或P2P文件分享等Web App中的 API。借助WebRTC，你可以在基于开放标准的应用程序中添加实时通信功能。它支持在同级之间发送视频，语音和通用数据，从而使开发人员能够构建功能强大的语音和视频通信解决方案。该技术可在所有现代浏览器以及所有主要平台的本机客户端上使用。WebRTC项目是开源的，并得到Apple，Google，Microsoft和Mozilla等的支持。 如果某一请求只在某一地特定时刻失败率较高，会有哪些原因这个是某公司二面时的问题，是一个开放性问题，我总结了以下几点可能： 1、该时刻请求量过大 2、该地的网络节点较不稳定 3、用户行为习惯，比如该时刻为上班高峰期，或者某个群体的特定习惯 如果有对网络方面比较熟悉的小伙伴也可以补充。","link":"/2020/06/30/interview-network/"}],"tags":[{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"程序员","slug":"程序员","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"蓝牙","slug":"蓝牙","link":"/tags/%E8%93%9D%E7%89%99/"},{"name":"ANCS","slug":"ANCS","link":"/tags/ANCS/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"工作","slug":"工作","link":"/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"招聘","slug":"招聘","link":"/tags/%E6%8B%9B%E8%81%98/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Hybrid","slug":"Hybrid","link":"/tags/Hybrid/"},{"name":"阅读","slug":"阅读","link":"/tags/%E9%98%85%E8%AF%BB/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"月报","slug":"月报","link":"/tags/%E6%9C%88%E6%8A%A5/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"AVPlayer","slug":"AVPlayer","link":"/tags/AVPlayer/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"DFU","slug":"DFU","link":"/tags/DFU/"},{"name":"Cocoapods","slug":"Cocoapods","link":"/tags/Cocoapods/"},{"name":"Notification","slug":"Notification","link":"/tags/Notification/"},{"name":"静态分析","slug":"静态分析","link":"/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"},{"name":"敏捷开发","slug":"敏捷开发","link":"/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"},{"name":"本地化","slug":"本地化","link":"/tags/%E6%9C%AC%E5%9C%B0%E5%8C%96/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"}],"categories":[{"name":"蓝牙总结","slug":"蓝牙总结","link":"/categories/%E8%93%9D%E7%89%99%E6%80%BB%E7%BB%93/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"iOS知识点","slug":"iOS知识点","link":"/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"}]}