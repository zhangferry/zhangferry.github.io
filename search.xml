<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>快手iOS面经</title>
    <url>/2020/03/28/interview_kuaishou/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>过完年来北京之后，有准备看看机会，也是想了解下市场行情。简历没有投太多，只定向投了头条教育部门、抖音、快手、阿里，这些公司。头条和阿里的简历都没过，肯定是亮点太少吧。只有快手简历过了，快手是三轮技术面+一轮HR面，前两轮技术都比较顺利，到第三轮却栽了，很痛心o(╥﹏╥)o。目前就不考虑换工作了，等下半年再说了，接下来的时间再好好精炼一下。</p>
<p>快手是视频面试，不支持周末，但是可以选择晚上时间，我这几次都是定在了晚上九点。视频面试是通过牛客网进行的，以下是我还记得下来的各轮面试题，对于一些iOS基础知识就不做解答了。</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>1、用递归写一个算法，计算从1到100的和。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(value: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> number = value</span><br><span class="line">    <span class="keyword">return</span> value + sum(value: number - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算过程</span></span><br><span class="line"><span class="keyword">let</span> result = sum(value: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>写完算法之后又围绕着问了几个问题，都是算法基础：</p>
<ul>
<li>算法的时间复杂度是多少</li>
<li>递归会有什么缺点</li>
<li>不用递归能否实现，复杂度能否降到O(1)</li>
</ul>
<p>2、<code>property</code>的作用是什么，有哪些关键词，分别是什么含义？</p>
<p>3、父类的<code>property</code>是如何查找的？</p>
<p>4、<code>NSArray</code>、<code>NSDictionary</code>应该如何选关键词？</p>
<p>5、<code>copy</code>和<code>muteCopy</code>有什么区别，深复制和浅复制是什么意思，如何实现深复制？</p>
<p>6、用<code>runtime</code>做过什么事情？<code>runtime</code>中的方法交换是如何实现的？</p>
<p>7、讲一下对KVC合KVO的了解，KVC是否会调用<code>setter</code>方法？</p>
<p>8、<code>__block</code>有什么作用</p>
<p>9、说一下对GCD的了解，它有那些方法，分别是做什么用的？</p>
<p>10、对二叉树是否了解？</p>
<p>面试官是想接着问这方面的问题的。我当时说了不了解，然后就没有后续了。</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>1、ARC和MRC的区别，iOS是如何管理引用计数的，什么情况下引用计数加1什么情况引用计数减一？</p>
<p>2、在MRC下执行<code>[object autorelease]</code>会发生什么，<code>autorelease</code>是如何实现的？</p>
<p>3、OC如何实现多继承？</p>
<p>这个当时没有答好。其实借助于消息转发，<code>protocol</code>和类别都可以间接实现多继承。</p>
<p>4、对设计模式有什么了解，讲一下其中一种是如何使用的。</p>
<p>5、有没有哪个开源库让你用的很舒服，讲一下让你舒服的地方。</p>
<p>6、一张100*100，RGBA的png图像解压之后占多大内存空间。</p>
<p>5、算法题</p>
<p>题目：给定一个个数字arr，判断数组arr中是否所有的数字都只出现过一次。</p>
<p>这个并没有要求写出来，说是提供思路就行了。我当时给的方案是在便利数组的时候，用一个字典把便利的元素存起来，如果在后面的便利过程中新元素在字典中存在过就说明，有重复数字出现。时间复杂度是O(n)。</p>
<p>当时也问了有没有办法进行优化，我当时想到了将数组转成<code>Set</code>，然后和原数组比较，两个集合的数量是否变化。</p>
<p>7、因为我跟他介绍自己Swift用的多一些，然后问了些Swift跟OC的区别，各自的优缺点。</p>
<p>8、为什么离职，有什么职业规划。</p>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>1、给定一个Int型数组，用里面的元素组成一个最大数，因为数字可能非常大，用字符串输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: 9534330</span><br></pre></td></tr></table></figure>

<p>这个是leetcode的<a href="https://leetcode-cn.com/problems/largest-number/">179题</a>，难度中等。面试官让先说思路，再去做题。事先说一下这个题我没有做过。当时的思路是用冒泡法进行排序，排序的前提是将较少位数的数字进行循环补齐，例如3和30的比较，变成33和30的比较，34和4的比较变成34和44的比较，然后将结果从大到小整合成字符串输出。</p>
<p>但是做题是却发现没那么简单，位数的补齐对于2位和3位数的比较还需要求位数的最小公倍数，将他们都转成6位数才能比较。在挣扎了5分钟做了就做罢了。</p>
<p>后来再去做这道题，其实这就是一个排序而已，只不过他的规则是按高位优先级更高的原则，而这一点跟字符串的比较保持一致，如果再加一些Swift的高阶函数，就可以写成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">sort</span> = nums.<span class="built_in">map</span> &#123;<span class="string">"\($0)"</span>&#125;.sorted &#123; (lStr, rStr) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> lStr + rStr &gt; rStr + lStr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">sort</span>.joined()</span><br><span class="line">    <span class="keyword">if</span> result.<span class="keyword">prefix</span>(<span class="number">1</span>) == <span class="string">"0"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200328114843.png" alt=""></p>
<p>2、项目中有这么一个方法<code>func findfile(dir: String suffix: String) -&gt; [String]</code> ，可以通过输入文件夹目录，和后缀检索出所需的文件。</p>
<p>例如需要在某个文件中检索txt文件或者mp4文件，那就传入dir和suffix就行了。现在又有一些需求，例如需要检索utf8格式的txt或者h264编码的mp4，也会有一些例如查找最近一周更新过的文件这样的需求，你如何优化这个类，让它满足这些情况？</p>
<p>我首先想到的是这么多需求不可能一个方法就完成，需要根据不同场景拆出不同的方法，但是这些同属于文件操作，会有一个共同使用的方法就是检索文件。这个方法需要传入文件目录，然后递归的返回当前目录所有文件路径。外部不同场景的调用逻辑就用一个<code>enum</code>完成，不同值对应相同范围的不同种类。</p>
<p>面试官比较关注内部共用的文件检索怎么写，他说子文件如果过多怎么办，如何优化。我有点懵，查找文件至少是要遍历一遍的，子文件过多，这个应该是没法优化的啊。中间卡了一段时间，后来他给了提示说是不是可以用block实现，将文件路径返回出去，由外部决定当前文件是否可用，最终外部的调用类是这个样子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我的方案</span></span><br><span class="line"><span class="comment">//func findDir(_ dir: String) -&gt; [String]</span></span><br><span class="line"><span class="comment">//block方案</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDir</span><span class="params">(<span class="number">_</span> dir: String, block: <span class="params">(<span class="params">(String)</span></span></span></span> -&gt; <span class="type">Bool</span>))</span><br></pre></td></tr></table></figure>

<p>我想来确实没毛病，用block返回内容至少不会将该目录的所有文件都由一个对象持有，而前面一堆的铺垫其实也都是为验证block方案的好处。</p>
<p>其实事后想下这个问题没啥难的，这种写法自己也有写过，但当时就是没想起来，可能前面一圈的铺垫给我带偏了吧，说亏也不亏，以后多多努力吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来看，快手的面试题跟我在别处看到的iOS面试题对比要简单些，一面主要是基础知识，二面考察更全面一些，更多让自己谈一些对技术的理解，三面则是更偏实践一些。</p>
<p>算法虽然三轮都有，但相对比较简单，即使写不出来，有思路也是可以的。当然写出来肯定是加分项，所以大家准备面试时，应该都看一下。算法相关的，排序，数组，二叉树，这几类是重点。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime内存模型探究</title>
    <url>/2020/02/23/runtime_objc_class/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/laptop-2838917_1280.jpg" alt=""></p>
<blockquote>
<p>Objective-C是一种通用、高级、面向对象的编程语言。它扩展了标准的ANSI C编程语言，将Smalltalk式的消息传递机制加入到ANSI C中。</p>
</blockquote>
<p>可以这么理解，Objective-C = C + Runtime，Runtime是将C语言具有面向对象功能的推动剂，是iOS开发中的核心概念。我们可以在苹果开源的 <a href="https://opensource.apple.com/tarballs/objc4/">runtime</a>（当前的最新版本objc4-779.1.tar.gz）中可以发现一些 Objective-C 对象模型的实现细节。</p>
<a id="more"></a>

<h2 id="NSObject的实现"><a href="#NSObject的实现" class="headerlink" title="NSObject的实现"></a>NSObject的实现</h2><p>OC中几乎所有的类都继承自<code>NSObject</code>，OC的动态性也是通过NSObject实现的，那就从NSObject开始探索。</p>
<p>在<code>runtime</code>源码中的<code>NSObject.h</code>中，我们可以找到<code>NSObject</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>NSObject</code>里有一个指向<code>Class</code>的<code>isa</code>，其中对于Class的定义在<code>objc.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_class</code>代表类对象，<code>objc_object</code>代表实例对象，<code>objc_object</code>的<code>isa</code>指向<code>objc_class</code>。<br>这里可以得出一个结论，实例对象的isa是指向类（类对象）的。其实类（objc_class）也有一个isa属性，那它指向什么呢？</p>
<h3 id="Meta-Class（元类）"><a href="#Meta-Class（元类）" class="headerlink" title="Meta Class（元类）"></a>Meta Class（元类）</h3><p>这里runtime为了设计上的统一性，引入了元类（meta class）的概念。</p>
<p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p>
<p><code>objc_class</code>的isa指向meta class，甚至meta class也有isa指针，它指向根元类（root meta class）。实例对象，类对象，元类和根元类的关系如下图所示：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200223121419.png" alt=""></p>
<p>类和元类形成了一个完整的闭环，其中有两条关系需要注意：</p>
<ul>
<li>元类的isa均指向根元类，根元类指向自己</li>
<li>根元类继承根类（NSObject）</li>
</ul>
<h2 id="ObjectiveC1-0数据模型"><a href="#ObjectiveC1-0数据模型" class="headerlink" title="ObjectiveC1.0数据模型"></a>ObjectiveC1.0数据模型</h2><p>我们可以在<code>runtime.h</code>中查看<code>objc_class</code>的定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">&#x2F;* Use &#96;Class&#96; instead of &#96;struct objc_class *&#96; *&#x2F;</span><br></pre></td></tr></table></figure>
<p>注意这两个宏命令：<code>!__OBJC2__</code>和<code>OBJC2_UNAVAILABLE</code>，他们均是为了提示当前的<code>objc_class</code>结构是Objc2之前的结构设计，即Objc1.0的设计。</p>
<p>从这个<code>objc_class</code>的定义我们可以看出它包含了超类的指针(<code>super_class</code>)，类名(<code>name</code>)，实例大小(<code>instance_size</code>)，<code>objc_ivar_list</code>成员变量列表的指针(<code>ivars</code>)，指向<code>objc_method_list</code><strong>指针的指针</strong>(<code>methodLists</code>)。</p>
<p>注意<code>*methodLists</code>是指向方法列表的指针，可以动态修改<code>*methodLists</code>的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。</p>
<p>剩下的<code>objc_cache</code>代表函数的缓存列表，<code>objc_protocol_list</code>代表协议列表。</p>
<h3 id="Objective语言历史"><a href="#Objective语言历史" class="headerlink" title="Objective语言历史"></a>Objective语言历史</h3><p>我在网上查资料的时候发现关于runtime的文章非常多，但提示数据模型在OC1.0和2.0之间区别的非常少，其实这一点很重要的。这也是为什么我将这段标题命名为Objective-C1.0数据模型的原因。</p>
<p>这里补一点<code>Objective-C</code>语言的发展历史（<a href="https://zh.wikipedia.org/wiki/Objective-C">维基百科</a>）：</p>
<blockquote>
<p> Objective-C1.0 即Objective-C++ 由Stepstone 公司的布莱德·考克斯（Brad Cox）和 汤姆·洛夫（Tom Love） 在 1980 年代发明。它是GCC的一个前端，它可以编译混合C++与Objective-C语法的源文件。Objective-C++是C++的扩展，类似于Objective-C是C的扩展。</p>
<p> Objective-C2.0 在2006年7月苹果全球开发者会议中，Apple宣布了“Objective-C 2.0”的发布，其增加了“现代的垃圾收集，语法改进，运行时性能改进，以及64位支持”。</p>
</blockquote>
<h2 id="Objective2-0数据模型"><a href="#Objective2-0数据模型" class="headerlink" title="Objective2.0数据模型"></a>Objective2.0数据模型</h2><p>可以在objc-runtim-new.h文件找到新版对<code>objc_class</code>的数据模型定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现<code>objc_class</code>不再是一个单独的结构体，而是继承于<code>objc_object</code>，objc_object内部的<code>isa</code>变成了<code>isa_t</code>的<a href="https://baike.baidu.com/item/%E8%81%94%E5%90%88%E4%BD%93">联合体</a>。</p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><p>我们再回来看类中的其他属性，之前表示类的属性、方法、以及遵循的协议都放在了<code>class_data_bits_t</code>中，更准确的说是放在了<code>class_rw_t</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint16_t version;</span><br><span class="line">    uint16_t witness;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面引入了<code>class_rw_t</code>和<code>class_ro_t</code>（rw-readwrite，ro-readonly）两个结构体。可以看到<code>class_rw_t</code>是包含一个常量指针<code>ro</code>，结构体为<code>class_ro_t</code>。这里存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。在 ObjC 运行时的时候会调用 <code>realizeClass</code> 方法，将<code>class_ro_t</code>传入<code>class_rw_t</code>，所以新版的动态性是通过这种方式实现的。</p>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    static bucket_t *emptyBuckets();</span><br><span class="line">    </span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    mask_t occupied();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    &#x2F;&#x2F; IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    &#x2F;&#x2F; SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">#else</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cache_t</code>是<code>objc_class</code>中的缓存结构体，里面通过<code>bucket_t</code>结构体存储一些最近调用的函数。设置cache最大的原因就是OC为动态语言，函数的执行是通过消息调用实现的，消息调用会首先查找当前类中的方法列表，如果找不到会查找父类，直到检索至<code>NSObject</code>依然找不到函数实现，就会进入消息转发流程。而为了节省每次查找函数表的开销，发明了<code>cache_t</code>。我们从<code>bucket_t</code>的内联函数中可以看出，缓存的SEL和IMP都是在内存中进行加载的。</p>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,</span><br><span class="line">                                    const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是函数的结构体，里面包含3个成员变量。<code>SEL</code>是方法的名字name。<code>types</code>是类型编码，类型可参考<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encoding</a>。<code>IMP</code>是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。</p>
<h2 id="数据模型对比"><a href="#数据模型对比" class="headerlink" title="数据模型对比"></a>数据模型对比</h2><p>最后总结下，Objc1.0到2.0的对比：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200223131049.png" alt=""><br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200223131158.png" alt=""><br>这两张图片引用自<a href="https://halfrost.com/">寒神</a>博客。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-objc-%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84">深入解析 ObjC 中方法的结构</a></li>
<li><a href="https://halfrost.com/objc_runtime_isa_class/">神经病院 Objective-C Runtime 入院第一天—— isa 和 Class</a></li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode配置Python版本</title>
    <url>/2020/02/01/vscode_python/</url>
    <content><![CDATA[<p>刚学习Python没多久，对VSCode也不是很熟悉，在一次解问题的过程中，加深了对这两者的印象，于是记录一下。</p>
<p>环境：Mac OS 10.15，VSCode 1.41.1</p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>我在尝试用VSCode写python爬虫，遇到一个问题<code>ImportError: No module named requests</code>。</p>
<p>通过问题描述很容易知道问题，这是因为导入了<code>requests</code>库，但是VSCode却没有找到这个库。</p>
<a id="more"></a>

<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>知道了问题，那就好办，安装<code>requests</code>就行了。<code>requests</code>需要通过<code>pip</code>安装，所以要先安装<code>pip</code>。在安装<code>pip</code>之前还要清楚一件事，就是当前的<code>python</code>版本，因为<code>pip</code>是跟<code>python</code>版本对应的。</p>
<h3 id="升级python"><a href="#升级python" class="headerlink" title="升级python"></a>升级python</h3><p>因为python2已经不再维护了，所以要保证当前为python3版本。查看当前python版本在命令行输入<code>python</code>：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">WARNING: Python 2.7 is not recommended.</span><br><span class="line">This version is included <span class="keyword">in</span> macOS <span class="keyword">for</span> compatibility with legacy software.</span><br><span class="line">Future versions of macOS will not include Python 2.7.</span><br><span class="line">Instead, it is recommended that you transition to using <span class="string">'python3'</span> from within Terminal.</span><br><span class="line"></span><br><span class="line">Python 2.7.16 (default, Aug 24 2019, 18:37:03)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 11.0.0 (clang-1100.0.32.4) (-macos10.15-objc<span class="_">-s</span> on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure>
<p>得知当前python版本为2.7，所以我们要进行升级。</p>
<p>小提示：命令行运行python就是打开了终端python环境，如果我们想退出该环境，运行exit()即可。</p>
<h4 id="下载python安装包"><a href="#下载python安装包" class="headerlink" title="下载python安装包"></a>下载python安装包</h4><p><a href="https://www.python.org/downloads/">下载地址</a><br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200201153150.png" alt=""><br>当前最新版本为3.8.1，我们下载之后进行安装。</p>
<h4 id="更改默认python版本"><a href="#更改默认python版本" class="headerlink" title="更改默认python版本"></a>更改默认python版本</h4><p>虽然我们安装了python3.8，但此时命令行运行python，还是显示为2.7，这是因为我们电脑中运行着两个版本的python，默认版本还是2.7。我们需要更改这项默认配置。<br>在此之前我们还需要确认终端的shell环境，常见的shell环境是<code>bash</code>和<code>zsh</code>。怎么当前是哪一个呢？在终端运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br></pre></td></tr></table></figure>
<p><strong>1、bash</strong><br>使用vim打开<code>.bash_profile</code>，当然你也可以使用别的文本编辑器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi .bash_profile</span><br></pre></td></tr></table></figure>
<p>在最后一行添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias python="/Library/Frameworks/Python.framework/Versions/3.8/bin/python3.8"</span><br></pre></td></tr></table></figure>
<p>保存之后，更新配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure>
<p><strong>2、zsh</strong><br>编辑<code>.zprofile</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi .zprofile</span><br></pre></td></tr></table></figure>
<p>在最后一行添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias python="/Library/Frameworks/Python.framework/Versions/3.8/bin/python3.8"</span><br></pre></td></tr></table></figure>
<p>保存之后，更新配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .zprofile</span><br></pre></td></tr></table></figure>

<p>然后再次运行<code>python</code>，会看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Python 3.8.1 (v3.8.1:1b293b6006, Dec 18 2019, 14:08:53)</span><br><span class="line">[Clang 6.0 (clang-600.0.57)] on darwin</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br></pre></td></tr></table></figure>
<p>说明我们已经成功将python默认版本改成了3.8版本。</p>
<h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>推荐使用pip安装脚本进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py   <span class="comment"># 下载安装脚本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo python get-pip.py    <span class="comment"># 运行安装脚本</span></span></span><br></pre></td></tr></table></figure>
<p>因为我们默认的python版本就是3.x版本，所以安装的pip会自动关联到python3版本上。</p>
<h4 id="查看pip版本和路径"><a href="#查看pip版本和路径" class="headerlink" title="查看pip版本和路径"></a>查看pip版本和路径</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip --version</span><br></pre></td></tr></table></figure>
<p>会得到以下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip 20.0.2 from /Library/Python/2.7/site-packages/pip (python 2.7)</span><br></pre></td></tr></table></figure>
<p>为什么关联的是python2.7版本？这是因为我电脑上之前通过python2.7安装过<code>pip</code>。那对应的python3.8版本的<code>pip</code>呢？它是由<code>pip3</code>表示的，可以验证下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 --version</span><br></pre></td></tr></table></figure>
<p>会得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip 20.0.2 from &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;pip (python 3.8)</span><br></pre></td></tr></table></figure>

<h3 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h3><p>到这一步就很简单了，注意使用<code>pip3</code>执行安装命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 install requests</span><br></pre></td></tr></table></figure>
<h2 id="VSCode的python环境和本机python环境"><a href="#VSCode的python环境和本机python环境" class="headerlink" title="VSCode的python环境和本机python环境"></a>VSCode的python环境和本机python环境</h2><p>我们成功安装了<code>requests</code>，但是在vscode中运行脚本依旧报无法找到<code>requests</code>库的错误。这时我开始怀疑vscode和本机的python环境可能是不同的，而且我本机有两个python版本，vscode用的是哪一个呢？不管怎么样，我应该需要让vscode的python环境指向本机的python3.8，因为我的<code>pip3</code>和<code>requests</code>都是基于这个版本的python安装的。</p>
<h3 id="vscode的python环境"><a href="#vscode的python环境" class="headerlink" title="vscode的python环境"></a>vscode的python环境</h3><p>在vscode的python编辑界面的最下面一行会显示当前的python环境：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200201171205.png" alt=""><br>点击它可以看到当前支持python版本：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200201171339.png" alt=""><br>发现并没有我们的python3.8，所以我们需要手动指定python的版本。</p>
<h3 id="指定vscode的python版本"><a href="#指定vscode的python版本" class="headerlink" title="指定vscode的python版本"></a>指定vscode的python版本</h3><p>使用快捷键<code>Command + ,</code>可以唤出vscode的设计界面。因为配置项非常多，我们通过搜索命令查询，键入<code>[python path]</code>（中括号表示整体搜索），可以找到python路径配置的设置项：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200201171935.png" alt=""></p>
<p>默认值是python，我们将它改为<code>/usr/local/bin/python3</code>，然后重启vscode，我们就可以看到当前的python版本已经改为3.8.1了。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200201172605.png" alt=""><br>导入<code>requests</code>的代码执行也没有问题了！</p>
<h3 id="疑问？"><a href="#疑问？" class="headerlink" title="疑问？"></a>疑问？</h3><p>这里还有几个疑问：<br>1、python2.7和3.7版本都是vscode在安装python时自己装进去的吗？<br>2、如果不通过指定为本机python版本，仅使用vscode中的python版本能否安装pip？</p>
<p>有能帮助解答的小伙伴将不胜感激！</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年总结</title>
    <url>/2020/01/01/2019-year-summary/</url>
    <content><![CDATA[<blockquote>
<p>好像随着年龄的增长，对时间的感知就变得越来越弱了。总感觉2019年还是一个很新鲜的年份，但它却已经走完了，2020年好像很遥远的样子，但它已经到来了。来个总结吧，2019年，这一年有太多的酸甜苦辣。从工作、生活和规划三个方面展开说吧。</p>
</blockquote>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/thought-catalog-505eectW54k-unsplash.jpg" alt=""></p>
<p>年初原项目组有一位很厉害的开发离职了，当时是我俩共同负责一个项目。他开发经验比我多，而且工作态度和习惯都很好，是我见过的未数不多让我称赞的程序员。曾经一起工作的将近一年多时间里，我都以他为学习榜样。对于他的离职，我纠结了很长一段时间，自认这是对我对公司的一大损失。</p>
<p>后来很长的时间里，一直都没有招到合适的人，我便一个人扛起了项目。很多之前应该是两个人一起商量的问题都需要自己一个人去思考解决方式，渐渐的我不断磨练自己的独立思考能力。大半年下来，突然感觉自己被逼着成长了许多，从一个崇拜别人，向别人学习的角色变成了一个不惧怕任何技术难题，能够帮助别人解决困难的角色。</p>
<p>2019年学会的第一个最重要的道理，<strong>很多时候有一个可以依赖的对象，是会减弱自己探索和尝试的动力，而开发很多时候对技能的理解和掌握，乃至个人进步，都是要依靠自己的探索获取的</strong>。</p>
<a id="more"></a>

<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>2019年共产出<a href="https://zhangferry.com/">27篇博文</a>，27是一个挺大的数量，但令我满意的文章到不是很多。博客内容质量的重要性应该是要远大于数量的，这一点后面注意到了。</p>
<p>对技术博客的写作今年做了一些不同的尝试。</p>
<p>首先对于月报的更新持续到今年7月份，共产出了一共13篇文章，就停更了。月报内容主要由三部分组成：</p>
<ul>
<li>最近一段时间的bug修复经历和开发tip</li>
<li>阅读过的优秀博文</li>
<li>优秀的github库</li>
</ul>
<p>第一部分，这个受开发经历的影响，就我个人来说，很多时候没有太好的经验可以写，到最后时感觉内容不好撑起这一个模块。<br>第二部分，出现过几次前期准备不够，最后一两天才去寻找素材，导致推荐内容很一般。<br>第三部分，优秀库的推荐，写到第十期时就感觉乏力的。当然我知道这里的内容是接近无限的，但是很多如果我都不了解，不使用，只读一个简介就去推荐，会有种不负责任的感觉。</p>
<p>还有一部分原因是，到后来关注的人越来越少，接到的反馈也越来越少，应该是跟质量下降有关。做这个东西也确实费时间，很多时候我就想如果这些时间去打磨一篇技术博客，可能效果会更好。而且月报给人感觉时效性更强，跟新闻类似，过了这个时间之后好像过时了一样，大家很少会特意翻看之前的内容，而普通的技术博客却不会有这种问题，解题思路，技术干货几乎不存在过时问题。</p>
<p>另外我也一直在观察给我启发的 “老司机iOS周报”，他们只有博文推荐和代码库推荐，由多位联合编辑共同完成，人员、时间、内容质量都不是问题。但就我观察得知，“老司机”的号召力和响应力也在不断减弱。技术类人员对内容聚合类产品的粘性是没有固定知识分享平台高的。一篇周报，十篇左右文章，大致看去，自己感兴趣的可能就两三篇，新窗口打开，导流到别的地方，有时间的话读一读，时间不够就放到收藏夹。一般在周报的停留时间不超过3分钟。</p>
<p>基于这些原因吧，我也就不再更新月报了，而是把时间分配到别的事情上去。</p>
<p><strong>公众号</strong></p>
<p>另外，开始尝试写公众号，名字叫“iOS成长之路”。文章更新不多，其中最主要的原因就是我习惯了写博客，而且博客有一套自己的workflow。一般我是先写博客，然后将文章复制到别的平台。像之前的简书和后来的掘金，都是可以全量复制的。</p>
<p>转到公众号时，虽然可以直接将Markdown转成公众号形式，但对图片却不识别，需要单独导入。我需要把github上的图片下载下来，放到公众号编辑界面。如果图多，就是项很繁琐的流程。而且公众号还限制了每天只能发一篇文章，所以后面更新了几次之后就不再更新了。如果有小伙伴知道解决方案的话，希望能够告知。之后的话，会想把公众号这个事情再推进下。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/851578118934_.pic.jpg" alt=""></p>
<h3 id="那些经历"><a href="#那些经历" class="headerlink" title="那些经历"></a>那些经历</h3><p>今年基本没有什么活动。</p>
<p>清明节，回家看妈妈，不自觉拍了很多家里，地里的照片，感觉老家哪里都是美的。那个我曾经抵触，一心想逃离的家乡，在这个春天里一下变得可爱，温馨起来。走到路上我想起曾经走在这里发生过的一切，到了家里我回想这个房屋里曾经发生过的一切，那些欢声笑语。记忆一点点展开，如果此时放弃工作，放弃所有，跟爸爸就在老家生活下去，也未尝不可，我这样想着，对未来的规划和期许，已经都不重要了。但是也只能想想，现实还有很多问题需要考虑，需要处理，我已经被社会规则裹挟着由不得自己了，这可能就是长大的无奈吧。</p>
<p>4月份中旬，参加了《天火》的电影宣发，见到了很多明星，但也并没有太多兴奋，就感觉明星跟普通人其实也没有太多不同。12月12号，电影上映，因为宣发时收到了很多到场礼品，就买了票去支持下，女友和我观点一致：电影很烂，昆凌演的一般，剧情太散。配备了近乎完美的制作团队，外加周杰伦的宣传，电影竟然如此扑街，真的很让人匪夷所思。今年娱乐活动极少，一共就去电影院看了两场电影，其中一部还是这种感受。剧情，剧情，剧情，这是电影的灵魂，真的很重要啊。</p>
<p>4月底，参加我们609寝室第一个结婚的室友婚礼，分别两年多了再相聚，大家都基本没变。我们还是曾经的我们，各奔东西，又再次相聚，真好。</p>
<p>4月份报名了半马，但是很遗憾没有中签，直接导致了去年的一项目标没有完成。</p>
<p>5月份没有出门，跟女朋友在家探索了很多美食的做法，每次做好吃的，我都会用手机拍下来，相册里已经有几十张美食照片了。做饭其实是一项很有趣的事情，洗菜，切菜，食材下锅一瞬间的滋滋声，出锅时的香气四溢，都能不断激发自己的食欲，这可比塑料彩盒包装的外卖有灵魂多了。所以这一年不光点外卖次数少了很多，厨艺还增进了不少。</p>
<p>6月份重新拾起了跑步的习惯，每天下午下班之前的半个小时都陪菲姐去园区跑道跑步，这个习惯帮助她减掉了十几斤肉，也帮助我在年度跑步计划中增加了将近200公里的里程。</p>
<p>7月份准备园区的篮球比赛，虽然每次练习都挥汗如雨，各种制定战术，尽心准备，但还是改变不了比赛被别的公司虐的结局。虽然篮球比不过他们，但是我们敲代码比他们厉害啊，这么安慰自己。但老实说，为什么我感觉打球比敲代码还有意思啊。教练，我想打球。</p>
<p>8月份，配父亲去郑州等肾脏配型，当时想的是父亲留在这里，等有手术消息了，我再赶过去，但是医院要求等待期间必须要有家属陪同，那就回不了北京了。跟公司说明情况之后想申请远程办公，当时想的是如果公司不同意就直接离职。最后公司领导商量之后决定同意我的请求，之后就开始了长达45天的在郑州远程办公。</p>
<p>9月份，工作日期间，我将作息时间调整到跟公司一样的点，有时候去附近的咖啡店，有时候就在家办公。这期间最大的挑战就是自律和需求沟通。因为有时候配父亲做检查，或者送饭，耽误一些时间，这个就要想办法从别的地方补上来，还有就是家里的工作氛围比着公司要差一下，注意力的持续状态要短一些。所以这段时间基本周六都会根据情况抽出时间用来补进度。当然远程办公最爽的一点就是时间可以自由安排，可以是忙完一项任务或者通过时间挪移，你就可以在任意时间段做自己能做的事情。</p>
<p>当然因为效率没有在公司高，所以空闲时间相较而言还是更少了。这里的调整就是时间规划和时间管理的内容了，这个在未来我会重点优化下。</p>
<p>10月份，参加我们609第二个结婚的小伙伴婚礼，还顺道去了一趟大学校园。校园里多了好几栋教学楼和宿舍楼，当年的公教没变，宿舍楼变成了女寝？图书馆还是那么霸气，甚至想进去找个地方看会书。多好的环境啊，为什么当初没有好好珍惜，努力学习呢。好像在回忆过往时，我从来都是责备自己不够努力，不够优秀。</p>
<p>但是好像这就是真的，2019年也是，<strong>我并没有拼进全力，很多事情都没有做好，我应该更加努力，多逼一逼自己才是</strong>。</p>
<p>11月份，一直陪父亲等的肾脏配型终于有了结果，父亲接受手术，我来郑州陪护。这段经历大多数记在博客里面，这期间确实让我成长了不少。后来父亲出院，我回北京的第二天在V站看到一个帖子，一个程序员长时间加班导致身体不适，去医院检查被诊断为CKD4期（慢性肾病4期）。而CKD5期就是尿毒症，就是父亲的那个病。虽然我在医院见过很多病人了，但这个病的魔爪伸到了程序员群体，还是很让我惊讶和担忧的。</p>
<p>不只尿毒症，很多病都在向低龄化发展。<strong>健康！健康！健康！这个真的非常重要，作息，饮食，这两个最容易导致身体出问题的环节一定要重视啊</strong>。</p>
<p>12月份，在天桥看了一场话剧《黄金百万》，演员均非科班出身，当时还只是第三场演出，所以整体感觉水分很大，甚至一度有中途撤离的冲动。话剧演出结束，演员讲述舞台背后的故事时，却让我得到了些意外收获。他们是由互联网圈，投资圈，主持人圈的几个朋友组建起来的，其中就有为人熟知的张泉灵和于光东。他们都不缺钱，也不指望依靠话剧挣钱，就凭着爱好，组织话剧社，在本职工作之余，挤时间进行排练，很多人都不在北京居住，但他们还是圆满的完成了这次表演。</p>
<p>这让我看到了一种生活态度，<strong>工作不应该完全占据生活，生活也不应该只是吃喝玩乐，我们应该发觉自己的爱好，潜力，去做一些能带给自己满足感，更有意义的事情，这样才是精彩的活着</strong>。所以2020年，我也会往这方面做一些尝试。</p>
<h3 id="关于理财"><a href="#关于理财" class="headerlink" title="关于理财"></a>关于理财</h3><p>看到很多人晒今年收益，50%，甚至120%。因为今年经济整体都是上行，大多数都是赚的，只是赚多赚少而已。像我这种理财小白，只是定投指数基金不动都有将近30%的收益。所以大家对于很多人的收益不要眼红，不要过于乐观。今年大好，明年是好还是坏谁也说不准了。理财的一条金科玉律就是，收益越大风险越大，能承受风险，有一定的专业知识，那就努力达到收益最大化。如果都做不到，那就不要定过高的目标，像我目前定的目标就是跑赢通货膨胀，保证手里的钱不贬值就行。</p>
<p>理财这项技能，可以看到上限还是很高的，以后会花更多的时间在上面做一些研究，补足这方面的能力，努力提高收益。</p>
<h3 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h3><p>阅读方面，近几年看的书越来越少了，今年只有：<br>《软技能：代码之外的生存指南》<br>《图解TCP/IP》<br>《重构》<br>《未来简史》<br>《老人与海》<br>《白夜行》<br>《半小时漫画中国史+世界史》<br>《如何高效读懂一本书》</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200104144208.png" alt=""></p>
<p>这里最推荐的就是《软技能》，它介绍了程序员在编程能力之外还应该具备哪些能力，涵盖职业规划，自我营销，学习方法，理财手段，健身，精神提升等方面。这本书影响了我对自己职业的看法，同时也让我对未来的规划更坚定，更清晰了一些。非常建议大家都读一读。</p>
<h2 id="OKR总结"><a href="#OKR总结" class="headerlink" title="OKR总结"></a>OKR总结</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/brendan-church-pKeF6Tt3c08-unsplash.jpg" alt=""></p>
<h3 id="2019年OKR总结"><a href="#2019年OKR总结" class="headerlink" title="2019年OKR总结"></a>2019年OKR总结</h3><p><strong>O1:精进技术栈</strong></p>
<table>
<thead>
<tr>
<th>KR</th>
<th>完成进度</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>刷50道LeetCode，输出解题思路</td>
<td>10%</td>
<td>时间问题</td>
</tr>
<tr>
<td>逆向实践</td>
<td>0%</td>
<td>逆向理论没有持续深入研究，时间问题</td>
</tr>
<tr>
<td>翻译5篇技术文章</td>
<td>60%</td>
<td>翻译水平有待提高，输出较慢</td>
</tr>
<tr>
<td>博客主题优化</td>
<td>10%</td>
<td>学习前端要系统的学习，低估了这个工作量</td>
</tr>
<tr>
<td>开发微习惯APP</td>
<td>5%</td>
<td>发现有别的APP做的很好了，另因产品设计能力短时间没有补全，及时间问题，后来做罢</td>
</tr>
<tr>
<td>博客输出24篇文章</td>
<td>112%</td>
<td>因为多了几篇生活中的文章，如果只算技术文章也是不够的</td>
</tr>
</tbody></table>
<p>总结：实现度较低，很多是因为时间问题，和对制定任务的难度预估不准确导致的。这一年对技术层面的提升总综合性，没有在某一点有所突出，今年需要做一些调整。</p>
<p><strong>O2:攒更多的钱</strong></p>
<table>
<thead>
<tr>
<th>KR</th>
<th>完成进度</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>工资外收入达到1000</td>
<td>200%</td>
<td>有段时间帮助一个团队处理了几个问题，获得了一些报酬</td>
</tr>
<tr>
<td>总收入达到买房需要的首付一半</td>
<td>50%</td>
<td>收入是达到了，但是存款却没有</td>
</tr>
</tbody></table>
<p>总结：这几项定的目标都有些含糊了，工资外收入其实更像表达的是，写博客的打赏，和公众号的一些收入。总收入的目标其实没有意义，存款才有意义。</p>
<p><strong>O3:运动健身</strong></p>
<table>
<thead>
<tr>
<th>KR</th>
<th>完成进度</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>半程马拉松跑到2小时以内</td>
<td>0%</td>
<td>因为没有中签，也就没有跑半马的经历了</td>
</tr>
<tr>
<td>咕咚累积里程达到500公里</td>
<td>99%</td>
<td>依靠每天下午的跑步，基本追上了这个目标</td>
</tr>
</tbody></table>
<p>总结：跑步里程到是一个合理的目标，半马因为受外界因素影响，所以是一个不太好的KR。</p>
<h3 id="2020年OKR"><a href="#2020年OKR" class="headerlink" title="2020年OKR"></a>2020年OKR</h3><p>有些在2019年没有做好的事情，会在新的一年里持续的跟进优化。</p>
<p><strong>O1：精进技术栈</strong></p>
<p>KR1：刷20道经典LeetCode题目，输出2篇解题思路的文章</p>
<p>KR2：学习前端知识，优化博客小站</p>
<p>KR3：输出5篇对计算机知识总结的文章</p>
<p>KR4：维护一个Swift库，用于筛选项目中不用的文件</p>
<p><strong>O2：个人成长</strong></p>
<p>KR1：公众号粉丝达到500</p>
<p>KR2：学习基金知识，分析对比10种基金的数据表现</p>
<p>KR3：全年跑步里程400公里</p>
<p>KR4：阅读15本书</p>
<p>KR5：培养时间规划能力，总结并践行一份时间规划清单</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>OC项目转Swift指南</title>
    <url>/2019/12/07/transfom_oc_to_swift/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/web-3967926_1280.jpg" alt=""></p>
<blockquote>
<p>运行环境：Xcode 11.1 Swift5.0</p>
</blockquote>
<p>最近参与的一个项目需要从Objective-C（以下简称OC）转到Swift，期间遇到了一些坑，于是有了这篇总结性的文档。如果你也有将OC项目Swift化的需求，可以作为参考。</p>
<p>OC转Swift有一个大前提就是你要对Swift有一定的了解，熟悉Swift语法，最好是完整看过一遍官方的<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html">Language Guide</a>。</p>
<p>转换的过程分自动化和手动转译，鉴于自动化工具的识别率不能让人满意，大部分情况都是需要手动转换的。</p>
<a id="more"></a>

<h2 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h2><p>有一个比较好的自动化工具<a href="https://objectivec2swift.com/#/home">Swiftify</a>，可以将OC文件甚至OC工程整个转成Swift，号称准确率能达到90%。我试用了一些免费版中的功能，但感觉效果并不理想，因为没有使用过付费版，所以也不好评价它就是不好。</p>
<p>Swiftify还有一个Xcode的插件<a href="https://objectivec2swift.com/#/xcode-extension/">Swiftify for Xcode</a>，可以实现对选中代码和单文件的转化。这个插件还挺不错，对纯系统代码转化还算精确，但部分代码还存在一些识别问题，需要手动再修改。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191208103559.png" alt=""></p>
<h2 id="手动Swift化"><a href="#手动Swift化" class="headerlink" title="手动Swift化"></a>手动Swift化</h2><h3 id="桥接文件"><a href="#桥接文件" class="headerlink" title="桥接文件"></a>桥接文件</h3><p>如果你是在项目中首次使用Swift代码，在添加Swift文件时，Xcode会提示你添加一个<code>.h</code>的桥接文件。如果不小心点了不添加还可以手动导入，就是自己手动生成一个<code>.h</code>文件，然后在<code>Build Settings &gt; Swift Compiler - General &gt; Objective-C Bridging Header</code>中填入该<code>.h</code>文件的路径。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20200229115315.png" alt=""></p>
<p>这个桥接文件的作用就是供Swift代码引用OC代码，或者OC的三方库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Utility.h&quot;</span><br><span class="line">#import &lt;Masonry&#x2F;Masonry.h&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>Bridging Header</code>的下面还有一个配置项是<code>Objective-C Generated Interface Header Name</code>，对应的值是<code>ProjectName-Swift.h</code>。这是由Xcode自动生成的一个隐藏头文件，每次Build的过程会将Swift代码中声明为外接调用的部分转成OC代码，OC部分的文件会类似<code>pch</code>一样全局引用这个头文件。因为是Build过程中生成的，所以只有<code>.m</code>文件中可以直接引用，对于在<code>.h</code>文件中的引用下文有介绍。</p>
<h3 id="Appdelegate-程序入口"><a href="#Appdelegate-程序入口" class="headerlink" title="Appdelegate(程序入口)"></a>Appdelegate(程序入口)</h3><p>Swift中没有<code>main.m</code>文件，取而代之的是<code>@UIApplicationMain</code>命令，该命令等效于原有的执行<code>main.m</code>。所以我们可以把<code>main.m</code>文件进行移除。</p>
<h3 id="系统API"><a href="#系统API" class="headerlink" title="系统API"></a>系统API</h3><p>对于<code>UIKit</code>框架中的大部分代码转换可以直接查看系统API文档进行转换，这里就不过多介绍。</p>
<h3 id="property-属性"><a href="#property-属性" class="headerlink" title="property(属性)"></a>property(属性)</h3><p>Swift没有<code>property</code>，也没有<code>copy</code>，<code>nonatomic</code>等属性修饰词，只有表示属性是否可变的<code>let</code>和<code>var</code>。</p>
<p><strong>注意点一</strong><br>OC中一个类分<code>.h</code>和<code>.m</code>两个文件，分别表示用于暴露给外接的方法，变量和仅供内部使用的方法变量。迁移到Swift时，应该将<code>.m</code>中的property标为<code>private</code>，即外接无法直接访问，对于<code>.h</code>中的property不做处理，取默认的<code>internal</code>，即同模块可访问。</p>
<p>对于函数的迁移也是相同的。</p>
<p><strong>注意点二</strong><br>有一种特殊情况是在OC项目中，某些属性在内部（<code>.m</code>）可变，外部（<code>.h</code>）只读。这种情况可以这么处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> value: <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>就是只对<code>value</code>的<code>set</code>方法就行<code>private</code>标记。</p>
<p><strong>注意点三</strong><br>Swift中针对空类型有个专门的符号<code>?</code>，对应OC中的<code>nil</code>。OC中没有这个符号，但是可以通过在<code>nullable</code>和<code>nonnull</code>表示该种属性，方法参数或者返回值是否可以空。</p>
<p>如果OC中没有声明一个属性是否可以为空，那就去默认值<code>nonnull</code>。</p>
<p>如果我们想让一个类的所有属性，函数返回值都是<code>nonnull</code>，除了手动一个个添加之外还有一个宏命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">&#x2F;* code *&#x2F;</span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>
<h4 id="enum（枚举）"><a href="#enum（枚举）" class="headerlink" title="enum（枚举）"></a>enum（枚举）</h4><p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, PlayerState) &#123;</span><br><span class="line">    PlayerStateNone &#x3D; 0,</span><br><span class="line">    PlayerStatePlaying,</span><br><span class="line">    PlayerStatePause,</span><br><span class="line">    PlayerStateBuffer,</span><br><span class="line">    PlayerStateFailed,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_OPTIONS(NSUInteger, XXViewAnimationOptions) &#123;</span><br><span class="line">    XXViewAnimationOptionNone            &#x3D; 1 &lt;&lt;  0,</span><br><span class="line">    XXViewAnimationOptionSelcted1      	 &#x3D; 1 &lt;&lt;  1,</span><br><span class="line">    XXViewAnimationOptionSelcted2      	 &#x3D; 1 &lt;&lt;  2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PlayerState</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> playing</span><br><span class="line">    <span class="keyword">case</span> pause</span><br><span class="line">    <span class="keyword">case</span> buffer</span><br><span class="line">    <span class="keyword">case</span> failed</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewAnimationOptions</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue: <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">None</span> = <span class="type">ViewAnimationOptions</span>(rawValue: <span class="number">1</span>&lt;&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Selected1</span> = <span class="type">ViewAnimationOptions</span>(rawValue: <span class="number">1</span>&lt;&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Selected2</span> = <span class="type">ViewAnimationOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift没有<code>NS_OPTIONS</code>的概念，取而代之的是为了满足<code>OptionSet</code>协议的<code>struct</code>类型。</p>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (MTObject *)object &#123;</span><br><span class="line">    if (!_object) &#123;</span><br><span class="line">        _object &#x3D; [MTObject new];</span><br><span class="line">    &#125;</span><br><span class="line">    return _object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> object: <span class="type">MTObject</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> object = <span class="type">MTObject</span>()</span><br><span class="line">    <span class="keyword">return</span> imagobjecteView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef void (^DownloadStateBlock)(BOOL isComplete);</span><br></pre></td></tr></table></figure>
<p>Swift代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">DownloadStateBlock</span> = ((<span class="number">_</span> isComplete: <span class="type">Bool</span>) -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>

<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (XXManager *)shareInstance &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance &#x3D; [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift对单例的实现比较简单，有两种方式：</p>
<p><strong>第一种</strong></p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shared = <span class="type">XXManager</span>()<span class="comment">// 声明在全局命名区（global namespace）</span></span><br><span class="line"><span class="type">Class</span> <span class="type">XXManager</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会疑惑，为什么没有<code>dispatch_once</code>，如何保证多线程下创建的唯一性？其实是这样的，Swift中全局变量是懒加载，在AppDelegate中被初始化，之后所有的调用都会使用该实例。而且全局变量的初始化是默认使用<code>dispatch_once</code>的，这保证了全局变量的构造器（initializer）只会被调用一次，保证了<code>shard</code>的<strong>原子性</strong>。</p>
<p><strong>第二种</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="type">XXManager</span> &#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">XXManager</span>()</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">   		<span class="comment">// do something </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 2 开始增加了<code>static</code>关键字，用于限定变量的作用域。如果不使用<code>static</code>，那么每一个<code>shared</code>都会对应一个实例。而使用<code>static</code>之后，<code>shared</code>成为全局变量，就成了跟上面第一种方式原理一致。可以注意到，由于构造器使用了 <code>private</code> 关键字，所以也保证了单例的原子性。</p>
<h3 id="初始化方法和析构函数"><a href="#初始化方法和析构函数" class="headerlink" title="初始化方法和析构函数"></a>初始化方法和析构函数</h3><p>对于初始化方法OC先调用父类的初始化方法，然后初始自己的成员变量。Swift先初始化自己的成员变量，然后在调用父类的初始化方法。</p>
<p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化方法</span><br><span class="line">@interface MainView : UIView</span><br><span class="line">@property (nonatomic, strong) NSString *title;</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame title:(NSString *)title NS_DESIGNATED_INITIALIZER;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MainView</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame title:(NSString *)title &#123;</span><br><span class="line">    if (self &#x3D; [super initWithFrame:frame]) &#123;</span><br><span class="line">        self.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F; 析构函数</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    &#x2F;&#x2F;dealloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewSwift</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(frame: <span class="type">CGRect</span>, title: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">deinit</span> &#123;</span><br><span class="line">      <span class="comment">//deinit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实例函数（共有方法）</span><br><span class="line">- (void)configModelWith:(XXModel *)model &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 实例函数（私有方法）</span><br><span class="line">- (void)calculateProgress &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 类函数</span><br><span class="line">+ (void)configModelWith:(XXModel *)model &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Swift代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例函数（共有方法）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configModel</span><span class="params">(with model: XXModel)</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">// 实例函数（私有方法）</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">calculateProgress</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">// 类函数（不可以被子类重写）</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">configModel</span><span class="params">(with model: XXModel)</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">// 类函数（可以被子类重写）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">configModel</span>(<span class="title">with</span> <span class="title">model</span>: <span class="title">XXModel</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 类函数（不可以被子类重写）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">final</span> <span class="title">func</span> <span class="title">configModel</span>(<span class="title">with</span> <span class="title">model</span>: <span class="title">XXModel</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>OC可以通过是否将方法声明在<code>.h</code>文件表明该方法是否为私有方法。Swift中没有了<code>.h</code>文件，对于方法的权限控制是通过权限关键词进行的，各关键词权限大小为：<br><code>private &lt; fileprivate &lt; internal &lt; public &lt; open</code></p>
<p>其中<code>internal</code>为默认权限，可以在同一<code>module</code>下访问。</p>
<h3 id="NSNotification-通知"><a href="#NSNotification-通知" class="headerlink" title="NSNotification(通知)"></a>NSNotification(通知)</h3><p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; add observer</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(method) name:@&quot;NotificationName&quot; object:nil];</span><br><span class="line">&#x2F;&#x2F; post</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;NotificationName&quot; object:nil];</span><br></pre></td></tr></table></figure>

<p>Swift代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add observer</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(method), name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"NotificationName"</span>), object: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"NotificationName"</span>), object: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p>可以注意到，Swift中通知中心<code>NotificationCenter</code>不带<code>NS</code>前缀，通知名由字符串变成了<code>NSNotification.Name</code>的结构体。</p>
<p>改成结构体的目的就是为了便于管理字符串，原本的字符串类型变成了指定的<code>NSNotification.Name</code>类型。上面的Swift代码可以修改为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSNotification</span>.<span class="title">Name</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">let</span> <span class="type">NotificationName</span> = <span class="type">NSNotification</span>.<span class="type">Name</span>(<span class="string">"NotificationName"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add observer</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(method), name: .<span class="type">NotificationName</span>, object: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: .<span class="type">NotificationName</span>, object: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<h3 id="protocol-协议-代理"><a href="#protocol-协议-代理" class="headerlink" title="protocol(协议/代理)"></a>protocol(协议/代理)</h3><p>OC代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@protocol XXManagerDelegate &lt;NSObject&gt;</span><br><span class="line">- (void)downloadFileFailed:(NSError *)error;</span><br><span class="line">@optional</span><br><span class="line">- (void)downloadFileComplete;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@interface XXManager: NSObject</span><br><span class="line">@property (nonatomic, weak) id&lt;XXManagerDelegate&gt; delegate;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>Swift中对<code>protocol</code>的使用拓宽了许多，不光是<code>class</code>对象，<code>struct</code>和<code>enum</code>也都可以实现协议。需要注意的是<code>struct</code>和<code>enum</code>为指引用类型，不能使用<code>weak</code>修饰。只有指定当前代理只支持类对象，才能使用<code>weak</code>。将上面的代码转成对应的Swift代码，就是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">XXManagerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">downloadFailFailed</span><span class="params">(error: Error)</span></span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">downloadFileComplete</span><span class="params">()</span></span> <span class="comment">// 可选协议的实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">		<span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">XXManagerDelegate</span>?  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@objc</code>是表明当前代码是针对<code>NSObject</code>对象，也就是<code>class</code>对象，就可以正常使用weak了。</p>
<p>如果不是针对NSObject对象的delegate，仅仅是普通的class对象可以这样设置代理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">XXManagerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">downloadFailFailed</span><span class="params">(error: Error)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXManager</span> </span>&#123;</span><br><span class="line">		<span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">XXManagerDelegate</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，仅<code>@objc</code>标记的<code>protocol</code>可以使用<code>@optional</code>。</p>
<h2 id="Swift和OC混编注意事项"><a href="#Swift和OC混编注意事项" class="headerlink" title="Swift和OC混编注意事项"></a>Swift和OC混编注意事项</h2><h3 id="函数名的变化"><a href="#函数名的变化" class="headerlink" title="函数名的变化"></a>函数名的变化</h3><p>如果你在一个Swift类里定义了一个delegate方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MarkButtonDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clickBtn</span><span class="params">(title: String)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你要在OC中实现这个协议，这时候方法名就变成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)clickBtnWithTitle:(NSString *)title &#123;</span><br><span class="line">		&#x2F;&#x2F; code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这主要是因为Swift有指定参数标签，OC却没有，所以在由Swift方法名生成OC方法名时编译器会自动加一些修饰词，已使函数作为一个句子可以”通顺”。</p>
<h3 id="在OC的头文件里调用Swift类"><a href="#在OC的头文件里调用Swift类" class="headerlink" title="在OC的头文件里调用Swift类"></a>在OC的头文件里调用Swift类</h3><p>如果要在OC的头文件里引用Swift类，因为Swift没有头文件，而为了让在头文件能够识别该Swift类，需要通过<code>@class</code>的方法引入。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">class</span> <span class="title">SwiftClass</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">interface</span> <span class="title">XXOCClass</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="class">@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">strong</span>) <span class="title">SwiftClass</span> *<span class="title">object</span>;</span></span><br><span class="line"><span class="class">@<span class="title">end</span></span></span><br></pre></td></tr></table></figure>

<h3 id="对OC类在Swift调用下重命名"><a href="#对OC类在Swift调用下重命名" class="headerlink" title="对OC类在Swift调用下重命名"></a>对OC类在Swift调用下重命名</h3><p>因为Swift对不同的module都有命名空间，所以Swift类都不需要添加前缀。如果有一个带前缀的OC公共组件，在Swift环境下调用时不得不指定前缀是一件很不优雅的事情，所以苹果添加了一个宏命令<code>NS_SWIFT_NAME</code>，允许在OC类在Swift环境下的重命名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NS_SWIFT_NAME(LoginManager)</span><br><span class="line">@interface XXLoginManager: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这样我们就将<code>XXLoginManager</code>在Swift环境下的类名改为了<code>LoginManager</code>。</p>
<h3 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h3><p>1、  <code>struct</code> 和 <code>enum</code> 是值类型，类 <code>class</code> 是引用类型。<br>2、<code>String</code>，<code>Array</code>和 <code>Dictionary</code>都是结构体，因此赋值直接是拷贝，而<code>NSString</code>, <code>NSArray</code> 和<code>NSDictionary</code>则是类，所以是使用引用的方式。<br>3、<code>struct</code> 比 <code>class</code> 更“轻量级”，<code>struct</code> 分配在栈中，<code>class</code> 分配在堆中。</p>
<h3 id="id类型和AnyObject"><a href="#id类型和AnyObject" class="headerlink" title="id类型和AnyObject"></a>id类型和AnyObject</h3><p>OC中<code>id</code>类型被Swift调用时会自动转成<code>AnyObject</code>，他们很相似，但却其实概念并不一致。<br>AnyObject可以代表任何class类型的实例；</p>
<h3 id="其他语法区别及注意事项（待补充）"><a href="#其他语法区别及注意事项（待补充）" class="headerlink" title="其他语法区别及注意事项（待补充）"></a>其他语法区别及注意事项（待补充）</h3><p>1、Swift语句中不需要加分号<code>;</code>。<br>2、关于Bool类型更加严格，Swift不再是OC中的非0就是真，真假只对应<code>true</code>和<code>false</code>。<br>3、Swift类内一般不需要写<code>self</code>，但是闭包内是需要写的。<br>4、Swift是强类型语言，必须要指定明确的类型。在Swift中<code>Int</code>和<code>Float</code>是不能直接做运算的，必须要将他们转成同一类型才可以运算。<br>5、Swift抛弃了传统的<code>++</code>，<code>--</code>运算，抛弃了传统的C语言式的<code>for</code>循环写法，而改为<code>for-in</code>。<br>6、Swift的<code>switch</code>操作，不需要在每个case语句结束的时候都添加<code>break</code>。<br>7、Swift对<code>enum</code>的使用做了很大的扩展，可以支持任意类型，而OC枚举仅支持<code>Int</code>类型，如果要写兼容代码，要选择Int型枚举。<br>8、Swift代码要想被OC调用，需要在属性和方法名前面加上<code>@objc</code>。<br>9、Swift独有的特性，如泛型，<code>struct</code>，非Int型的<code>enum</code>等被包含才函数参数中，即使添加<code>@objc</code>也不会被编译器通过。<br>10、Swift支持重载，OC不支持。<br>11、带默认值的Swift函数再被OC调用时会自动展开。</p>
<h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><p>对于OC转Swift之后的语法变化还有很多细节值得注意，特别是对于初次使用Swift这门语言的同学，很容易遗漏或者待着OC的思想去写代码。这里推荐一个语法检查的框架<a href="https://github.com/realm/SwiftLint">SwiftLint</a>，可以自动化的检查我们的代码是否符合Swift规范。</p>
<p>可以通过<code>cocoapods</code>进行引入，配置好之后，每次<code>Build</code>的过程，Lint脚本都会执行一遍Swift代码的语法检查操作，Lint还会将代码规范进行分级，严重的代码错误会直接报错，导致程序无法启动，不太严重的会显示代码警告（⚠️）。</p>
<p>如果你感觉SwiftLint有点过于严格了，还可以通过修改<code>.swiftlint.yml</code>文件，自定义属于自己的语法规范。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】iOS 架构模式--浅析MVC, MVP, MVVM 和 VIPER</title>
    <url>/2019/11/22/ios_architecture_patterns/</url>
    <content><![CDATA[<blockquote>
<p>作者：Bohdan Orlov<br>原文地址：<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191122154526.png" alt=""></p>
<p>在iOS开发过程中你是否对MVC的使用感觉很别扭？你是否对转向MVVM有疑惑？你听说过VIPER，但不清楚这个东西是否值得一试。</p>
<p>接着读下去，你会找到上面这些问题的答案。如果读完仍不能解惑，欢迎到评论区捶我。</p>
<p>接下来你将在iOS环境下构建关于架构模式的知识体系。我们将简要构建一些经典的例子，并在理论和实践上进行比较他们的不同。如果你需要更多关于任何一个特定的细节，请关注我。</p>
<a id="more"></a>

<p>掌握设计模式容易让人上瘾，所以要注意：阅读本文之前要问自己几个问题：</p>
<blockquote>
<p>谁应该持有网络请求：Model还是Controller?</p>
<p>如何在一个新的View中向ViewModel传递Model</p>
<p>谁创建了一个新的VIPER模块：Router还是Presenter</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191122152602.png" alt=""></p>
<hr>
<h2 id="为什么应该关心选用何种架构"><a href="#为什么应该关心选用何种架构" class="headerlink" title="为什么应该关心选用何种架构"></a>为什么应该关心选用何种架构</h2><p>因为如果你不这么做的话，总有一天，等这个类庞大到同时处理十几种事务，你会发现你根本无法从中找到对应代码并修改bug。当然，将这整个类了然于心是很难的，你会常常忘记一些重要的细节。如果你的程序已经处于这种状态了，那它很可能具有下面这些特征：</p>
<ul>
<li>这个类是UIViewController的子类</li>
<li>你的数据直接在UIViewController中进行存储</li>
<li>你的UIView基本什么都没做</li>
<li>你的Model只是一个单纯的数据结构</li>
<li>你的单元测试没有覆盖任何代码</li>
</ul>
<p>即使你认为自己遵守了苹果的指导，并按照苹果推荐的MVC设计规范进行开发，但还是遇到了这些问题。不要担心，这是因为苹果的MVC本身就存在一些问题，我们稍后会再来讨论它。</p>
<p>让我们定义一下好的架构应该具备的特点：<br>1、平衡的分配实体和具体角色的职责<br>2、把可测试性放在第一位（通过合适的架构，这将很容易实现）<br>3、易用性和低维护成本</p>
<h3 id="为什么要分配职责"><a href="#为什么要分配职责" class="headerlink" title="为什么要分配职责"></a>为什么要分配职责</h3><p>职责的分配能让我们在尝试搞清楚事情如何运作这一过程中保持一个正常的负荷。你可能会认为你投入的精力越多你的大脑越能适应更加复杂的东西，这没错。但是这个能力是非线性的，而且会很快达到临界点。所以降低复杂性的最好的方式是，根据<strong>职责单一原则</strong>将它的功能（职责）分配到多个实体中。</p>
<h3 id="为什么要可测试性"><a href="#为什么要可测试性" class="headerlink" title="为什么要可测试性"></a>为什么要可测试性</h3><p>对于那些已经添加了单元测试的项目来说，当他们增加一个新的功能或者重构一个复杂的类时会由单元测试告知失败与否，这多让人很放心啊。同时这也意味着这些测试项将在运行时帮助开发者找到问题，而如果这些问题发生在用户设备上的，解决他们通常会花费一周。</p>
<h3 id="为什么要易用性"><a href="#为什么要易用性" class="headerlink" title="为什么要易用性"></a>为什么要易用性</h3><p>这并不需要答案，但值得一提的是，最好的代码是那些从未写过的代码。所以，代码越少，bug就越少。这意味着，编写更少代码的愿望不应该仅仅由开发人员的懒惰来解释，而且你不应该为了采用更好的解决方案，而对其维护成本视而不见。</p>
<h2 id="MV-X-的要素"><a href="#MV-X-的要素" class="headerlink" title="MV(X)的要素"></a>MV(X)的要素</h2><p>如今我们又很多可选的架构方案：</p>
<ul>
<li>MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>VIPER<br>前三项方案是把应用程序的实体分为三类：</li>
<li><strong>Modes</strong> – 负责数据域和操作数据的数据访问层，例如’<strong>Person</strong>’类, ‘<strong>PersonDataProvider</strong>‘类。</li>
<li><strong>Views</strong> – 负责展示层（GUI），对于iOS环境就是指所有已‘<strong>UI</strong>’开头的类。</li>
<li><strong>Controller/Presenter/ViewModel</strong> – 是<strong>Model</strong>和<strong>View</strong>的中介，通常的职责是通过响应用户在<strong>View</strong>的操作改变<strong>Model</strong>，然后根据<strong>Model</strong>的变化更新<strong>View</strong>。</li>
</ul>
<p>这些实体的分割帮助我们：</p>
<ul>
<li>更好的理解他们</li>
<li>重用他们（通常是<strong>View</strong>和<strong>Model</strong>）</li>
<li>单独测试他们</li>
</ul>
<p>让我们开始讲解MV(X)模式，随后是VIPER</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="它原本是什么样的"><a href="#它原本是什么样的" class="headerlink" title="它原本是什么样的"></a>它原本是什么样的</h3><p>在讨论苹果的MVC版本之前，让我们看一下传统的MVC模式：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191124201633.png" alt=""></p>
<p>这个模式下，<strong>View</strong>是无状态的。它只是简单的被<strong>Controller</strong>渲染当<strong>Model</strong>变化的时候。想一下Web页面，当你点一个链接尝试跳转时，整个页面都会重新渲染。尽管可以在iOS应用程序中实现传统的MVC，但由于架构问题，这并没有多大意义—— 所有三个实体都是紧密耦合的，每个实体都知道其他两个。这正好降低了他们的重用性，而这又是你在程序中不想看到的。因为这个原因，我们将跳过编写传统MVC代码的示例。</p>
<blockquote>
<p>传统的MVC似乎不适合现代的iOS开发</p>
</blockquote>
<h2 id="苹果的MVC"><a href="#苹果的MVC" class="headerlink" title="苹果的MVC"></a>苹果的MVC</h2><h3 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191124202807.png" alt=""><br><strong>Controller</strong>是<strong>View</strong>和<strong>Model</strong>的中介，因此它俩互相不知道对方。可重用性最差的就是<strong>Controller</strong>，因为我们必须为复杂的业务逻辑提供一个位置，<strong>Model</strong>又不适合。</p>
<p>理论上，这看起来很简单，但是你总感觉有什么地方不对，是吧？你甚至听到人们解读MVC为<strong>Massive View Controller</strong>。也因此，视图控制器的简化成了iOS开发一个重要的课题。苹果只是采用传统的MVC并对其进行一些改进，为什么会出现这种情况呢?</p>
<h3 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191124205759.png" alt=""></p>
<p>Cocoa MVC鼓励你编写大量的视图控制器，因为它们是视图生命周期的一部分，很难说它们是独立的。尽管你有能力转移一些业务逻辑和数据转换工作到<strong>Model</strong>中，当需要转移工作到<strong>View</strong>时你仍然没有太多选择，因为大多数情况<strong>View</strong>的职责就是发送行为到<strong>Controller</strong>。视图控制器最终将成为一个所有东西的委托、数据源、负责调度和取消网络请求，等等。</p>
<p>这种代码，你肯定见过很多少次了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userCell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"identifier"</span>) <span class="keyword">as</span> <span class="type">UserCell</span></span><br><span class="line">userCell.configureWithUser(user)</span><br></pre></td></tr></table></figure>
<p>这个cell是<strong>View</strong>，直接通过<strong>Model</strong>进行配置，这明显违反了MVC的要求，但这种事情却经常发生，而且认为还不认为这是错的。如果你严格按照MVC的 做法，你应该在Controller里面配置cell，而不是将<strong>Model</strong>直接传递给<strong>View</strong>，但这样就会增加<strong>Controller</strong>的大小。</p>
<blockquote>
<p>Cocoa MVC 被称为 Massive View Controller是多么合理啊。</p>
</blockquote>
<p>这个问题还不是那么明显，直到提到单元测试（希望它存在于你的项目）。因为你的视图控制器跟View是紧耦合的，这将使得测试非常困难。所以你应该让你的业务逻辑和视图布局代码尽可能分割开来。</p>
<p>让我们看一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123; <span class="comment">// Model</span></span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingViewController</span> : <span class="title">UIViewController</span> </span>&#123; <span class="comment">// View + Controller</span></span><br><span class="line">    <span class="keyword">var</span> person: <span class="type">Person</span>!</span><br><span class="line">    <span class="keyword">let</span> showGreetingButton = <span class="type">UIButton</span>()</span><br><span class="line">    <span class="keyword">let</span> greetingLabel = <span class="type">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"didTapButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didTapButton</span><span class="params">(button: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> greeting = <span class="string">"Hello"</span> + <span class="string">" "</span> + <span class="keyword">self</span>.person.firstName + <span class="string">" "</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVC</span></span><br><span class="line"><span class="keyword">let</span> model = <span class="type">Person</span>(firstName: <span class="string">"David"</span>, lastName: <span class="string">"Blaine"</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">GreetingViewController</span>()</span><br></pre></td></tr></table></figure>

<p>这样根本没法测试，对吧？我们可以把greeting的赋值移到一个新的类GreetingModel中，然后分开测试它。但是我们无法在不直接调用UIView相关方法（viewDidLoad, didTapButton）的情况下测试任何外在的逻辑，而如果这样做，这些方法就导致所有view的刷新，所以这本身就是一个不好的单元测试。</p>
<p>事实上，在一个模拟器上加载和测试UIViews表现正常，不代表它在别的设备依然这样。所以我建议测试时移除单元测试对“宿主程序”的依赖，而直接测试代码。</p>
<blockquote>
<p><strong>View</strong>和<strong>Controller</strong>之间的交互行为无法通过Unit Tests进行。</p>
</blockquote>
<p>根据上面的说法，Cocoa MVC是一个相当不好的架构方案。让我们再来根据文章开头定义的好架构应有的特性来评价下它：</p>
<ul>
<li>职责分离 – <strong>View</strong>和<strong>Model</strong>是分离的，但<strong>View</strong>和<strong>Controller</strong>是紧耦合关系。</li>
<li>可测试性 – 由于不好的职责分离特性，只有<strong>Model</strong>层是可以测试的。</li>
<li>易用性 – 这几种架构模式中它的代码量是最少的。每个人都很熟悉这种模式，即使是一个经验有限的开发者也可以很容易的维护这份代码。</li>
</ul>
<p>如果你不打算投入很多事情在架构上，或者你感觉对于你们的小项目来说不值得投入过多维护成本，那你应该选择Cocoa MVC。</p>
<blockquote>
<p>Cocoa MVC 是开发速度最快的一种架构。</p>
</blockquote>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191127143603.png" alt=""></p>
<p>这是不是更苹果的MVC非常像？确实是这样的，它的名字叫做<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>。等一下，这是不是意味着苹果的MVC事实上就是MVP？不。你可以再观察下这个结构，<strong>View</strong>和<strong>Controller</strong>是紧耦合关系，作为MVP的中介者 – <strong>Presenter</strong>并没有管理视图控制器的生命周期，它里面也不含有布局代码，它的职责是根据数据的状态变化更新<strong>View</strong>，所以呢，<strong>View</strong>这一层就可以很简单的抽出来。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191127144422.png" alt=""></p>
<blockquote>
<p>我会告诉你，UIViewController也是View</p>
</blockquote>
<p>在<strong>MVP</strong>模式下，UIViewController的子类实际上是<strong>Views</strong>而不是<strong>Presenters</strong>。这种区别提供了极好的可测试性，但这是以开发速度为代价的，因为你必须手动绑定数据和时间，就像这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123; <span class="comment">// Model</span></span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GreetingView</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setGreeting</span><span class="params">(greeting: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GreetingViewPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(view: <span class="type">GreetingView</span>, person: <span class="type">Person</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showGreeting</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPresenter</span> : <span class="title">GreetingViewPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> view: <span class="type">GreetingView</span></span><br><span class="line">    <span class="keyword">let</span> person: <span class="type">Person</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(view: <span class="type">GreetingView</span>, person: <span class="type">Person</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showGreeting</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> greeting = <span class="string">"Hello"</span> + <span class="string">" "</span> + <span class="keyword">self</span>.person.firstName + <span class="string">" "</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingViewController</span> : <span class="title">UIViewController</span>, <span class="title">GreetingView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">GreetingViewPresenter</span>!</span><br><span class="line">    <span class="keyword">let</span> showGreetingButton = <span class="type">UIButton</span>()</span><br><span class="line">    <span class="keyword">let</span> greetingLabel = <span class="type">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"didTapButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didTapButton</span><span class="params">(button: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter.showGreeting()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setGreeting</span><span class="params">(greeting: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于装配（assembly）的重要说明"><a href="#关于装配（assembly）的重要说明" class="headerlink" title="关于装配（assembly）的重要说明"></a>关于装配（assembly）的重要说明</h3><p>MVP是第一个揭露三层模型装配问题的模式。我们不想让<strong>View</strong>和<strong>Model</strong>互通，因为在试图控制器（View）中执行装配操作是明显不对的，所以我们只能换个地方放装配的代码。例如，我们可以做一个应用范围的<strong>Router</strong>服务，它负责装配工作和<strong>View</strong>到<strong>View</strong>的展示。这个问题的出现不仅要在MVP中解决，在以下的几个模式中也都要解决。</p>
<p>我们看下MVP的特性：</p>
<ul>
<li>职责分离 – 我们将大部分职责分配给了<strong>Presenter</strong>和<strong>Model</strong>，而视图则什么都不需要做（上面的<strong>Model</strong>也是什么都不用做）</li>
<li>可测试性 – 非常好，我们可以通过静态的<strong>View</strong>测试大多数逻辑。</li>
<li>易用性 – 在我们上个简单示例中，代码量是MVC的两倍，但是它的逻辑是很清晰的。</li>
</ul>
<blockquote>
<p>在iOS中MVP模式意味着良好的可测试性和大量代码。</p>
</blockquote>
<h2 id="MVP-1"><a href="#MVP-1" class="headerlink" title="MVP"></a>MVP</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191127153028.png" alt=""><br>这是另一个MVP的样式 – 由视同控制器担当管理的MVP。这个变体中，<strong>View</strong>和<strong>Model</strong>是直接绑定的，<strong>Presenter</strong>(担当管理的控制器)仍然处理着来自<strong>View</strong>的操作，并且能够改变<strong>View</strong>。</p>
<p>但是通过上面的学习我们已经知道了，将<strong>View</strong>和<strong>Model</strong>紧耦合处理，这种不明确的职责分离是很糟糕的。这与Cocoa桌面开发中的工作原理类似。</p>
<p>跟传统MVC一样，我找不到要为这个有缺陷的架构写示例的理由。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="最新而且是最好的一个MV-X-类型"><a href="#最新而且是最好的一个MV-X-类型" class="headerlink" title="最新而且是最好的一个MV(X)类型"></a>最新而且是最好的一个MV(X)类型</h3><p><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a>是最新的MV(X)类型，希望它能解决我们之前讨论过的问题。</p>
<p>MVVM理论上看起来是很好的，<strong>View</strong>和<strong>Model</strong>我们已经很熟悉了，它俩之间的中介者由<strong>View Model</strong>表示。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191127155036.png" alt=""></p>
<p>这和MVP很像：</p>
<ul>
<li>MVVM也是把视图控制器当做<strong>View</strong></li>
<li>在<strong>View</strong>和<strong>Model</strong>之间没有紧耦合关系</li>
</ul>
<p>此外它的绑定逻辑很像MVP的监管版本；但是这次不是<strong>View</strong>和<strong>Model</strong>，而是<strong>View</strong>和<strong>View Model</strong>之间的绑定。</p>
<p>所以iOS当中的<strong>View Model</strong>到底是什么呢？它是UIKit独立于视图及其状态的表示。<strong>View Model</strong>调用<strong>Model</strong>执行更改，然后根据<strong>Model</strong>的更新再更新自己，因为我们绑定了<strong>View</strong>和<strong>View Model</strong>，第一个模型将相应的更新。</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>我在MVP部分明确提到过绑定，这次让我们再来讨论一下。绑定出自于MacOS开发，在iOS中是没有的。我们虽然可以通过KVO和通知完成这一过程，但是这样的绑定方式并不方便。</p>
<p>如果我们不想自己实现的话，有两个选项可供参考：</p>
<ul>
<li>一个是基于KVO的绑定库像<a href="https://github.com/Rightpoint/RZDataBinding">RZDataBinding</a>,<a href="https://github.com/DeclarativeHub/Bond">SwiftBond</a></li>
<li>完整的函数式编程工具，像<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>, <a href="https://github.com/ReactiveX/RxSwift/">RxSwift</a>, <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a>。</li>
</ul>
<p>如今当你听到“MVVM”，就应该想到ReactiveCocoa。因为它可以让你用很简单的绑定方式构建MVVM，几乎涵盖所有MVVM中的逻辑。</p>
<p>但是使用响应式框架会面临一个不好的现实：能力越大责任越大。使用reactive很容易将事情复杂化。也就是说，如果发生了一处错误，你需要花费很多时间去调试问题，可以简单看下响应式的调用堆栈。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191127163910.png" alt=""></p>
<p>在我们的示例中，响应式框架甚至KVO都是多余的，我们将使用showGreeting方法显式地要求<strong>View Model</strong>更新，并使用greetingDidChange回调函数的简单属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123; <span class="comment">// Model</span></span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GreetingViewModelProtocol</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting: <span class="type">String</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> greetingDidChange: ((<span class="type">GreetingViewModelProtocol</span>) -&gt; ())? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// function to call when greeting did change</span></span><br><span class="line">    <span class="keyword">init</span>(person: <span class="type">Person</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showGreeting</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingViewModel</span> : <span class="title">GreetingViewModelProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> person: <span class="type">Person</span></span><br><span class="line">    <span class="keyword">var</span> greeting: <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.greetingDidChange?(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> greetingDidChange: ((<span class="type">GreetingViewModelProtocol</span>) -&gt; ())?</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(person: <span class="type">Person</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showGreeting</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.greeting = <span class="string">"Hello"</span> + <span class="string">" "</span> + <span class="keyword">self</span>.person.firstName + <span class="string">" "</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingViewController</span> : <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> viewModel: <span class="type">GreetingViewModelProtocol</span>! &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.viewModel.greetingDidChange = &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] viewModel <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.greetingLabel.text = viewModel.greeting</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> showGreetingButton = <span class="type">UIButton</span>()</span><br><span class="line">    <span class="keyword">let</span> greetingLabel = <span class="type">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>.viewModel, action: <span class="string">"showGreeting"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVVM</span></span><br></pre></td></tr></table></figure>

<p>再次回来用这三个特征验证一下：</p>
<ul>
<li>职责分离 – 这在我们的小示例还无法体现，但是MVVM的<strong>View</strong>比着MVP的<strong>View</strong>有着更多的职责。因为前者通过<strong>View Model</strong>建立绑定更新它的状态，后者仅仅是把所有事件都交给<strong>Presenter</strong>，不更新自己。</li>
<li>可测试性 – <strong>View Model</strong>是不知道<strong>View</strong>的，这可以让我们很容易的对它进行测试。<strong>View</strong>可能也需要测试，但因为它依赖UIKit，你可能想跳过它。</li>
<li>易用性 – 它有河MVP模式相同的代码量，但是实际项目中，你不得不把所有事件通过<strong>View</strong>传给<strong>Presenter</strong>，然后还要手动更新<strong>View</strong>，比较而言，MVVM使用绑定将更加简洁。</li>
</ul>
<blockquote>
<p>MVVM是很有吸引力的，因为它包含了前面提到的优点，此外通过View层的绑定，也不需要额外的代码处理View更新。测试性也还不错。</p>
</blockquote>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><h3 id="把乐高的搭建流程应用到iOS设计模式"><a href="#把乐高的搭建流程应用到iOS设计模式" class="headerlink" title="把乐高的搭建流程应用到iOS设计模式"></a>把乐高的搭建流程应用到iOS设计模式</h3><p>VIPER是我们最后一个候选模式，有趣的一点是它不属于MV(X)类型。</p>
<p>目前为止，你必须同意职责的粒度是很重要的。VIPER在划分职责层面又做了一次迭代，它将项目划分成5层。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191203220802.png" alt=""></p>
<ul>
<li><strong>Interactor</strong>– 包含跟数据（<strong>Entities</strong>）和网络相关的业务逻辑，像是创建新的实例对象后者从服务器拉取数据。出于这些目的，你也可以使用Services和Mananger类完成功能，但这就不属于VIPER模块，而是外部依赖类。</li>
<li><strong>Presenter</strong> – 包含UI相关的业务逻辑，调用<strong>Interactor</strong>中的方法。</li>
<li><strong>Entities</strong> – 普通的数据对象，不是数据访问层，因为这是<strong>Interactor</strong>的责任。</li>
<li><strong>Router</strong> – 负责VIPER模块之间的切换。</li>
</ul>
<p>基本上，VIPER模块可以是一整屏内容，也可以是你应用中完整的用户行为 – 想一下授权行为，它可以在一个或者几个相关联的界面。“乐高”方块应该多小呢？这取决于你。</p>
<p>如果我们将它和MV(X)类比，会发现一些在职责划分上的区别：</p>
<ul>
<li><strong>Model</strong>(数据交互)逻辑转移到了包含<strong>Entities</strong>数据结构的<strong>Interactor</strong>中。</li>
<li>只有<strong>Controller/Presenter/ViewModel</strong>这种UI表示层的职责转移到了<strong>Presenter</strong>中，不包含数据。</li>
<li><strong>VIPER</strong>是第一个明确导航职责的模式，并通过<strong>Router</strong>解决这个问题。</li>
</ul>
<blockquote>
<p>在iOS应用中用一个优雅的方式处理跳转问题确实是一个挑战，MV(X)模式没有处理这个问题。</p>
</blockquote>
<p>该示例不涉及模块之间的<strong>路由</strong>或<strong>交互</strong>，因为MV(X)模式根本不涉及这些主题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123; <span class="comment">// Entity (usually more complex e.g. NSManagedObject)</span></span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreetingData</span> </span>&#123; <span class="comment">// Transport data structure (not Entity)</span></span><br><span class="line">    <span class="keyword">let</span> greeting: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> subject: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GreetingProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">provideGreetingData</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GreetingOutput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receiveGreetingData</span><span class="params">(greetingData: GreetingData)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingInteractor</span> : <span class="title">GreetingProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">GreetingOutput</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">provideGreetingData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>(firstName: <span class="string">"David"</span>, lastName: <span class="string">"Blaine"</span>) <span class="comment">// usually comes from data access layer</span></span><br><span class="line">        <span class="keyword">let</span> subject = person.firstName + <span class="string">" "</span> + person.lastName</span><br><span class="line">        <span class="keyword">let</span> greeting = <span class="type">GreetingData</span>(greeting: <span class="string">"Hello"</span>, subject: subject)</span><br><span class="line">        <span class="keyword">self</span>.output.receiveGreetingData(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GreetingViewEventHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didTapShowGreetingButton</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GreetingView</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setGreeting</span><span class="params">(greeting: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPresenter</span> : <span class="title">GreetingOutput</span>, <span class="title">GreetingViewEventHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">GreetingView</span>!</span><br><span class="line">    <span class="keyword">var</span> greetingProvider: <span class="type">GreetingProvider</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didTapShowGreetingButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingProvider.provideGreetingData()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receiveGreetingData</span><span class="params">(greetingData: GreetingData)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> greeting = greetingData.greeting + <span class="string">" "</span> + greetingData.subject</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingViewController</span> : <span class="title">UIViewController</span>, <span class="title">GreetingView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> eventHandler: <span class="type">GreetingViewEventHandler</span>!</span><br><span class="line">    <span class="keyword">let</span> showGreetingButton = <span class="type">UIButton</span>()</span><br><span class="line">    <span class="keyword">let</span> greetingLabel = <span class="type">UILabel</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"didTapButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didTapButton</span><span class="params">(button: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.eventHandler.didTapShowGreetingButton()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setGreeting</span><span class="params">(greeting: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assembling of VIPER module, without Router</span></span><br><span class="line"><span class="keyword">let</span> view = <span class="type">GreetingViewController</span>()</span><br><span class="line"><span class="keyword">let</span> presenter = <span class="type">GreetingPresenter</span>()</span><br><span class="line"><span class="keyword">let</span> interactor = <span class="type">GreetingInteractor</span>()</span><br><span class="line">view.eventHandler = presenter</span><br><span class="line">presenter.view = view</span><br><span class="line">presenter.greetingProvider = interactor</span><br></pre></td></tr></table></figure>

<p>让我们再一次对比那几个特征：</p>
<ul>
<li>职责分离 – 毫无疑问，VIPER是职责分离做的最好的。</li>
<li>可测试性 – 职责分离越好，可测试性当然也会更好</li>
<li>易用性 – 你可能已经猜到了，上面两项意味着维护成本的提升。你必须写很多处理各个类之间交互的代码。</li>
</ul>
<h3 id="所有这个乐高模式到底怎么样呢？"><a href="#所有这个乐高模式到底怎么样呢？" class="headerlink" title="所有这个乐高模式到底怎么样呢？"></a>所有这个乐高模式到底怎么样呢？</h3><p>当使用VIPER时，如果你感觉就像是通过乐高方块搭建帝国大厦，这就意味着出现了问题。不应该过早在你的应用中使用VIPER，你需要考虑简便性。有些人不注意简便性，直接使用VIPER，会有点大材小用。我猜测很多人是这么想的，他们的应用迟早都会发展到适用VIPER的复杂程度，所以早晚都会做的事，即使现在维护成本高也应该继续做下去。如果你就是这么想的，我推荐你试一下<a href="https://github.com/strongself/Generamba">Generamba</a> – 一个生成VIPER组件的工具。虽然对我个人来说，这感觉就像使用自动瞄准系统而不是简单的弹射。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经讲解了几个架构模式，希望你能解答曾经困扰你的问题。我敢肯定你也意识到了架构模式的选择没有最好这一说，它取决于你在特定环境下权衡利弊之后做的选择。</p>
<p>所以，在一个应用中出现混合一种混合的架构模式也是很常见的。例如，你一开始使用MVC，然后你发现有一个界面的逻辑变得很复杂，然后你转向了MVVM，但也是仅限于这个界面。你不必重构别的使用MVC的界面，因为它原本就是工作的好好的，而且这两个架构模式是很容易兼容的。</p>
<blockquote>
<p>事情应该力求简单，不过不能过于简单 – 阿尔伯特·爱因斯坦</p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>感谢大家的帮助</title>
    <url>/2019/11/09/thanks_letter/</url>
    <content><![CDATA[<h2 id="好消息"><a href="#好消息" class="headerlink" title="好消息"></a>好消息</h2><p>开始水滴筹之后，父亲治病的消息大家就都知道了，期间收到了很多来自亲友的支持和帮助。先告诉大家好消息，父亲手术完了，并且身体恢复一切正常，已于11月8号中午从重症监护室转到无菌病房，还需要在里面待够五天才转到普通病房。关于看病所需要的筹款，也得到了解决。今天晚上7点左右，我已经终止了这次筹款。</p>
<p>看病资金问题能快速解决，除了来自水滴筹的筹款，还有就是公司的大力支持。三位老板帮助了2万元，还破格提前给我发了年终奖，算上水滴筹中的63588元，一直到出院应该是没什么问题了。</p>
<a id="more"></a>
<h2 id="感谢公司"><a href="#感谢公司" class="headerlink" title="感谢公司"></a>感谢公司</h2><p>真的非常感谢公司给予的支持，啥也不说了，我要夸一夸他。我们公司叫乐信圣文，是一家全球领先的移动出海应用开发商，致力于为全球用户提供卓越的移动应用，作为中国移动互联网公司出海的新锐领军者，产品在全球移动端月活超过2000万，累计用户超过3亿。目前正在招聘Android、iOS、Unity、web前端、Python等开发工程师，另外中高级测试、数据分析师、产品运营、MG动画师也都职位空缺。大家有要换工作的或者朋友换工作的，可以推荐来我们这。这么好的老板，这么有前景的公司还等什么？详情可以问我或者关注公司微信公众号：乐信圣文Learnings。</p>
<h2 id="感谢所以提供帮助的小伙伴"><a href="#感谢所以提供帮助的小伙伴" class="headerlink" title="感谢所以提供帮助的小伙伴"></a>感谢所以提供帮助的小伙伴</h2><p>其次来自小伙伴的支持也让我非常感动，很多感动瞬间，其中有两个场景让我特别难忘。一是刚开始发起水滴筹时，当时心里慌慌的，根本不知道接下来事情会怎么发展，也不敢看手机。但不到5分钟时间，大学室友就开始齐刷刷的给我打钱，给我加油，当时铺天盖地的收款和问候消息直接就给我感动哭了，我真是爱死你们了。还有一件事是来自于一个前同事，当时我们只有QQ这一种联系方式，因为QQ用的很少，直到昨天才看到他的祝福和转账。他因为公司问题两个月都没收到工资了，知道我的情况之后，还执意给我打钱。真的是折煞我也！不知道说什么好了。</p>
<p>其实每次转发时我都怕打扰到大家，因为水滴筹里的各种求转发的术语，很像牛皮癣广告。但你们却对我很宽容，帮我转发，号召别人帮我转发，很多人还多次打款，真的非常感谢。我知道大家都不容易，各种生活琐事，结婚，买房，都是花钱的地方，我用你们的钱，也很过意不去，这里给大家道个歉，给你们添麻烦了。我想说的是，你们帮助我，给我爸治病这些钱不是捐给我的而是借给我的，我会在之后经济允许的情况下把钱都一一还给大家。</p>
<h2 id="大家一定要给我面子啊，这笔钱我是要还的"><a href="#大家一定要给我面子啊，这笔钱我是要还的" class="headerlink" title="大家一定要给我面子啊，这笔钱我是要还的"></a>大家一定要给我面子啊，这笔钱我是要还的</h2><p>上午我用了将近一个小时时间把水滴筹的捐款记录反复核对了两遍，只要是能对应上名字的人我都用小本本把人名和捐款数额记录下来。本次捐款收到了750次帮助，我记录下来的人名有120多个。也就是说有很大一部分人没有联系到，这其中有一大部分来自于我爸的朋友、同行，教会的人，一部分亲戚，还有就是所有参与转发水滴筹扩散之后的朋友圈成员。好像要把所有人都确认下身份也不现实，所以对于那些无法确知是谁且捐款数额较多的，我都在捐款记录的下面留了言，询问联系方式。如果能联系上，钱还是会还给你的。</p>
<p>这里的还钱是除了老板们的2万哈，不是不还，是因为我想换一种还法，通过努力工作的方式回报公司，帮你们多宣传多招人（主要还是有点多，他们又都是大佬，肯定不差钱）。</p>
<p>可能很多人捐钱时就没打算再要回来，但是我是有打算还的。我选择还大家钱是因为我知道挣钱的不易。我有困难你们帮我，我困难过去了，理应把钱还给你们。这是我的心愿，不还你钱我会不舒服的，所以大家为了照顾我的感受不能推脱啊。</p>
<p>当然了这个还钱过程肯定是不会快的，这段时间确实用钱厉害，等过了这个坎，我会慢慢地开始还大家钱。如果你因为什么事情着急用钱，可以先找我；如果你的钱迟迟不给，排除被遗漏的可能性，那就说明在我眼里你是土豪，土豪的钱就最后还啦。</p>
<h2 id="更多近况"><a href="#更多近况" class="headerlink" title="更多近况"></a>更多近况</h2><p>另外关于这几天的详细进展，以及我在七院里的一些见闻，大部分是记录下来了。大家有兴趣的话可以访问这个网站进行了解：<a href="https://zhangferry.com">zhangferry.com</a></p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>关于水滴筹</title>
    <url>/2019/11/08/shuidi/</url>
    <content><![CDATA[<p>很多朋友因为我的原因关注并参与到水滴筹中，有些小伙伴因为担心水滴筹有手续费用就直接把钱打给我。为了打消大家的顾虑，我花了些时间理解水滴筹背后的一些事情。</p>
<a id="more"></a>
<h2 id="水滴筹的背景"><a href="#水滴筹的背景" class="headerlink" title="水滴筹的背景"></a>水滴筹的背景</h2><p>水滴筹是由水滴公司于2016年推出的一项针对疾病救助的筹款业务。在水滴筹之前的筹款平台领头羊是轻松筹（2014年推出），当时包括轻松筹在内的平台都会收取2%左右的手续费。水滴筹却一开始就不收取任何手续费，筹款所得资金全部归收款人（目前仅收取微信提现产生的手续费：0.1%）。免手续费肯定更多人使用，慢慢的水滴筹不断从轻松筹手里抢占市场，目前市场份额已经第一（轻松筹现在也免手续费了）。</p>
<h2 id="水滴的发展"><a href="#水滴的发展" class="headerlink" title="水滴的发展"></a>水滴的发展</h2><p>说水滴筹的发展就不得不说水滴的创始人沈鹏，他是美团的第10号员工。在美团，沈鹏战功卓著：早期带着5万元单枪匹马杀到天津，第二个月就将天津市场份额从第七提升到第一；23岁升任大区经理，通管北京、天津、山东同400人团队，参与“千团大战”；26岁，跟随王慧文立项美团外卖，带领团队在一年多的时间里把美团外卖做的行业第一。所以他的市场把控和感知能力是非常强的。</p>
<p>线下地推是美团的强项，这个强项也被带到了水滴公司，很多早期水滴员工都是沈鹏从美团挖来的。早期水滴筹获取流量的重要砝码就是地推，他们下沉到渗透率并不高的三四五线城市和农村地区，招募大量兼职人员，志愿者辅导当地人筹款；他们在各个医院，各个科室留下名片，传单，立起易拉宝。不光鼓励患者加入，他们还会免费指导筹钱金额怎么写，求助说明怎么写，怎么转发（一次发三条可以占满手机一屏）效果好，甚至哪些时间点转发效率更高都会说。完美复制美团“农村包围城市”的策略。</p>
<p>这种形式让水滴筹快速获取了大量用户，也带来了巨大的流量。快速发展的水滴公司，目前估值近30亿，腾讯是最大的投资方。</p>
<h2 id="盈利模式"><a href="#盈利模式" class="headerlink" title="盈利模式"></a>盈利模式</h2><p>前面说了水滴筹是免手续费的，地推人员也都是需要发工资的，那它怎么赚钱呢？</p>
<p>首先按照水滴筹的规则，一次筹款是30天，在这30天内只要不发起提现，水滴筹有权将这笔款项委托给第三方进行资金托管，水滴筹至今累计筹款200多亿，平均每月就将近5亿的流水，这产生的利息是非常高的。</p>
<p>另外水滴筹共有超过2.5亿名爱心人士参与帮助，累计产生6.5亿人次捐助活动。这巨大的流量推动宣传了水滴公司的另外两项业务：水滴互助和水滴保。这两项业才是赚钱的，它们的区别是：<strong>水滴筹，捐款人，是来做慈善的；水滴互助，互助会员，是希望加入一个低成本的互助计划。水滴保，主动跑来的投保人，是希望找到性价比高的保险产品。</strong></p>
<p>其中水滴互助是水滴公司发展的第一项业务（后来支付宝出了个相互宝，跟它的模式基本一样，一人生病，大家帮忙分摊），水滴筹的产生更深层的目的是给水滴互助导流。所以水滴公司的商业变现模式就是通过水滴筹这种公益互助类产品聚集高黏性的用户和流量，然后再通过水滴互助、水滴保等商业业务板块进行变现。</p>
<p>所以他们肯定是赚钱的啦，只不过是一面做“慈善”，一面做生意。</p>
<h2 id="目前问题及现状"><a href="#目前问题及现状" class="headerlink" title="目前问题及现状"></a>目前问题及现状</h2><p>水滴筹目前已经过了市场掠夺期，但仍有些问题需要解决。水滴筹在前期的审核是相对宽松的，最主要的诊断证明和身份证号，只要没问题，就可以进入审核阶段，说是5分钟，有时基本1分钟就好了。可以让你快速的开始募捐，提现时才会需要你出示更加详细的诊断报告，病历，医院消费清单，银行卡信息等。这些都只是确认你真的生病了，但是是否贫困，其实是没有确认的，因为为了一个筹款的人就去当地调查也不现实，这也不好确认。不过这也会带来问题，有可能导致“滥用众筹”，“滥用爱心”，此前某德云社相声演员名下有房有车却筹款惹来的争议就是此类。</p>
<p>虽然水滴筹的审核机制受到争议，但我们并不能否认其存在的社会价值，它切切实实的帮助了很多人。在未来的监管中，要在防范风险与鼓励创新之间寻求适当的平衡，可能是监管部门和水滴公司需要认真思考和探讨的问题。如今，对于渴望疾驰的水滴公司来说，要想持续发展，关键还是“不忘初心”。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么会得尿毒症</title>
    <url>/2019/11/07/2019_11_7/</url>
    <content><![CDATA[<p>看了父亲的病历，再结合之前了解的一些情况，我试着分析一下为什么会得尿毒症。</p>
<h2 id="一些医学知识"><a href="#一些医学知识" class="headerlink" title="一些医学知识"></a>一些医学知识</h2><p>关于肾脏：</p>
<blockquote>
<p>肾脏有很重要的代谢排毒功能，可以清除体内经由食物消化所残留的尿素、尿素氮、肌酸酐等，也会排出水分，维持体内的电解质平衡，甚至是控制血压高低起伏、活化维生素 D 的重要器官。此外，肾脏与肝脏一样，也是体内清除药物的重要器官，这也是为何肾功能不好时，就容易发生药物过量或中毒后遗症的原因。可见肾脏是何等的重要！等到肾脏的功能持续恶化到只剩下不到正常的 10% 时，才较容易出现包括恶心、水肿、高血压、倦怠无力、抽筋等症状，一旦造成更严重的尿毒症时，只能透析治疗。</p>
</blockquote>
<a id="more"></a>

<p>其中衡量肾脏功能健康程度有个很重要的指标，肌酐：</p>
<blockquote>
<p>肌酐是肌肉在人体内代谢的产物，临床常用来衡量肾功能的健康程度。正常范围是54-106umol/L。</p>
</blockquote>
<p>痛风：</p>
<blockquote>
<p>痛风是一种单钠尿酸盐(MSU)沉积所致的晶体相关性关节病，与嘌呤代谢紊乱及(或)尿酸排泄减少所致的高尿酸血症直接相关，属代谢性风湿病范畴。痛风可并发肾脏病变，严重者可出现关节破坏、肾功能损害，常伴发高脂血症、高血压病、糖尿病、动脉硬化及冠心病等。</p>
<p>因为痛风常发于指关节，痛起来是那种深入骨头的痛，取自“痛疯”的谐音。</p>
</blockquote>
<h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><h3 id="2007年"><a href="#2007年" class="headerlink" title="2007年"></a>2007年</h3><p>2007年，爸爸来北京打工已经7、8年左右了。凭借着勤奋和聪明，他从一个蹬板车买花的小贩变成了一个接小区别墅建筑项目的小老板，生意上虽然越来越好，很多事上爸爸还是喜欢亲力亲为。</p>
<p>那时正赶上夏季，爸爸要给人做葡萄架，一个葡萄架工期差不多是10人天，因为没有跟别的事赶在一起，爸爸就一个人做了。做木工活，使用频率最高的工具就是电锯。他对流程和工具的使用已经是很熟练了，但那次可能是走神了或者预估错误，没有把握好电锯的切割幅度，一下切中了小拇指。虽然没有整个切掉，但是骨头都切断了，很血腥的一幕。紧接着送去医院，医生在手指中间接了一根钢针，保住了手指。</p>
<p>在调养期间，为了防止发炎，打了很多抗生素也吃了很多消炎药。我们总说伤筋动骨一百天，这个调养也将近持续了一百天。这一点虽然没有体现的病历中，但我隐隐感觉，这可能就是后面一系列事件的引子。</p>
<h3 id="2008-2009年"><a href="#2008-2009年" class="headerlink" title="2008-2009年"></a>2008-2009年</h3><p>2008年左右，父亲感觉左脚大拇指外侧疼痛，频繁几次之后就去了北京解放军301医院做检查。当时检查为肌酐80（umol/L），被医生诊断为通风，并建议控制饮酒。当时吃了别嘌醇等药物进行治疗，很快疼痛的症状消失，就没有再去医院进行检查。</p>
<p>一直以来父亲都爱喝啤酒，因为北京这边亲戚朋友也比较多，大家不忙的时候常会一块聚聚。父辈那些人基本都爱喝酒，坐到一起，打牌，喝酒，吃肉，经常几天就一次，一喝就是酩酊大醉。虽然母亲经常批评父亲不要喝酒，但父亲感觉不疼了就是病好了，再加上朋友劝酒，自己又想喝，也没有加以控制。为了这事他被母亲不知吵了多少次。</p>
<p>关于痛风，目前还无法根治的，只能通过调养，延缓病情。而这其中最重要的就是要限制嘌呤的摄入，啤酒嘌呤虽然含的不多，但容易喝过量也就导致体内嘌呤大量增加。</p>
<h3 id="2010-2011年"><a href="#2010-2011年" class="headerlink" title="2010-2011年"></a>2010-2011年</h3><p>大概一年之后，爸爸又出现了左脚大拇指疼痛的症状，而且这次要比上一次严重。再去北京解放军301医院检查，肌酐已经涨到200，被诊断为“慢性肾功能不全”。痛风患者中大约有40%的人会患有慢性肾病，因为饮酒的原因由痛风发展到了慢性肾病。</p>
<p>之后父亲也意识到了问题的严重性，开始慢慢戒啤酒。也是从这时开始，爸爸之后吃药就没再断过。确诊为“慢性肾功能不全”之后，从医院就拿了一个月的药。这期间效果一直一般，爸妈决定换个医院试试。然后去了北京武警医院，医生对病情的诊断是一致的，但对于病情的治疗并不乐观，说慢性肾病也是一个需要调理的疾病，并不能吃某种药就根治。这次在这里又拿了1个月的药。</p>
<p>对于医生不能彻底根治的说法，他们有些灰心。后来在电视上看到有家中医院关于治疗慢性肾病的广告，他们宣传的效果非常好，这给他们带来了一些希望。虽然知道大医院才更靠谱一些，他们还是去了那个医院，并开了3个月的中药。中药熬出来之后都是非常苦的，但是为了治病，父亲皱着眉头也都坚持把药喝下去的。期间药吃完了就再去买，都是一买几个月的。</p>
<p>虽然父亲一直生病，但是并不影响干活，只要脚不疼他忙起来依旧生龙活虎的。这段时间家里的经济状况也越来越好，当时很多亲戚结婚或者盖房来我家借钱，父亲都是慷慨解囊。</p>
<h3 id="2012年"><a href="#2012年" class="headerlink" title="2012年"></a>2012年</h3><p>到2012年暑假，我高考完来北京。爸爸身体已经出现一些症状：特别容易困，脚浮肿。有一天上午他需要到一个客户那里办事，我陪他一起去，车刚开到一半，父亲就说，开不了了，需要休息一会。然后停到一个地方，睡了20分钟，再继续走。当时脚也经常性的水肿，鞋都只能穿宽松的。</p>
<p>病情持续恶化，一天中午，父亲躺在床上不起来，被母亲发现时，他眼睛里面布满了血丝。我当时正在场，看到这个场景，只感觉心里被重重击打了一下，很恐慌，想哭却哭不出来。我背着他坐上车，那天直接去了北大医院，进入重症监护室。</p>
<p>医生已经下了病危通知书，他冷酷无情地告诉我跟母亲，病人随时有可能遭遇不测，请提前做好心理准备。我跟妈妈都哭了出来，那是我第一次近距离接触死亡。</p>
<p>过了几个小时，医生告诉我们父亲已经脱离了危险，并被确诊为尿毒症（慢性肾脏病5期），肌酐达到了1200。进入尿毒针阶段就只有两种方法维持生命了，透析和肾移植。因为肾移植手术不是想做就能做的，需要等待合适肾源，所以前期只能通过透析维持。度过危险期之后，由于北大医院病房紧张，父亲被转到了北京航空医院进行透析治疗。当时在航空医院住了将近一个月时间才恢复身体出院。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>1、饮酒和一些药物</strong></p>
<p>病根在痛风上，但痛风的病因和发病机制尚不清楚。但有些诱发因素，例如大量摄入动物内脏，贝类海鲜等高嘌呤食物，还有酒精的摄入，特别是啤酒。当然还有可能导致血尿酸增高的药物。</p>
<p>因为已经无从查证父亲当时手指受伤都吃了哪些药，动物内脏和贝类他也不喜欢吃，只能猜测那时的用药和父亲本身喜欢喝啤酒共同造成了痛风的发生。</p>
<p><strong>2、中药要慎重，去大医院看病</strong></p>
<p>痛风发展成为慢性肾炎，是有很大概率的，但是保养得当也可以控制的很好。但是在短短两年多的时间 就从慢性肾脏病1期发展到5期确实太快了，很多人根本不会发展到5期，或者是很多年之后才会发展恶化到尿毒症阶段。所以我就十分怀疑是吃中药阶段导致的病情加重。</p>
<p>关于中药治疗肾病的效果，我看了一些网上的讨论，是还不错的，有用中药调理这种说法。那就大概率是被那个广告医院给坑了，喝中药阶段一点改善没有，而且中药本身会含有很多非药效的杂质，喝到体内会大大增加肾的负担。</p>
<p><strong>3、定期检查</strong></p>
<p>还有一点是如果不能保证吃的药一定就对病情有帮助，那就需要定期去医院检查，一个是了解病情处在哪个阶段，一个就是能看出来当时再吃的那个药是否有作用。</p>
<p>更重要的一点一定要去大医院啊。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>七院第三天（11月5号）</title>
    <url>/2019/11/05/2019_11_5/</url>
    <content><![CDATA[<p>手术完成就是渡过了最大的难关，其他时间爸爸都是在重症监护室由专门护工照顾的。实际也不需要那么多人手，先后送走了三姨姨父，弟弟，还有两位叔叔，就我自己留在医院。平常需要买什么吃的，里面护士直接给我打电话，我买好送过来。</p>
<a id="more"></a>
<p>这天早上是鸡蛋小米粥，已经不需要萝卜水了，中午要吃肉丝面。听到爸爸要吃肉丝面很开心，因为这是除了小米粥鸡蛋之外第一个非常规食物。但是可能是我没考虑周到，面太长了，汤也有点少，他吃的不方便，只吃了两口。之后根据护士交代给他买了一包口香糖。</p>
<p>再晚些时候护士打电话说他想看书。因为里面不让玩手机，也没什么娱乐措施，除了睡觉吃饭没别的事，很容易无聊。附近就一家卖教辅资料的书店，在一堆小学生读物中，我挑了本《中外名人故事》。</p>
<p>下午探视时状态好很多，声音也不再那么沙哑了。感觉状态越来越好了。</p>
<p>三姨一直在家盼着，说你爸有什么情况随时汇报，姥爷每天上午打来一次电话询问情况，大姨，三姨，小姨也都经常打电话过来。</p>
<p>我这几天还是因为睡眠问题，状态不佳，特别是到了下午。困得不行就坐在台阶，往腿上一趴睡着了，但20分钟就醒了，那石板台阶是真的硬。</p>
<p>在监护室外面一直待到晚上十点钟，见里面一直没有消息，就回到了附近租的房子准备休息。洗个澡，躺下睡觉，这可能是近几年来睡得最香的一个晚上了。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>七院第二天（11月4号）</title>
    <url>/2019/11/04/2019_11_4/</url>
    <content><![CDATA[<h2 id="订饭"><a href="#订饭" class="headerlink" title="订饭"></a>订饭</h2><p>五点半起床。医生嘱咐手术完第二天需要喝米油（小米粥虑掉小米），还有喝萝卜水。一般来说术后6小时宜服用一些排气类食物，如萝卜汤，帮助因麻醉而停止蠕动的胃肠道保持运作，以肠道排气作为可以进食的标志。</p>
<a id="more"></a>
<p>送完这两样东西，我们就在外面等着了。因为这个是整个医院的手术室，大大小小的手术都从这里进入。一上午有陆续五个人先后进入手术室，还有一名孕妈妈，没多久她被推出来要转到别的病房。病床从旁边经过，我看到母亲安静的闭着眼睛，小宝宝被裹的严严实实的只漏一个小脑袋，被放在母亲腿间，后面一群家人跟着病床，多么美好的画面啊！</p>
<p>中午监护室大夫打电话说爸爸需要喝小米粥，因为不再是米油，就让我高兴了一下。</p>
<h2 id="视频通话"><a href="#视频通话" class="headerlink" title="视频通话"></a>视频通话</h2><p>下午5点到了探视时间，有一间专门的小小的探视房间，里面有两部电话，两台电视。可以通过这里接通各个病床上面的监视器，看到病人的情况，然后通过电话跟病人对讲。我看到前面两个人的通话场景，一个清晰，一个稍微模糊一点，还跑到了画面清晰的那一对排着。离手术完成已经19个小时了，非常想看看爸爸现在的情况。满怀期待地接通电话之后，大夫说，张中线床头摄像坏了，等会通过护士手机进行视频。</p>
<p>通过护士手机接通视频，看爸爸状态还可以，我问他感觉怎么样，他说，还好。虽然是“还好”但听他声音沙哑，不免还有些担心，不敢跟他讲太多话。问旁边大夫声音沙哑问题，他说全麻手术喉部插管引起的肿胀，需要一段时间的恢复。晚上吃饭还需要喝萝卜水。挂完电话就给爸爸准备萝卜水去了。</p>
<p>把跟爸爸通话的情况拍上照片发给亲戚们，告诉他们恢复的挺好。</p>
<h2 id="开始水滴筹"><a href="#开始水滴筹" class="headerlink" title="开始水滴筹"></a>开始水滴筹</h2><p>三姨给我打电话催我赶紧弄水滴筹。一开始我是有些抵触这个事情的，因为手术费手术费凑齐了，还有感觉水滴筹这个事情有点抹不开面子。但是想到重症监护室每天一万多的花费，下个月4万的信用卡，再之后的无菌监护室5天，继续住院10天，还有后期每周一次检查，抗排异药要吃好几年，这些都是很大一笔花费。现在筹钱不管多难都比以后为钱发愁好。想通了这些我联系了一个附近水滴筹的对接人，跟他说明了情况，也问了一些他们那边关于审核，筹款，提现的手续。然后就开始了朋友圈里水滴筹。</p>
<p>发出去后我还恍恍惚惚的，很快就会被大家注意到，不知道即将到来的是什么，我甚至都不敢看手机。5分钟后大学室友那几个小伙子联系到我，他们五个齐刷刷的给我打钱，并祝福我爸早日康复。那会回复都回复不过来，被他们的行为感动的不行。真的，我们609无论做什么事都是齐齐整整的，毕业前这样，毕业后也是这样，很多次聚会我们的团结都让其他同学们羡慕，我们是我一辈子的好兄弟。</p>
<p>可能这段时间确实太累了，将近两天基本没怎么休息过，一直在顶着各种压力前进，那么一瞬间因为室友的关怀而放下压力的时候，竟不自觉哭了出来。</p>
<p>再过了一会张弛给我打电话说，你急用钱先借你1万，我刚买完房手头不是很宽裕，如果不够再开口。张弛是高中同学，大学各忙各的基本没怎么交流过，毕业之后又几年了，有事情还惦记着我，真的很感动。</p>
<p>然后再去看水滴筹上面的筹款情况，亲戚，公司领导，同事，同学，朋友都有帮助并留下祝福的话。我翻看着，感觉到一股一股的能量不断注入体内。我会好好加油的，伴着大家的祝福，一定会顺利度过这道难关。</p>
<p>然后跟女朋友打电话，跟她说水滴筹的事情，她表示很理解，还说之前也想过这个事，但感觉我爱面子不会同意。她也很心疼我，看我这样还数落我，你每天工作时间那么长，家里的事还就你一个人扛，工作几年攒的钱全搭进去了，你多大能耐啊。我理解她，因为本来今年许诺她买房结婚的，因为我爸的事肯定也耽误了。其实这一圈最对不起的就是她。她可能也感觉话说重了，又反过来安慰我照顾好自己，照顾好我爸。</p>
<p>不知从什么时候开始，无论发生什么事情，我都不再埋怨，而只是去想怎么处理好它。命运是太不公平了，把一个完整的家破坏的零零碎碎，母亲病故，父亲大病需要治疗，弟弟结婚几年还一事无成，所有的事情都需要我一人承担。之前我也会恨的用拳头砸墙，但是现在不会了，我知道这是我应该做的，我感觉自己可以做到，然后就去做了。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>七院第一天（11月3号）</title>
    <url>/2019/11/03/2019_11_3/</url>
    <content><![CDATA[<h2 id="抵达郑州"><a href="#抵达郑州" class="headerlink" title="抵达郑州"></a>抵达郑州</h2><p>二号中午我爸打电话来医院这边配型成功，让三号早上来做手术。我得知这个消息有些开心也有些担忧，开心是因为盼了八个多月的肾源终于有了消息，担忧是紧接着将是一场大手术，不管医院怎么保证手术成功率，肾移植手术本身都是一项大手术。</p>
<p>我和弟弟是二号晚上9点半的火车，因为当天才进行买票，只有硬座了，三号早上5点45到的郑州。爸爸于前一天晚上在三姨和姨父的陪同下到的医院。见到爸爸，看他精神状态挺不错，我安心不少。他说需要做的检查都已经做了，身体条件一切正常，就等医生上班安排手术时间了。</p>
<a id="more"></a>
<h2 id="准备手术钱"><a href="#准备手术钱" class="headerlink" title="准备手术钱"></a>准备手术钱</h2><p>去到住院部，医生首先问费用是否准备齐全，肾源费15万必须现金，住院账户上至少有6万可用费用，这个账户可以用支付宝微信银行卡充值。手术之前如果这些钱不够是不给手术的。我跟我爸简单核对了下现在有多少钱，加上我之前的积蓄，差不多够。基金里有3万左右，因为这个提现有几天延迟，我担心后面有别的情况出现，也申请了提现。</p>
<p>护士提示我们先准备现金，15万属于大额，有些银行必须要预约还需要预约。这一点确实超出我的预期，就赶紧带着卡跟我弟一块去取钱。楼下ATM取了两万就超额不让取了。附近有个建设银行，工作人员一听要跨行转账，而且这么多直接拒绝了我们。我的钱在招商卡里面，就又去了较远的招商银行。柜员问是否有预约，我怕因为这个不给取就赶紧说了这是做手术急用的钱。他犹豫了一下同意了，就开始在柜台那边操作。包括另一张银行卡的跨行提现，他说不知道能不能行，但可以帮我们试一下。虽然最后确实不行，但这个态度挺让我满意，前后对比两家银行，建行给我的印象就更差了。</p>
<p>15万放在包里真挺重的，我背着沉甸甸的钱回到了医院，就在护士的待领取下去缴费。我看柜台人员点钱，15万现金，一万一万的点，要数3-4次左右，光在那等点钱等了七八分钟。然后是凑手术和住院费的钱，我这边微信，支付宝，都交了进去，一直到预存金达到6万。此时手里的钱已经不足一万了，但好在达到了手术要求的费用。</p>
<h2 id="术前准备"><a href="#术前准备" class="headerlink" title="术前准备"></a>术前准备</h2><p>回到医护室，护士交代，要买10支白蛋白，是术后用的。还给了我一张名片，让我打电话去找这个人买。不明白为什么医院不自己开，还要通过外面才能买？我没时间考虑太多这种事情，就按照她的要求，说什么做什么，要什么给什么。接过电话，那边先说价格380一支，我好像也没别的选择，就让他送了十支。</p>
<p>再之后护士又给了一张纸条，上面分两段列了需要购买的东西这些。<br>洗脸盆、大便器、小便器、痰盂、毛巾、牙刷杯、牙刷、牙膏、奶瓶、卫生纸一提、成人尿垫一大包、湿巾一包，消毒湿巾一包、压力绷带两个、雾化吸氧面罩一个、呼吸训练器一个。这些是重症监护室需要用的。<br>便携式体重秤、温度计、小药箱、小本和笔、口罩一包、输液报警器一个、扣背器一个。这些是从重症监护室出来用的。</p>
<p>听大夫说整个过程是晚上6点左右手术，手术完会进重症监护室，在里面观察恢复5天左右，由专门护工照顾，每天有一次探视的机会，可以通过摄像头跟病人交流几分钟。五天之后从重症监护室转到无菌病房，再有五天可以转到普通病房。普通病房阶段就可以自由看望，甚至可以下床简单活动。</p>
<p>买完必备东西之后，爸爸开始了透析。因为正常是一周透析三次，一三五，隔一天一透，今天周日，上次透析是周五，隔的时间较长，需要补一次。透析时我还跟爸爸说，这可能是你最后一次透析了，以后再想透析也没了。</p>
<p>和爸爸一起接受手术的还有一个人，安徽阜阳的，他也属鸡比我爸小一轮，身高体重血型两人也都基本一致。他们俩是要接受同一个供体。问了下还是基督家庭，三姨也感叹这是何种的缘分，冥冥之中可能就是上帝促成的这件事吧。</p>
<p>确定了晚上6点手术之后，爸爸从早上10点开始就被要求不能进食。因为透析的缘故他饥饿感更强了，但也没办法了。这时护士过来说你们余额不足了，需要充钱。问清楚之后我才知道，不是一共交6万而是卡内余额要有6万，一上午已经花了3万多了，就说还要充进去4万才行。这可让我很发愁，想到了这是医院账号，试着用了1万花呗，充值成功，然后是用3万信用卡的额度。这已经是穷尽了力气了，总算筹齐了做手术的钱。</p>
<p>手术前还有一项是洗肠，不知因为什么缘故我爸需要做两次才行，莫名有些心疼起来。之后又等了一段时间，两位叔叔也来了，也说看我爸精神状态不错。我知道每临大事时最紧张的阶段都是知道大事降临，等待事情发生的那段时间。只盼望时间可以过的快一点，不要让我们，不要让我爸煎熬太久。术前量血压，我爸高压170，他本身有一些高血压，也可能是紧张的原因，有点过高了。依照大夫的指示要吃两片降压药，此时还需要控制饮水，只让抿一小口够吃药就行。这一点水下口，可是解了他的瘾，爸爸说水真是太好喝了，想喝却不敢喝。</p>
<p>手术之前需要签字，医生一上来跟我说了一大堆可能的不良反应和意外情况，手术之后可能肾不工作，恢复不好还需要透析辅助，术后肺部容易感染，伤口愈合前如果翻身不小心还可能伤口破裂，术后免疫力会非常低，特别需要照顾好别感冒，抗排异药容易引起情绪焦躁，需要配合医生。想着医院原来的话，手术成功率高达99%，本来还很有信心的我一下紧张和不安起来。但医生不管这些，只是把所有可能的坏情况给我说一遍，然后说，都清楚了吧，签个字吧。这就是一个免责说明书，我毫无还手之力，签了字匆匆离开，只希望手术能够顺顺利利完成。</p>
<h2 id="进行手术"><a href="#进行手术" class="headerlink" title="进行手术"></a>进行手术</h2><p>傍晚6点半左右进了手术室，在手术室门口，接待的医生已经是一身蓝绿色衣服了。他简单问了一下情况，然后记着一些东西，手势动作都很熟练。虽然是简单的步骤，但他的穿着，语气和动作，却让我感受到一种专业性。专业这个东西也是我一直向往和努力的目标。因着这种专业感我很快踏实下来，相信医生，他们肯定会好好给我爸治病。</p>
<p>医生说手术将近三个小时。亚茹姐也信基督，组织了一个小团队，在北京为爸爸祷告。郑老师，张阿姨还有老家的一个教会也在为爸爸祷告。很多人都在祝福着这场手术，盼望着它顺利进行。爸爸进入手术室半个小时之后，临床要一起进行手术的那个人也进了手术室。</p>
<p>这段时间感觉过的异常慢，7点，8点，9点，这个时间点左右差不多该出来了，我就一直盯着手术室的门。想象着它打开的那个瞬间。九点半左右，门开了，但是是跟他一起手术的那个人。他本身比我爸晚进去却早出来，又让我紧张起来。二十分钟左右，想像中的那个画面才出现：医生护士，推着病床，告诉我们手术一切顺利，已经排尿了。我问爸爸感觉怎么样，他声音沙哑说不出来，跟我们见了大概5秒中，很快就被医生推着进到重症监护室了。</p>
<p>此时一直悬着的心才放下来，向所有关注这场手术的人报了平安之后，我心里默默说着，感谢主。虽然身边很多人都是基督徒，我也是基督家庭，我却一直没有真正成为一名基督徒，但还是很感激，我相信这是一场被神祝福了的手术。</p>
<p>手术做完送了两支白蛋白，按照流程基本没什么事了。但是担心有别的情况，所以重症监护室外面得一直有人看着。我跟弟弟说好一替一会在这守着，这时我俩都已经三十多个小时没合眼了。我在监护室外待到夜里两点半，期间在凳子上眯了一会，然后弟弟来替我。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提升Mac下生产效率</title>
    <url>/2019/11/02/mac_efficiency_promotion/</url>
    <content><![CDATA[<h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><h3 id="效率神器Alfred"><a href="#效率神器Alfred" class="headerlink" title="效率神器Alfred"></a>效率神器Alfred</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102170129.png" alt=""><br>可以从Alfred官网下载，免费版没有workflow功能，付费购买Powerpack可以使用。建议大家购买正版，如果想找破解版，网上也有很多，自行搜索。</p>
<p>这有一篇比较详细的Alfred的使用<a href="http://louiszhai.github.io/2018/05/31/alfred/">教程</a>，大部分都被涵盖进去了。这里主要介绍几种对开发帮助比较大的workflow插件，官方workflows地址在<a href="https://www.alfredapp.com/workflows/">这里</a>，可以根据需要选择自己喜欢的插件使用。</p>
<a id="more"></a>
<h4 id="Youdao"><a href="#Youdao" class="headerlink" title="Youdao"></a>Youdao</h4><p>其实在开发过程中经常遇到一些与英文打交道的场景，除了系统自带的字典功能，我们常用的就是有道了。直接调起客户端去搜也很方便，但是如果是频繁操作或者是在全屏下操作，还需要跑到有道里面搜一个单词，搜一句话还是会显得麻烦。</p>
<p>这里有一个Youdao的workflow插件。<a href="http://www.packal.org/workflow/youdao-alfred">下载地址</a>。安装之后可以通过在Alfred中键入<code>yd {query}</code>调出有道字典，并直接搜索翻译结果。使用Enter复制翻译结果，支持多种语言和句子翻译。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102170404.png" alt=""></p>
<h4 id="CodeVar"><a href="#CodeVar" class="headerlink" title="CodeVar"></a>CodeVar</h4><p>生成可用的代码变量，解决你不知道该如何命名一个函数，类型，属性的烦恼。支持小驼峰（<code>xt</code>）、大驼峰（<code>dt</code>）、下划线(<code>xh</code>)、中划线（<code>zh</code>）、常量命名（<code>cl</code>）这几种命名方式。<br><a href="https://github.com/xudaolong/CodeVar">下载地址</a><br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102171226.png" alt=""></p>
<h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>可以直接在Alfred的输入框搜索github仓库。<br><a href="https://github.com/gharlan/alfred-github-workflow">下载地址</a><br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102172412.png" alt=""></p>
<h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><p>Snippets。可以将自己常用的代码片段放进去，让后通过快捷键调出Snippets，直接使用代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>&lt;#Name#&gt;<span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;#statements#&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更多插件"><a href="#更多插件" class="headerlink" title="更多插件"></a>更多插件</h4><p><strong><a href="http://www.alfredworkflow.com/">Workflow官方插件</a></strong><br><strong><a href="http://www.packal.org/">packal</a></strong></p>
<p>第一个插件库，好像很久不维护了，很多插件链接都失效了。第二个packal是alfred的一个活跃论坛，比较推荐到这里发现适合你的好东西。另外github，各个博主的推荐文章也有很多，基本你能想到的搜索主题都可以找到对应的workflow插件，这里就不得不佩服社区力量的强大，还有就是这个自定义插件功能做的太棒了。</p>
<h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><p>文档查询，<a href="https://kapeli.com/dash">下载地址</a><br>遇到问题最好的解决方式就是查文档，API描述能消除大部分自己的疑虑，Dash支持几十种语言的文档查询，还支持文档注释，tag功能。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102173411.png" alt=""></p>
<h4 id="Dash-Alfred"><a href="#Dash-Alfred" class="headerlink" title="Dash+Alfred"></a>Dash+Alfred</h4><p>Dash本身支持很多IDE的插件，其中就包括Alfred插件，可以在<code>Preferences-&gt;Integration</code>中找到Alfred。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102173540.png" alt=""><br>使用方式如下：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102173828.png" alt=""></p>
<h2 id="命令和快捷键篇"><a href="#命令和快捷键篇" class="headerlink" title="命令和快捷键篇"></a>命令和快捷键篇</h2><h3 id="几个常用命令行工具"><a href="#几个常用命令行工具" class="headerlink" title="几个常用命令行工具"></a>几个常用命令行工具</h3><p><strong>say</strong><br>say命令可以读出英文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ say hello world</span><br></pre></td></tr></table></figure>
<p><strong>echo</strong><br>echo是输出命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出shell本身的文件名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br></pre></td></tr></table></figure>
<p>将一段内容重定向至某一文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"5.0"</span> &gt; .swift-version</span><br></pre></td></tr></table></figure>
<p><strong>man</strong><br>man命令可以查看某个命令行的详细使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>
<p><strong>curl</strong><br>curl为client url缩写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl www.baidu.com	<span class="comment">#查看网页源码</span></span><br><span class="line">$ curl -i www.baidu.com <span class="comment">#显示头文件</span></span><br><span class="line">$ curl -o example.html https://www.example.com	<span class="comment">#将服务器回应保存成文件</span></span><br></pre></td></tr></table></figure>

<h3 id="常用终端快捷键"><a href="#常用终端快捷键" class="headerlink" title="常用终端快捷键"></a>常用终端快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+a</td>
<td>跳到行首</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>跳到行尾</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>删除光标之前到行首的字符</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>删除光标之前到行尾的字符</td>
</tr>
<tr>
<td>Ctrl+w</td>
<td>删除从光标位置前到当前所处单词（Word）的开头</td>
</tr>
<tr>
<td>Command+D</td>
<td>垂直分屏</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>关闭垂直分屏</td>
</tr>
</tbody></table>
<h2 id="自己动手写一个工具"><a href="#自己动手写一个工具" class="headerlink" title="自己动手写一个工具"></a>自己动手写一个工具</h2><h3 id="AppleScript"><a href="#AppleScript" class="headerlink" title="AppleScript"></a>AppleScript</h3><p>编写自动化工具就要选一中脚本语言，这里选择了AppleScript。</p>
<p>这是因为:</p>
<ul>
<li>它语法简单，并接近自然语言。（没有标点符号）</li>
<li>语法查询十分方便。（系统原生提供语法查询字典）</li>
<li>mac自带<code>Script Editor</code>可以实现编写运行并检查语法</li>
<li>mac上主流应用都含有AppleScript的语法支持<br>关于AppleScript这有一份简单的<a href="https://sspai.com/post/46912">教程</a>。<br>我们摘取其中几点，简要讲下AppleScript的语法。</li>
</ul>
<h4 id="tell命令"><a href="#tell命令" class="headerlink" title="tell命令"></a>tell命令</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Safari"</span></span><br><span class="line">    <span class="built_in">activate</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br></pre></td></tr></table></figure>
<p>告诉Safari启动。<br><code>tell</code>命令可以嵌套使用。</p>
<h4 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h4><p>定义变量到剪贴板。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set myVariables to clipboard</span><br></pre></td></tr></table></figure>
<h4 id="AppleScript-Suite"><a href="#AppleScript-Suite" class="headerlink" title="AppleScript Suite"></a>AppleScript Suite</h4><p>AppleScript Suite就是 <code>AppleScript</code> 类（class），及其元素（element）和属性（property）的集合。这个就是OmniFocus在<code>AppleScript</code>上定义的Suite。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191030090210.png" alt=""></p>
<h4 id="脚本字典"><a href="#脚本字典" class="headerlink" title="脚本字典"></a>脚本字典</h4><p>打开「脚本编辑器」 → 新建一个脚本 → 用快捷键 <code>Command+Shift+O</code> 打开 AppleScript 字典（Dictionary）。这个打开之后就能看到各个应用的Suite，我们可以通过这些说明，来完成功能的使用。</p>
<h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>有了上面的基础我们来编写一个选中文件夹，然后让iTerm2跳转到指定目录的脚本。</p>
<h4 id="定位文件路径"><a href="#定位文件路径" class="headerlink" title="定位文件路径"></a>定位文件路径</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Finder"</span></span><br><span class="line">	<span class="keyword">set</span> pathFile <span class="keyword">to</span> selection <span class="keyword">as</span> <span class="built_in">text</span></span><br><span class="line">	<span class="comment">--POSIX是mac中的根目录变量</span></span><br><span class="line">	<span class="keyword">set</span> pathFile <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> pathFile</span><br><span class="line">	<span class="comment">--防止目录存在空格跳转不了</span></span><br><span class="line">	<span class="keyword">set</span> pathFile <span class="keyword">to</span> <span class="keyword">quoted form</span> <span class="keyword">of</span> pathFile</span><br><span class="line">	<span class="keyword">set</span> pathFile <span class="keyword">to</span> <span class="string">"cd "</span> &amp; pathFile</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br></pre></td></tr></table></figure>
<p>现在我们通过tell和set命令已经获取到了<code>cd pathFile</code>这段文本。</p>
<h4 id="在iTerm中输入命令"><a href="#在iTerm中输入命令" class="headerlink" title="在iTerm中输入命令"></a>在iTerm中输入命令</h4><p>上一步获取到了文本命令，接下来我们需要将这段命令在iTerm中执行。那怎么将上面的文本写入iTerm中呢？</p>
<p>大致思路为：打开iTerm &gt; 创建窗口 &gt; 写入命令。</p>
<p>接下来就是如何实现这几个步骤，通过查看iTerm的Suite:<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102183300.png" alt=""><br>我们可以找到<code>create window with default profile</code>，<code>write</code>命令。有可能这就是我们需要的也有可能不是，所以有些时候是需要尝试出来的。最终实现上面步骤的代码为：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"iTerm"</span></span><br><span class="line">	create window <span class="keyword">with</span> default profile</span><br><span class="line">	<span class="keyword">tell</span> current session <span class="keyword">of</span> current window</span><br><span class="line">		<span class="built_in">write</span> <span class="built_in">text</span> pathFile</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br></pre></td></tr></table></figure>
<p>然后完整代码为：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Finder"</span></span><br><span class="line">    <span class="comment">-- get selection path</span></span><br><span class="line">    <span class="keyword">set</span> pathFile <span class="keyword">to</span> selection <span class="keyword">as</span> <span class="built_in">text</span></span><br><span class="line">    <span class="keyword">set</span> pathFile <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> pathFile</span><br><span class="line">    <span class="comment">-- fix space problem in the directory</span></span><br><span class="line">    <span class="keyword">set</span> pathFile <span class="keyword">to</span> <span class="keyword">quoted form</span> <span class="keyword">of</span> pathFile</span><br><span class="line">    <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"iTerm"</span></span><br><span class="line">	   create window <span class="keyword">with</span> default profile</span><br><span class="line">	   <span class="keyword">tell</span> current session <span class="keyword">of</span> current window</span><br><span class="line">		  <span class="built_in">write</span> <span class="built_in">text</span> pathFile</span><br><span class="line">	   <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br></pre></td></tr></table></figure>
<h3 id="AppleScript-Alfred"><a href="#AppleScript-Alfred" class="headerlink" title="AppleScript+Alfred"></a>AppleScript+Alfred</h3><p>上面过程我们编写了脚本，但是怎么方便的使用它呢？可以利用Alfred。<br>在workflow中，我们增加一个Hotkeys。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102184419.png" alt=""></p>
<p>然后绑定快捷键<code>Command+O</code>，从快捷键脱出一条线，选择<code>Actions &gt; Run Script</code>，选择Language为AS(AppleScript)，粘贴我们刚才写的代码，保存即可。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20191102184556.png" alt=""></p>
<p>之后我们可以选中文件夹，触发热键<code>Command+O</code>就能直接在iTerm中定位至改目录了。</p>
]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解TCP/IP》总结</title>
    <url>/2019/08/31/diagram_tcpip_concepts/</url>
    <content><![CDATA[<p>最近刚把《图解TCP/IP》翻了一遍，是有很多收获，但是还有很多东西不是太懂。又因为计算机网络涉及的内容多且杂，所以有了这篇记录性质的文章。</p>
<a id="more"></a>
<h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><p>计算机网络最重要的一个概念就是协议，简单来说，<strong>协议</strong>就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备，不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能实现通信。</p>
<p>那这个协议由谁来规定呢，ISO（国际标准化组织）制定的一个国际标准OSI（开放式通信系统互联参考模型）。本书将要说明的TCP/IP并非ISO所制定的某种国际标准，而是由IETF（互联网工程任务组）所建议的致力于推进标准化作业的一种协议。这里提一下，通常OSI只是一种参考模型，他将网络分层，但是它并没有规定任何具体的协议，协议内容则归属为TCP/IP。</p>
<p>OSI参考模型中各个分层的作用：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190919213227.png" alt=""></p>
<h2 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h2><p><strong>面向有连接型</strong>：<br>在发送数据之前，需要在收发主机之间连接一条通信线路。比如打电话，必须对方接通才能开始通话。</p>
<p><strong>面向无连接型</strong>：<br>不要求建立连接和断开连接，发送端可以任何时候发送数据，接收端也永远不知道自己何时会收到数据。</p>
<p><strong>分组交换</strong>：<br>让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送，就是分组交换。有了分组交换，数据被细分，所有计算机可以一起收发数据，这样也就提高了通信线路的利用率。TCP/IP正是采用了分组交换技术。</p>
<p><strong>单播（Unicast）</strong>：<br>一对一通信，早先的固定电话就是单播通信的典型例子。</p>
<p><strong>广播</strong>：<br>将消息从1台主机发送到与之相连的所有其他主机。典型例子就是电视播放。</p>
<p><strong>多播</strong><br>与广播类似，将消息发到多个接收主机，不同之处在于多播要限定某一组主机作为接收端，最典型的例子就是电话会议。</p>
<p><strong>任播</strong><br>从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息，通常，所被选中的那台特定主机将返回一个丹波信号，随后发送端主机会只跟这台主机进行通信。任播在实际网络中的应用有DNS根域名解析服务器。</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>TCP/IP通信中使用MAC地址、IP地址、端口号等信息作为地址标识。</p>
<p>地址很重要的两个属性是唯一性和层次性。</p>
<p>MAC地址由设备的制造厂商对每块网卡进行分别制定。人们可以通过制造商识别号、制造商内部产品编号以及产品通用编号确保MAC地址的唯一性。但并不具有层次性。IP地址因具有网络号和主机号而具有层次性。</p>
<h2 id="TCP-IP基础知识"><a href="#TCP-IP基础知识" class="headerlink" title="TCP/IP基础知识"></a>TCP/IP基础知识</h2><p>TCP/IP的诞生<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190915183056.png" alt=""></p>
<h3 id="TCP-IP的具体含义"><a href="#TCP-IP的具体含义" class="headerlink" title="TCP/IP的具体含义"></a>TCP/IP的具体含义</h3><p>从字面意义上讲，有时这就是指TCP和IP两种协议，但是更多情况下，他是利用IP进行通信时所必须用到的协议群统称。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190915183431.png" alt=""></p>
<h3 id="TCP-IP规范–RFC"><a href="#TCP-IP规范–RFC" class="headerlink" title="TCP/IP规范–RFC"></a>TCP/IP规范–RFC</h3><p>前面提到的TCP/IP的协议由IEFT讨论制定，被人们列入RFC(Request For Comment)文档并公布到互联网上。RFC不仅记录了协议规范内容，还包含了协议的实现和运用的相关信息，以及实验方面的信息。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190915184056.png" alt=""></p>
<p>可以通过<a href="https://www.rfc-editor.org/">RFC Editor</a>查看RFC所有内容。</p>
<h2 id="TCP-IP协议分层模型"><a href="#TCP-IP协议分层模型" class="headerlink" title="TCP/IP协议分层模型"></a>TCP/IP协议分层模型</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190919143416.png" alt=""></p>
<p>这个就是常被问及网络分层模型，它有两种，一种是OSI7层模型；一种是TCP/IP的5层模型，也有一种分法是4层模型，是将5层模型中的网卡层和硬件层合为网络接口层。</p>
<h3 id="物理层（硬件）"><a href="#物理层（硬件）" class="headerlink" title="物理层（硬件）"></a>物理层（硬件）</h3><p>TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。</p>
<p>主要功能是：利用传输介质为数据链路层提供物理连接，负责处理数据传输并监控数据出错率，以便数据流的透明传输。</p>
<h3 id="数据链路层（网络接口层）"><a href="#数据链路层（网络接口层）" class="headerlink" title="数据链路层（网络接口层）"></a>数据链路层（网络接口层）</h3><p>网络接口层（有时人们也将网络接口层与硬件层合并起来称作网络通信层。） 利用以太网中的数据链路层进行通信，因此属于接口层。也就是说，把它当做让NIC起作用的“驱动程序”也无妨。</p>
<h3 id="网络层（互联网层）"><a href="#网络层（互联网层）" class="headerlink" title="网络层（互联网层）"></a>网络层（互联网层）</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190919145252.png" alt=""><br>网络层(Network layer)是参考模型的第3层。主要功能是：为数据在结点之间传输创建逻辑链路，通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现拥塞控制、网络互联等功能。</p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。</p>
<h4 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP(Internet Control Message Protocol)"></a>ICMP(Internet Control Message Protocol)</h4><p>IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能而制定的。它有时也被用来诊断网络的健康状况。</p>
<h4 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP(Address Resolution Protocol)"></a>ARP(Address Resolution Protocol)</h4><p>地址解析协议，从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190919145219.png" alt=""><br>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。</p>
<p><strong>TCP首部</strong><br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922200215.png" alt=""><br>其中控制位是用于连接管理的标记位，字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如下所示。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922200920.png" alt=""></p>
<p><strong>连接管理</strong><br>TCP会在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答（TCP中发送第一个SYN包的一方叫做客户端，接收这个的一方叫做服务端。） 。如果对端发来确认应答，则认为可以进行数据通信。如果对端的确认应答未能到达，就不会进行数据通信。此外，在通信结束时会进行断开连接的处理（FIN包）。</p>
<p>可以使用TCP首部用于控制的字段来管理TCP连接。一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成（建立一个TCP连接需要发送3个包。这个过程也称作“三次握手”。） 。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922200022.png" alt=""></p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP是User Datagram Protocol的缩写。</p>
<p>UDP有别于TCP，它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</p>
<p>由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下几个方面：</p>
<ul>
<li>包总量较少的通信（DNS、SNMP等）</li>
<li>视频、音频等多媒体通信（即时通信）</li>
<li>限定于LAN等特定网络中的应用通信</li>
<li>广播通信（广播、多播）</li>
</ul>
<p><strong>UDP首部</strong><br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922200442.png" alt=""></p>
<h3 id="应用层（会话层及以上分层）"><a href="#应用层（会话层及以上分层）" class="headerlink" title="应用层（会话层及以上分层）"></a>应用层（会话层及以上分层）</h3><p>TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。因此，细看TCP/IP的应用程序功能会发现，它不仅实现OSI模型中应用层的内容，还要实现会话层与表示层的功能。</p>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p>在FTP中进行文件传输时会建立两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接（这两种连接的控制管理属于会话层的功能。） </p>
<h4 id="远程登录（TELNET和SSH）"><a href="#远程登录（TELNET和SSH）" class="headerlink" title="远程登录（TELNET和SSH）"></a>远程登录（TELNET和SSH）</h4><p>远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能。TCP/IP网络中远程登录常用TELNET（TELetypewriter NETwork的缩写。有时也称作默认协议。） 和SSH（SSH是Secure SHell的缩写。） 两种协议。</p>
<h3 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h3><p>假设甲给乙发送电子邮件，内容为：“早上好”。而从TCP/IP通信上看，是从一台计算机A向另一台计算机B发送电子邮件。这一过程可以用如下图示表示：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190919150413.png" alt=""></p>
<h2 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>当用户在浏览器的地址栏里输入所要访问Web页的URI以后，HTTP的处理即会开始。HTTP中默认使用80端口。它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。</p>
<p>HTTP中常用的有两个版本，一个HTTP1.0，另一个是HTTP1.1。在HTTP1.0中每一个命令和应答都会触发一次TCP连接的建立和断开。而从HTTP1.1开始，允许在一个TCP连接上发送多个命令和应答（这种方式也叫保持连接（keep-alive）。） 。由此，大量地减少了TCP连接的建立和断开操作，从而也提高了效率。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922201820.png" alt=""><br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922201908.png" alt=""></p>
<h3 id="多媒体实现技术"><a href="#多媒体实现技术" class="headerlink" title="多媒体实现技术"></a>多媒体实现技术</h3><p>由于TCP具有流控制、拥塞控制、重发机制等功能，有时应用所发出去的数据可能无法迅速到达对端目标主机。然而在互联网电话（使用的VoIP（Voice Over IP的缩写。） ）和电视会议当中，即使有少许丢包，也希望系统延时少一点，非常注重系统的即时性。因此，在实时多媒体通信当中采用UDP。</p>
<p>然而，只使用UDP还不足以达到进行实时多媒体通信的目的。例如，在互联网电视电话议会中需要提供查询对方号码、模拟电话机的拨号以及以什么形式交互数据等功能。为此，需要一个叫做“呼叫控制”的支持。呼叫控制主要采用H.323与SIP协议。此外，还需要RTP协议（结合多媒体数据本身的特性进行传输的一种协议）和压缩技术（在网络上传输音频、视频等大型多媒体数据时进行压缩）的支持。</p>
<h4 id="H-323"><a href="#H-323" class="headerlink" title="H.323"></a>H.323</h4><p>H.323是由ITU开发用于在IP网上传输音频、视频的一种协议。起初，它主要是作为接入ISDN网和IP网之上的电话网为目的的一种规范而被提出的。</p>
<p>H.323定义了4个主要组件。它们分别是终端（用户终端）、网关（吸收用户数据压缩顺序的不一致性）、网闸（电话本管理、呼叫管理）以及多点控制单元（允许多个终端同时使用）。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922202435.png" alt=""></p>
<h4 id="SIP"><a href="#SIP" class="headerlink" title="SIP"></a>SIP</h4><p>与H.323相对的TCP/IP协议即是SIP（Session Initiation Protocol）协议。</p>
<p>“终端之间进行多媒体通信时，需要具备事先解析对方地址、呼出对方号码并对所要传输的媒体信息进行处理等功能。此外，还需要具备中断会话和数据转发的功能。这些功能（呼叫控制与信令）都被统一于SIP协议中。它相当于OSI参考模型中的会话层。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922202804.png" alt=""></p>
<h4 id="RTP和RTCP"><a href="#RTP和RTCP" class="headerlink" title="RTP和RTCP"></a>RTP和RTCP</h4><p>UDP不是一种可靠性传输协议。因此有可能发生丢包或乱序等现象。因此采用UDP实现实时的多媒体通信需要附加一个表示报文顺序的序列号字段，还需要对报文发送时间进行管理。这些正是RTP（Real-Time Protocol）的主要职责。</p>
<p>RTP为每个报文附加时间戳和序列号。接收报文的应用，根据时间戳决定数据重构的时机。序列号则根据每发出一次报文加一的原则进行累加。RTP使用这个序列号对同一时间戳的数据（尤其是对于视频的数据。视频中一个帧的数据往往要超过一个包，然而它们发送的时间戳一致。此时就可以使用同一时间戳内不同的序列号加以区分。） 进行排序，掌握是否有丢包的情况发生。</p>
<p>RTCP（RTP Control Protocol）是辅助RTP的一种协议。通过丢包率等线路质量的管理，对RTP的数据传送率进行控制。</p>
<h3 id="TLS-SSL与HTTPS"><a href="#TLS-SSL与HTTPS" class="headerlink" title="TLS/SSL与HTTPS"></a>TLS/SSL与HTTPS</h3><p>对于一些涉及机密信息的网络连接需要进行加密处理，Web中可以通过TLS/SSL（Transport Layer Security/Secure Sockets Layer。由网景公司最早提出的名称叫SSL，标准化以后被称作TLS。使用TLS/SSL的HTTP通信叫做HTTPS通信。</p>
<p>HTTPS中采用对称加密方式。而在发送其公共密钥时采用的则是公钥加密方式（对称加密虽然速度快，但是密钥管理是巨大的挑战。公钥加密密钥管理相对简单，但是处理速度非常慢。TLS/SSL将两者进行取长补短令加密过程达到了极好的效果。由于谁都可以发送公钥，使得密钥管理更为简单。） 。</p>
<p>确认公钥是否正确主要使用认证中心（CA（Certificate Authority） ）签发的证书，而主要的认证中心的信息已经嵌入到浏览器的出厂设置中。如果Web浏览器中尚未加入某个认证中心，那么会在页面上提示一个警告信息。此时，判断认证中心合法与否就要由用户自己决定了。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922203528.png" alt=""></p>
<h3 id="IEEE802-1X"><a href="#IEEE802-1X" class="headerlink" title="IEEE802.1X"></a>IEEE802.1X</h3><p>IEEE（The Institute of Electronical and Electronics Engineers，美国电子和电气工程师协会）委员会中，依据不同的工作小组制定了各种局域网技术标准。因于1980年2月启动局域网国际标准化项目，所以命名为802。</p>
<p>IEEE802.1X是为了能够接入LAN交换机和无线LAN接入点而对用户进行认证的技术（包括我们常用的WiFi）<br>并且它只允许被认可的设备才能访问网络。虽然它是一个提供数据链路层控制的规范，但是与TCP/IP关系紧密。一般，由客户端终端、AP（无线基站）或2层交换机以及认证服务器组成。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190922204520.png" alt=""></p>
<h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>蓝牙与IEEE802.11b/g类似，是使用2.4GHz频率无线电波的一种标准（因此，当IEEE802.b/g等设备与蓝牙设备一起使用时，无线电波信号削减有可能导致通信性能的下降。） 。数据传输速率在V2中能达到3Mbps（实际最大吞吐量为2.1Mbps）。通信距离根据无线电波的信号的强弱，有1药看看吧3 B、10药看看吧3 B、100药看看吧3 B三种类型。通信终端最多允许8台设备（其中一台为主节点，其他1～7台为受管节点。这种网络也叫做piconet，微微网。） 。</p>
<p>如果说IEEE802.11是针对笔记本电脑这样较大的计算机设备的标准，那么蓝牙则是为手机或智能手机、键盘、鼠标等较小设备而设计的标准。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Swift World：设计模式--中介者模式</title>
    <url>/2019/08/28/design_pattern_mediator/</url>
    <content><![CDATA[<blockquote>
<p>原文：<a href="https://medium.com/swiftworld/swift-world-design-patterns-mediator-e6b3c35d68b0">https://medium.com/swiftworld/swift-world-design-patterns-mediator-e6b3c35d68b0</a><br>作者：Peng</p>
</blockquote>
<p>今天我们讨论一下中介者模式(Mediator)。这次不从抽象定义开始，而是用现实世界中的一个场景来解释它。在一个团队里，有产品经理，开发工程师，质量工程师。当开发完成了某些功能，将代码提交到仓库。相关环节人员，像质量工程师和产品经理需要被通知。</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Collogue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span>: <span class="title">Collogue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> qe: <span class="type">QE</span></span><br><span class="line">    <span class="keyword">var</span> pm: <span class="type">PM</span></span><br><span class="line">    <span class="keyword">init</span>(qe: <span class="type">QE</span>, pm: <span class="type">PM</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id = <span class="string">"Developer"</span></span><br><span class="line">        <span class="keyword">self</span>.qe = qe</span><br><span class="line">        <span class="keyword">self</span>.pm = pm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        qe.receive(message: message)</span><br><span class="line">        pm.receive(message: message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QE</span>: <span class="title">Collogue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> developer: <span class="type">Developer</span></span><br><span class="line">    <span class="keyword">var</span> pm: <span class="type">PM</span></span><br><span class="line">    <span class="keyword">init</span>(developer: <span class="type">Developer</span>, pm: <span class="type">PM</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id = <span class="string">"QE"</span></span><br><span class="line">        <span class="keyword">self</span>.developer = developer</span><br><span class="line">        <span class="keyword">self</span>.pm = pm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        developer.receive(message: message)</span><br><span class="line">        pm.receive(message: message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PM</span>: <span class="title">Collogue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> developer: <span class="type">Developer</span></span><br><span class="line">    <span class="keyword">var</span> qe: <span class="type">QE</span></span><br><span class="line">    <span class="keyword">init</span>(developer: <span class="type">Developer</span>, qe: <span class="type">QE</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id = <span class="string">"PM"</span></span><br><span class="line">        <span class="keyword">self</span>.developer = developer</span><br><span class="line">        <span class="keyword">self</span>.qe = qe</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        developer.receive(message: message)</span><br><span class="line">        qe.receive(message: message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个角色都需要持有另一个角色的实例，这种连接方式是高耦合的，且很不容易修改。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190828104157.png" alt=""></p>
<p>现在我们需要一个中介者帮助我们简化这个系统。中介者的目的是帮助对象之间相互交流。它让每个对象都是跟自己进行交互而不是其他对象。当前对象不需要持有别的对象，而是持有中介者。这样将解耦系统，它的结构图如下所示：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190828104852.png" alt=""></p>
<p>我们来写一下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String, sender: Colleague)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeamMediator</span>: <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> colleagues: [<span class="type">Colleague</span>] = []</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(colleague: Colleague)</span></span> &#123;</span><br><span class="line">        colleagues.append(colleague)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String, sender: Colleague)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> colleague <span class="keyword">in</span> colleagues &#123;</span><br><span class="line">            <span class="keyword">if</span> colleague.id != sender.id &#123;</span><br><span class="line">                colleague.receive(message: message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过持有中介者，那几个角色对象变成了这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mediator: <span class="type">Mediator</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span>: <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> mediator: <span class="type">Mediator</span></span><br><span class="line">    <span class="keyword">init</span>(mediator: <span class="type">Mediator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id = <span class="string">"Developer"</span></span><br><span class="line">        <span class="keyword">self</span>.mediator = mediator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        mediator.send(message: message, sender: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Developer received: "</span> + message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QE</span>: <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> mediator: <span class="type">Mediator</span></span><br><span class="line">    <span class="keyword">init</span>(mediator: <span class="type">Mediator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id = <span class="string">"QE"</span></span><br><span class="line">        <span class="keyword">self</span>.mediator = mediator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        mediator.send(message: message, sender: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"QE received: "</span> + message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PM</span>: <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> mediator: <span class="type">Mediator</span></span><br><span class="line">    <span class="keyword">init</span>(mediator: <span class="type">Mediator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id = <span class="string">"PM"</span></span><br><span class="line">        <span class="keyword">self</span>.mediator = mediator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        mediator.send(message: message, sender: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"PM received: "</span> + message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，整个结构就变成了下面这样：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190828105301.png" alt=""></p>
<p>让我们用新的方式来使用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//usage</span></span><br><span class="line"><span class="keyword">let</span> mediator = <span class="type">TeamMediator</span>()</span><br><span class="line"><span class="keyword">let</span> qe = <span class="type">QE</span>(mediator: mediator)</span><br><span class="line"><span class="keyword">let</span> developer = <span class="type">Developer</span>(mediator: mediator)</span><br><span class="line"><span class="keyword">let</span> pm = <span class="type">PM</span>(mediator: mediator)</span><br><span class="line">mediator.register(colleague: developer)</span><br><span class="line">mediator.register(colleague: qe)</span><br><span class="line">mediator.register(colleague: pm)</span><br><span class="line">mediator.send(message: <span class="string">"Hello world!"</span>, sender: developer)</span><br></pre></td></tr></table></figure>
<p>另一个相似的例子就是非常受欢迎的<code>Notification</code>(<code>NSNotification</code>)。你可以在网上找到很多相关的代码。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】设计模式引导--OOP的能力</title>
    <url>/2019/08/20/builder_design_pattern_swift/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://medium.com/swift-india/design-patterns-by-tutorials-the-power-of-oop-2e871b551cbe">原文链接</a><br>作者：Hitendra Solanki</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190819211318.jpeg" alt=""><br>导读–本博客系列要求具有面向对象编程的中级专业知识。您应该对类、对象、构造函数、继承、值和引用类型有基本的了解。通过仔细地从头到尾阅读本系列文章，不管是中级还是高级开发，您都将有所收获。</p>
<a id="more"></a>
<p>设计模式用于表示经验丰富的面向对象软件开发人员社区采用的最佳实践。</p>
<p>建造者模式帮助我们更简单更易读地创建一个类，它遵守着以下两条规则：<br>1、分割原始类和它的构造方法<br>2、在最后一个返回类的实例</p>
<p><strong>建造者模式最佳的例子就是SwiftUI，是的你没有看错。SwiftUI中大部分类像是Text，Image都是使用的建造者模式。</strong></p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>想一下，一个<code>Person</code>类拥有不少于十个属性，当你要使用它时，你需要为它创建一个构造方法。它的构造者将拥有不少于十个参数，去管理这么一个带有很多参数的单一函数或构造方式将是非常困难的，最终你也会让这端代码失去可读性。看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">//personal details</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> gender: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> birthDate: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> birthPlace: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> height: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> weight: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//contact details</span></span><br><span class="line">  <span class="keyword">var</span> phone: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> email: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//address details</span></span><br><span class="line">  <span class="keyword">var</span> streeAddress: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> zipCode: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> city: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//work details</span></span><br><span class="line">  <span class="keyword">var</span> companyName: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> designation: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> annualIncome: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//constructor</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>,</span><br><span class="line">       gender: <span class="type">String</span>,</span><br><span class="line">       birthDate: <span class="type">String</span>,</span><br><span class="line">       birthPlace: <span class="type">String</span>,</span><br><span class="line">       height: <span class="type">String</span>,</span><br><span class="line">       weight: <span class="type">String</span>,</span><br><span class="line">       phone: <span class="type">String</span>,</span><br><span class="line">       email: <span class="type">String</span>,</span><br><span class="line">       streeAddress: <span class="type">String</span>,</span><br><span class="line">       zipCode: <span class="type">String</span>,</span><br><span class="line">       city: <span class="type">String</span>,</span><br><span class="line">       companyName: <span class="type">String</span>,</span><br><span class="line">       designation: <span class="type">String</span>,</span><br><span class="line">       annualIncome: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.gender = gender</span><br><span class="line">    <span class="keyword">self</span>.birthDate = birthDate</span><br><span class="line">    <span class="keyword">self</span>.birthPlace = birthPlace</span><br><span class="line">    <span class="keyword">self</span>.height = height</span><br><span class="line">    <span class="keyword">self</span>.weight = weight</span><br><span class="line">    <span class="keyword">self</span>.phone = phone</span><br><span class="line">    <span class="keyword">self</span>.email = email</span><br><span class="line">    <span class="keyword">self</span>.streeAddress = streeAddress</span><br><span class="line">    <span class="keyword">self</span>.zipCode = zipCode</span><br><span class="line">    <span class="keyword">self</span>.height = height</span><br><span class="line">    <span class="keyword">self</span>.city = city</span><br><span class="line">    <span class="keyword">self</span>.companyName = companyName</span><br><span class="line">    <span class="keyword">self</span>.designation = designation</span><br><span class="line">    <span class="keyword">self</span>.annualIncome = annualIncome</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//This is function in Xcode-Playground which executes our test code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hitendra = <span class="type">Person</span>(name: <span class="string">"Hitendra Solanki"</span>,</span><br><span class="line">                        gender: <span class="string">"Male"</span>,</span><br><span class="line">                        birthDate: <span class="string">"2nd Oct 1991"</span>,</span><br><span class="line">                        birthPlace: <span class="string">"Gujarat, India"</span>,</span><br><span class="line">                        height: <span class="string">"5.9 ft"</span>,</span><br><span class="line">                        weight: <span class="string">"85kg"</span>,</span><br><span class="line">                        phone: <span class="string">"+91 90333-71772"</span>,</span><br><span class="line">                        email: <span class="string">"hitendra.developer@gmail.com"</span>,</span><br><span class="line">                        streeAddress: <span class="string">"52nd Godrej Street"</span>,</span><br><span class="line">                        zipCode: <span class="string">"380015"</span>,</span><br><span class="line">                        city: <span class="string">"Ahmedabad"</span>,</span><br><span class="line">                        companyName: <span class="string">"Fortune 500"</span>,</span><br><span class="line">                        designation: <span class="string">"Software architect"</span>,</span><br><span class="line">                        annualIncome: <span class="string">"45,000 USD"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//use of Person object</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(hitendra.name) works in \(hitendra.companyName) compay as a \(hitendra.designation)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//call main to execute our test code in Xcode-Playground</span></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Console output:</span></span><br><span class="line"><span class="comment">Hitendra Solanki works in Fortune 500 compay as a Software architect.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>将上面的例子在playground中运行一下，你会得到预期结果。逻辑上这也是对的。</p>
<p>我们可以尝试优化上面的代码，从解决这两个问题入手。<br>1、我们必须按照既定的顺序传参数，而不能通过重新排列参数提高可读性。<br>2、即使创建对象时我们不知道一些属性值，我们也不得不传入所有参数。</p>
<p>例如你需要创建一个<code>Person</code>类，但是这个人还在找工作。只有当他进入某一公司我们才能得到他的工作信息。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>1、创建相关属性的逻辑分组。<br>2、为不同分组的属性创建不同的建造者类。<br>3、在建造者类中最后一步返回实例。</p>
<p>让我们从上面的例子开始，我们已经拥有一个<code>Person</code>类，它含有14个属性。我们仔细观察这14个属性，可以将它分为四组。<br>1、个人信息<br>2、联系方式<br>3、地址信息<br>4、公司信息</p>
<p>通过强大的设计模式我们可以解决上面两个问题，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//This is function in playground which executes our test code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> hitendra = <span class="type">Person</span>() <span class="comment">//person with empty details</span></span><br><span class="line">  <span class="keyword">let</span> personBuilder = <span class="type">PersonBuilder</span>(person: hitendra)</span><br><span class="line">  </span><br><span class="line">  hitendra = personBuilder</span><br><span class="line">    .personalInfo</span><br><span class="line">      .nameIs(<span class="string">"Hitendra Solanki"</span>)</span><br><span class="line">      .genderIs(<span class="string">"Male"</span>)</span><br><span class="line">      .bornOn(<span class="string">"2nd Oct 1991"</span>)</span><br><span class="line">      .bornAt(<span class="string">"Gujarat, India"</span>)</span><br><span class="line">      .havingHeight(<span class="string">"5.9 ft"</span>)</span><br><span class="line">      .havingWeight(<span class="string">"85 kg"</span>)</span><br><span class="line">    .contacts</span><br><span class="line">      .hasPhone(<span class="string">"+91 90333-71772"</span>)</span><br><span class="line">      .hasEmail(<span class="string">"hitendra.developer@gmail.com"</span>)</span><br><span class="line">    .lives</span><br><span class="line">      .at(<span class="string">"52nd Godrej Street"</span>)</span><br><span class="line">      .inCity(<span class="string">"Ahmedabad"</span>)</span><br><span class="line">      .withZipCode(<span class="string">"380015"</span>)</span><br><span class="line">    .build()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//use of Person object</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(hitendra.name) has contact number \(hitendra.phone) and email \(hitendra.email)"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//later on when we have company details ready for the person</span></span><br><span class="line">  hitendra = personBuilder</span><br><span class="line">    .works</span><br><span class="line">      .asA(<span class="string">"Software architect"</span>)</span><br><span class="line">      .inCompany(<span class="string">"Fortune 500"</span>)</span><br><span class="line">      .hasAnnualEarning(<span class="string">"45,000 USD"</span>)</span><br><span class="line">    .build()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//use of Person object with update info</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(hitendra.name) works in \(hitendra.companyName) compay as a \(hitendra.designation)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//call main to execute our test code</span></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person class which only contains the details</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">//personal details</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> gender: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> birthDate: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> birthPlace: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> height: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> weight: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//contact details</span></span><br><span class="line">  <span class="keyword">var</span> phone: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> email: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//address details</span></span><br><span class="line">  <span class="keyword">var</span> streeAddress: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> zipCode: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> city: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//work details</span></span><br><span class="line">  <span class="keyword">var</span> companyName: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> designation: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> annualIncome: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//empty constructor</span></span><br><span class="line">  <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PersonBuilder class helps to construct the person class instance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> person: <span class="type">Person</span></span><br><span class="line">  <span class="keyword">init</span>(person: <span class="type">Person</span>)&#123;</span><br><span class="line">    <span class="keyword">self</span>.person = person</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//personal details builder switching</span></span><br><span class="line">  <span class="keyword">var</span> personalInfo: <span class="type">PersonPersonalDetailsBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">PersonPersonalDetailsBuilder</span>(person: <span class="keyword">self</span>.person)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//contact details builder switching</span></span><br><span class="line">  <span class="keyword">var</span> contacts: <span class="type">PersonContactDetailsBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">PersonContactDetailsBuilder</span>(person: <span class="keyword">self</span>.person)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//address details builder switching</span></span><br><span class="line">  <span class="keyword">var</span> lives: <span class="type">PersonAddressDetailsBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">PersonAddressDetailsBuilder</span>(person: <span class="keyword">self</span>.person)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//work details builder switching</span></span><br><span class="line">  <span class="keyword">var</span> works: <span class="type">PersonCompanyDetailsBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">PersonCompanyDetailsBuilder</span>(person: <span class="keyword">self</span>.person)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">Person</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PersonPersonalDetailsBuilder: update personal details</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonPersonalDetailsBuilder</span>: <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">nameIs</span><span class="params">(<span class="number">_</span> name: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.name = name</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">genderIs</span><span class="params">(<span class="number">_</span> gender: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.gender = gender</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">bornOn</span><span class="params">(<span class="number">_</span> birthDate: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.birthDate = birthDate</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">bornAt</span><span class="params">(<span class="number">_</span> birthPlace: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.birthPlace = birthPlace</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">havingHeight</span><span class="params">(<span class="number">_</span> height: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.height = height</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">havingWeight</span><span class="params">(<span class="number">_</span> weight: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.weight = weight</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PersonContactDetailsBuilder: update contact details</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonContactDetailsBuilder</span>: <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">hasPhone</span><span class="params">(<span class="number">_</span> phone: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.phone = phone</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">hasEmail</span><span class="params">(<span class="number">_</span> email: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.email = email</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PersonAddressDetailsBuilder: update address details</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonAddressDetailsBuilder</span>: <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">at</span><span class="params">(<span class="number">_</span> streeAddress: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.streeAddress = streeAddress</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">withZipCode</span><span class="params">(<span class="number">_</span> zipCode: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.zipCode = zipCode</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">inCity</span><span class="params">(<span class="number">_</span> city: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.city = city</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PersonCompanyDetailsBuilder: update company details</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonCompanyDetailsBuilder</span>: <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">inCompany</span><span class="params">(<span class="number">_</span> companyName: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.companyName = companyName</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">asA</span><span class="params">(<span class="number">_</span> designation: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.designation = designation</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">hasAnnualEarning</span><span class="params">(<span class="number">_</span> annualIncome: String)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.annualIncome = annualIncome</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Console output:</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> Hitendra Solanki has contact number +91 90333-71772 and email hitendra.developer@gmail.com</span></span><br><span class="line"><span class="comment"> Hitendra Solanki works in Fortune 500 compay as a Software architect.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们把<code>Person</code>类根据职责分割成了几个不同的类。我们创建了多个建造者，他们分别管理相关分组内的属性，而Person只持有这些建造者。</p>
<p>我们拥有一个建造者基类<code>PersonBuilder</code>和四个衍生的建造者类，<code>PersonPersonalDetailsBuilder</code>, <code>PersonContactDetailsBuilder</code>, <code>PersonAddressDetailsBuilder</code> 和 <code>PersonCompanyDetailsBuilder</code>。</p>
<p>当其他四个从<code>Personbuilder</code>衍生出来的建造者需要更新相关属性时，<code>Personbuilder</code>这个基类可以帮助我们在它们之间进行转换。</p>
<p>在上面的例子中我们可以看到新的构造方法变得更加易读了，我们可以用一种更加优雅的方式更新一组或者某一个属性。</p>
<p>需要注意一下，上面的例子中我们再每个建造者更新方法之后返回了它自己。这让我们能够在相同的建造者中写出链式方法，而不是分开的多行。这个概念称为流程模式。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、用一种优雅的方式很容易地初始化一个含很多参数的类。<br>2、遵从单一职责原则。<br>3、根据你的情况，以任意的顺序初始化对象和更新属性。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS国际化及本地化（一）不同语言的差异处理及测试</title>
    <url>/2019/08/19/localization_guide/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190819180049.png" alt=""></p>
<h2 id="国际化及本地化概念"><a href="#国际化及本地化概念" class="headerlink" title="国际化及本地化概念"></a>国际化及本地化概念</h2><p>将标题取名为国际化及本地化（internationalization and localization），是因为这两个概念是有差异的，而这个差异常常被我们忽略，以下是维基百科的解释：</p>
<a id="more"></a>
<blockquote>
<p>国际化是指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。本地化则是指当移植软件时，加上与特定区域设置有关的信息和翻译文件的过程。</p>
<p>国际化和本地化之间的区别虽然微妙，但却很重要。国际化意味着产品有适用于任何地方的“潜力”；本地化则是为了更适合于“特定”地方的使用，而另外增添的特色。用一项产品来说，国际化只需做一次，但本地化则要针对不同的区域各做一次。这两者之间是互补的，并且两者合起来才能让一个系统适用于各地。</p>
</blockquote>
<p>有些时候我们也会用国际化或者全球化代替这两者含义。</p>
<p>作为一款优秀的产品我们做多语言版本时不应仅仅考虑到翻译这一层面，还有更多本地化相关内容需要我们注意，这篇文章主要涉及的也是本地化这一块。</p>
<h2 id="国际化工作流程"><a href="#国际化工作流程" class="headerlink" title="国际化工作流程"></a>国际化工作流程</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190815094524.png" alt=""></p>
<p>本篇文章主要介绍Internationalize和Test这两步。</p>
<p>本文目录为：</p>
<blockquote>
<p>1.增加多语言</p>
<p>2.UI元素的本地化</p>
<p>3.资源文件本地化</p>
<p>4.字符串相关的本地化</p>
<p>5.使用NSLocal进行本地化</p>
<p>6.从右到左语言的处理</p>
<p>7.本地化测试</p>
</blockquote>
<h2 id="增加多语言"><a href="#增加多语言" class="headerlink" title="增加多语言"></a>增加多语言</h2><p>1、在项目导航栏选择项目（不是target）</p>
<p>2、在Localizations一栏，点击“+”号，添加语言<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190813162840.png" alt=""><br>每个条目都是由语言名称和语言id构成，例如<code>Chinese(Simplified)(zh-Hans)</code>, <code>Japanese(ja)</code><br>至此我们的项目就开启了对应语言的本地化支持。</p>
<p>3、在对话框中选中你想本地化的文件。</p>
<h3 id="语言和区域的影响"><a href="#语言和区域的影响" class="headerlink" title="语言和区域的影响"></a>语言和区域的影响</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190813164121.png" alt=""><br>通过观察系统日历，我们可以看到即使语言一样，国家区域的不一致也会有一些约定上的区别，关于日期和时间的本地化会在下面介绍。</p>
<p>1、语言设置：Setting -&gt; General -&gt; Language &amp; Region<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190813164521.png" alt=""><br>同样的，关于Region和Calendar的设置也在该页面。</p>
<h2 id="资源文件的本地化"><a href="#资源文件的本地化" class="headerlink" title="资源文件的本地化"></a>资源文件的本地化</h2><h3 id="storyboard-xib文件"><a href="#storyboard-xib文件" class="headerlink" title="storyboard, xib文件"></a>storyboard, xib文件</h3><p>对于<code>sotryboard</code>和<code>xib</code>文件的本地化是Xcode直接支持的。<br>在添加语言时会提示我们自动选择创建本地化文件，如果是在添加语言之后创建的IB文件，可以通过xcode右侧属性栏中点击<code>Localize...</code>生成本地化文件。</p>
<h3 id="图片文件"><a href="#图片文件" class="headerlink" title="图片文件"></a>图片文件</h3><p><strong>1、方法一</strong><br>对于图片内容我们可以通过同IB文件的方式进行本地化，但是有一个限制就是图片要是放到项目文件层级的，而不能放到Assets文件夹中。<br>好消息是Xcode 11将放开这种限制，对于Assets引入的图片也可以做本地化处理。</p>
<p><strong>2、方法二</strong><br>除了Xcode本身支持的方式，我们还可以通过命名来区分图片内容，把图片名当做需要本地化的字符串，各个语言对应不同版本的图片名，这样也可以实现图片文件的本地化。</p>
<h3 id="音视频及其他资源文件"><a href="#音视频及其他资源文件" class="headerlink" title="音视频及其他资源文件"></a>音视频及其他资源文件</h3><p>如果是内置的像是音视频，json或者其他类型的配置文件这类内容，可以使用图片文件的方法二进行引入。</p>
<p>更多详细的设置可以参考这个文章：<a href="https://juejin.im/post/5b90ea53e51d450ea131ef81">iOS语言国际化/本地化-实践总结</a></p>
<h2 id="UI元素的本地化"><a href="#UI元素的本地化" class="headerlink" title="UI元素的本地化"></a>UI元素的本地化</h2><h3 id="使用Auto-layout"><a href="#使用Auto-layout" class="headerlink" title="使用Auto layout"></a>使用Auto layout</h3><p><code>Auto layout</code>是相对布局，它有能力在语言和区域变化时进行自适应。以下有几点使用auto layout的技巧：</p>
<p><strong>1、移除宽度的约束</strong><br>相同含义下不同语言宽度往往不一样，应该让控件能够自适应。</p>
<p><strong>2、使用内容内部大小</strong><br>fields和label默认是自动调整大小的，如果一个显示本地化内容的视图需要这个功能，选择该view，选择<code>Editor &gt; Size To Fit Content</code></p>
<p><strong>3、使用<code>leading</code>和<code>trailing</code>属性</strong><br>正常<code>leading</code>和<code>trailing</code>对应<code>left</code>和<code>right</code>，他们含义相同。但是有些国家，像是希伯来和阿拉伯的人使用习惯是从右往左。如果你是使用<code>leading</code>和<code>trailing</code>，在该环境下将自动对应<code>right</code>和<code>left</code>。</p>
<p><strong>4、将视图固定到相邻视图</strong><br>就是定义相邻约束，避免某一视图变化导致重叠。</p>
<h3 id="使用伪本地化发现问题"><a href="#使用伪本地化发现问题" class="headerlink" title="使用伪本地化发现问题"></a>使用伪本地化发现问题</h3><p>这个功能只支持使用<code>storyboard</code>和<code>xib</code>进行布局的UI。<br>1、选中需要测试的.storyboard或者.xib文件<br>2、选择菜单栏 View &gt; Assistant Editor &gt; Show Assistant Editor<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190813174244.png" alt=""></p>
<h2 id="字符串相关的本地化"><a href="#字符串相关的本地化" class="headerlink" title="字符串相关的本地化"></a>字符串相关的本地化</h2><h3 id="使用Unicode字符串"><a href="#使用Unicode字符串" class="headerlink" title="使用Unicode字符串"></a>使用Unicode字符串</h3><p>对于所有面向用户的字符串都要使用<code>NSString, NSAttributedString</code>，对于Swift就是<code>String, AttributedString</code>，因为他们支持Unicode，Unicode是世界上所有书写系统的字符编码标准。</p>
<p>对于一些特殊的字符串需求：<br><strong>1、访问字符串中的字符</strong><br>使用NSString中的<code>rangeOfComposedCharacterSequenceAtIndex:</code>和 <code>rangeOfComposedCharacterSequencesForRange:</code>方法，他们会确保你在取字符串时不会破坏原文本。看一个例子你可能会明白：</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190813174801.png" alt=""><br>这两个文字无论是在UTF-16还是UTF-32编码的情况下都是不同的长度，所以我们不能通过长度而要通过以上的两种方式取目标字符串。</p>
<p><strong>2、遍历字符串</strong></p>
<p>如果我们要遍历展示下面的字符串：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190813175200.png" alt=""><br>可以通过<code>enumerateSubstringsInRange:options:usingBlock:</code>方法，其中options参数如果传递<code>NSStringEnumerationByComposedCharacterSequences</code>将会按照最小字符进行遍历，如果选用<code>NSStringEnumerationByWords</code>将会按照词语进行遍历。<br>以上例子使用该值遍历的结果是：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190813175638.png" alt=""></p>
<p>更多关于字符串相关的本地化问题可以参照该条视频：<br><a href="https://developer.apple.com/videos/play/wwdc2013/219/">WWDC 2013 Making Your App World-Ready
</a></p>
<p><strong>3、关于人名，邮寄地址，电话号码的检测</strong><br>因为不同国家对于人名和电话号码的规则差别较大，我们可以针对不同国家写正则进行检测，也可以使用苹果提供的一个特殊含义字符的检测类：<a href="https://developer.apple.com/documentation/foundation/nsdatadetector">NSDataDetector</a></p>
<p>支持检测的类型包括日期，地址，链接，手机号，交通信息。</p>
<h3 id="获取当前语言"><a href="#获取当前语言" class="headerlink" title="获取当前语言"></a>获取当前语言</h3><p>将语言设置为English(United Kingdom)，区域设置成United States，通过以下API获取到：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//en</span></span><br><span class="line"><span class="built_in">NSString</span> *languageID = [[<span class="built_in">NSBundle</span> mainBundle] preferredLocalizations].firstObject;</span><br></pre></td></tr></table></figure>
<p>一般获取语言所用的方式是通过Bundle也就是第一种方式。</p>
<h2 id="使用NSLocal进行本地化"><a href="#使用NSLocal进行本地化" class="headerlink" title="使用NSLocal进行本地化"></a>使用NSLocal进行本地化</h2><p>NSLocale对象封装关于特定区域格式化标准的信息，包括日期，时间，测量，数字，货币等一系列内容。</p>
<p>将语言设置为English(United Kingdom)，区域设置成United States，通过以下API获取到：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//en-GB_US</span></span><br><span class="line">[<span class="built_in">NSLocale</span> currentLocale].localeIdentifier;</span><br><span class="line"><span class="comment">//en</span></span><br><span class="line">[<span class="built_in">NSLocale</span> currentLocale].languageCode;</span><br></pre></td></tr></table></figure>
<p>其中languageCode跟通过Bundle获取到的是一样的。</p>
<p>其中localIdentifier表示为<code>en-GB_US</code>，对应为：<code>语言id-国家id_区域码</code>，这几个内容都可以通过NSLocal对象取到。</p>
<h3 id="获取特定语言的引号"><a href="#获取特定语言的引号" class="headerlink" title="获取特定语言的引号"></a>获取特定语言的引号</h3><p>因为每种语言对于引号的使用是不一样的，我们可以通过NSLocal获取到引号</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.Get the language that the app is using.</span></span><br><span class="line"><span class="built_in">NSString</span> *languageID = [[<span class="built_in">NSBundle</span> mainBundle] preferredLocalizations].firstObject;</span><br><span class="line"><span class="comment">//2.Get the associated locale object.</span></span><br><span class="line"><span class="built_in">NSLocale</span> *locale = [<span class="built_in">NSLocale</span> localeWithLocaleIdentifier:languageID];</span><br><span class="line"><span class="comment">//3.Get the beginning and ending symbols for quotes from the locale object.</span></span><br><span class="line">bQuote = [locale objectForKey:<span class="built_in">NSLocaleQuotationBeginDelimiterKey</span>];</span><br><span class="line">eQuote = [locale objectForKey:<span class="built_in">NSLocaleQuotationEndDelimiterKey</span>];</span><br><span class="line"><span class="comment">//4.Format a string using the locale-sensitive quotes.</span></span><br><span class="line">quotedString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@"</span>, bQuote, myText, eQuote];</span><br></pre></td></tr></table></figure>
<p>以下展示了不同区域对于<code>myText</code>为<code>@&quot;iPhone&quot;</code>时的字符串效果。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814110652.png" alt=""></p>
<h3 id="字符串的本地化"><a href="#字符串的本地化" class="headerlink" title="字符串的本地化"></a>字符串的本地化</h3><p>1、创建格式化字符串<br>应该使用<code>localizedStringWithFormat:</code>而不是<code>stringWithFormat:</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *localizedString = [<span class="built_in">NSString</span> localizedStringWithFormat:<span class="string">@"%3.2f"</span>, myNumber];</span><br></pre></td></tr></table></figure>
<p>此方法会根据系统Local进行显示。</p>
<h3 id="日期时间本地化"><a href="#日期时间本地化" class="headerlink" title="日期时间本地化"></a>日期时间本地化</h3><p>2、日期和时间转字符串<br>使用<code>NSDateFormatter</code>表示<code>NSDate</code>对象。推荐使用这个方法：<code>localizedStringFromDate:dateStyle:timeStyle:</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//14 Aug 2019 at 11:19</span></span><br><span class="line"><span class="built_in">NSString</span> *localizedDateTime = [<span class="built_in">NSDateFormatter</span> localizedStringFromDate:[<span class="built_in">NSDate</span> date] dateStyle:<span class="built_in">NSDateFormatterMediumStyle</span> timeStyle:<span class="built_in">NSDateFormatterShortStyle</span>];</span><br></pre></td></tr></table></figure>
<p>下表展示了语言为英语，区域是美国时的日期和时间格式：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814112216.png" alt=""><br>下表展示了<code>dateStyle</code>为<code>NSDateFormatterMediumStyle</code>，<code>timeStyle</code>为<code>NSDateFormatterShortStyle</code>在不同语言和地区时的表现形式：</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814113048.png" alt=""><br>3、使用自定义日期和时间格式</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.Create an NSDateFormatter object.</span></span><br><span class="line"><span class="built_in">NSDateFormatter</span> *dateFormatter = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line"><span class="comment">//2.get a localized format string from a template that you provide.</span></span><br><span class="line"><span class="built_in">NSString</span> *localeFormatString = [<span class="built_in">NSDateFormatter</span> dateFormatFromTemplate:<span class="string">@"MMM d"</span> options:<span class="number">0</span> locale:dateFormatter.locale];</span><br><span class="line"><span class="comment">//3.Set the format of the NSDateFormatter instance to the locale-sensitive format string.</span></span><br><span class="line">dateFormatter.dateFormat = localeFormatString;</span><br><span class="line"><span class="comment">//4.Use the stringFromDate: method to get a localized string representation of the date.</span></span><br><span class="line"><span class="built_in">NSString</span> *localizedString = [dateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br></pre></td></tr></table></figure>
<p>在不同语言和区域下<code>localizedString</code>对应的内容为：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814113008.png" alt=""></p>
<p>3、解析日期字符串</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.Create a date formatter object.</span></span><br><span class="line"><span class="built_in">NSDateFormatter</span> *dateFormatter = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line"><span class="comment">//2.Set the formatter’s style to a preset style.</span></span><br><span class="line">dateFormatter.dateStyle = <span class="built_in">NSDateFormatterMediumStyle</span>;</span><br><span class="line"><span class="comment">//3.If the input string is not expected to contain a time, set the time style to none.</span></span><br><span class="line">dateFormatter.timeStyle = <span class="built_in">NSDateFormatterNoStyle</span>;</span><br><span class="line"><span class="comment">//4.Set the leniency to YES (enables the heuristics).</span></span><br><span class="line">dateFormatter.lenient = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//5.Convert the string to a date object.</span></span><br><span class="line"><span class="built_in">NSDate</span> *date = [dateFormatter dateFromString:inputString];</span><br></pre></td></tr></table></figure>
<p>我们输入的字符串是<code>9/3/14</code>，dateStyle设为<code>NSDateFormatterShortStyle</code>，如果区域为美国，我们得到的NSDate信息为：<code>2014-09-03 07:00:00 +0000</code>，如果区域为德国，我们将得到<code>2014-03-09 08:00:00 +0000</code>。</p>
<h3 id="数字本地化"><a href="#数字本地化" class="headerlink" title="数字本地化"></a>数字本地化</h3><p>本地化设置会影响小数点符号，千分符，货币符等内容，比如数字<code>1,234.56</code>在意大利应该表示为<code>1.234,56</code>，所以对于数字的格式化我们应该用<code>NSNumberFormatter</code>处理。<br><strong>注意：NSNumberFormatter不是现成安全的</strong><br>1、将Number转成本地化的字符串<br>可以使用<code>NSNumberFormatter</code>的<code>localizedStringFromNumber:numberStyle:</code>方式</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *localizedString = [<span class="built_in">NSNumberFormatter</span> localizedStringFromNumber:myNumber numberStyle:<span class="built_in">NSNumberFormatterDecimalStyle</span>];</span><br></pre></td></tr></table></figure>
<p>以下是不同语言和区域关于数字的显示效果，左侧的style及<code>numberStyle</code>：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814115914.png" alt=""><br>2、将字符串转成NSNumber对象<br>这个类似日期的转换</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.Create a number formatter object.</span></span><br><span class="line"><span class="built_in">NSNumberFormatter</span> *numberFormatter = [<span class="built_in">NSNumberFormatter</span> new];</span><br><span class="line"><span class="comment">//2.Set the formatter’s style to a preset style.</span></span><br><span class="line">numberFormatter.numberStyle = <span class="built_in">NSNumberFormatterDecimalStyle</span>;</span><br><span class="line"><span class="comment">//3.Set the leniency to YES (enables the heuristics).</span></span><br><span class="line">numberFormatter.lenient = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//4.Convert the string to a number object.</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number = [numberFormatter numberFromString:inputString];</span><br></pre></td></tr></table></figure>
<p>3、通过NSCalendar计算日期<br>NSCalendar类封装了日历的所有区域差异和复杂性。说他具有复杂性是因为在不同国家，一年之中的月份可能是12或者13，一月中的天数可能是5到31的任意值，每周第一天可能是周六，周日或者周一。可以看下表<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814121444.png" alt=""><br>因此使用NSCalendar取这些值将会很方便。<br>获取Calendar unit的方式为</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.Create an NSDateComponents object.</span></span><br><span class="line"><span class="built_in">NSDateComponents</span> *components = [[<span class="built_in">NSCalendar</span> currentCalendar]</span><br><span class="line">    components:<span class="built_in">NSDayCalendarUnit</span> | <span class="built_in">NSMonthCalendarUnit</span> | <span class="built_in">NSYearCalendarUnit</span> | <span class="built_in">NSEraCalendarUnit</span></span><br><span class="line">    fromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line"><span class="comment">//2.Access the values for day, month, year, and era.</span></span><br><span class="line"><span class="built_in">NSInteger</span> day = [components day];</span><br><span class="line"><span class="built_in">NSInteger</span> month = [components month];</span><br><span class="line"><span class="built_in">NSInteger</span> year = [components year];</span><br><span class="line"><span class="built_in">NSInteger</span> era = [components era];</span><br></pre></td></tr></table></figure>
<p>4、监听本地化信息或者时区修改<br>可以通过<code>NSCurrentLocaleDidChangeNotification</code>监听区域的改变</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(localeDidChange:) name:<span class="built_in">NSCurrentLocaleDidChangeNotification</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>同样的监听时区变化可以通过<code>NSSystemTimeZoneDidChangeNotification</code>。</p>
<h2 id="从右到左语言的处理"><a href="#从右到左语言的处理" class="headerlink" title="从右到左语言的处理"></a>从右到左语言的处理</h2><h3 id="创建从右到左语言的交互界面"><a href="#创建从右到左语言的交互界面" class="headerlink" title="创建从右到左语言的交互界面"></a>创建从右到左语言的交互界面</h3><p>支持从右到左向的语言，在约束层面应该使用Auto layout中的<code>leading</code>和<code>trailing</code>属性，而不是<code>right</code>和<code>right</code>。可以通过以下对比看到区别<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814202653.png" alt=""><br>整体像是做了水平的翻转，有很多控件像是segmented控件, 进度指示器系统会自动做翻转。但是有些情况是不需要翻转的：</p>
<ul>
<li>视频控制和时间线指示器</li>
<li>图片，除非他们传达方向感，如箭头</li>
<li>时钟</li>
<li>乐谱</li>
<li>图表（x轴和y轴总是在一致的方向）</li>
</ul>
<h3 id="获取布局的方向性"><a href="#获取布局的方向性" class="headerlink" title="获取布局的方向性"></a>获取布局的方向性</h3><p>如果我们想获取当前语言是否应该是从右到左项的语言可以通过以下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//right-to-left language</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="built_in">UIView</span> userInterfaceLayoutDirectionForSemanticContentAttribute:view.semanticContentAttribute] == <span class="built_in">UIUserInterfaceLayoutDirectionRightToLeft</span>) &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置文本的对齐方式"><a href="#设置文本的对齐方式" class="headerlink" title="设置文本的对齐方式"></a>设置文本的对齐方式</h3><p>在iOS中默认的文本对齐方式是“natural”，在OS X中默认方式是“left”。natural的含义就是会感觉语言的方向自动调整为left或者right。<br>如果你想<code>NSMutableParagraphStyle</code>对象的对齐方式为自然的方向，可以：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[(<span class="built_in">NSMutableParagraphStyle</span> *)paraStyle setAlignment:<span class="built_in">NSNaturalTextAlignment</span>];</span><br></pre></td></tr></table></figure>

<h3 id="对双向文本的处理"><a href="#对双向文本的处理" class="headerlink" title="对双向文本的处理"></a>对双向文本的处理</h3><p>双向文本就是一段文本中及含有从右往左的文本还含有从左往右的文本。是不是感觉很诧异？因为即使像阿拉伯和希伯来国家这些书写习惯为从右往左，但是对于数字和拉丁文是从左往右写的。如果你使用的是标准控件，像Label，TextView，Textfiled他们会自动处理双向文本内容。如果你是使用自定义控件，那这些问题就需要你手动处理。</p>
<h3 id="向双向文本添加Unicode标记"><a href="#向双向文本添加Unicode标记" class="headerlink" title="向双向文本添加Unicode标记"></a>向双向文本添加Unicode标记</h3><p>在某些特殊的时候，系统默认的行为可能会导致一些不正确的结果，这时我们可以通过添加Unicode标记进行纠正。</p>
<p>例如，手机号在所有语言中都是从左往右读的，如果一个需要本地化的字符串变量表示一个手机号，如果我们需要保证他是从左往右的顺序展示，需要再字符串首部增加一个从左往右的嵌入字符（LRE）：<code>U+202A</code>，在字符尾部增加定向格式字符（PDF）:<code>U+202C</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrap the plus (+) prefix and phone number in left-to-right directional markers</span></span><br><span class="line"><span class="built_in">NSString</span> *phoneNumber = <span class="string">@"408-555-1212"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *localizedPhoneNumber = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"\u202A%@\u202C"</span>, phoneNumber];</span><br></pre></td></tr></table></figure>

<h3 id="翻转Cocoa-Touch视图"><a href="#翻转Cocoa-Touch视图" class="headerlink" title="翻转Cocoa Touch视图"></a>翻转Cocoa Touch视图</h3><p>有些视图是不应该翻转的，在iOS9之后可以通过UIView的<code>semanticContentAttribute</code>属性手动指定视图应该是从左到后还是从右往左的方式展示。</p>
<p>如果是想翻转图片可以通过<code>UIImage</code>的<code>imageFlippedForRightToLeftLayoutDirection</code>方法。</p>
<h2 id="本地化测试"><a href="#本地化测试" class="headerlink" title="本地化测试"></a>本地化测试</h2><h3 id="通过IB预览测试本地化"><a href="#通过IB预览测试本地化" class="headerlink" title="通过IB预览测试本地化"></a>通过IB预览测试本地化</h3><p>这个功能只能在.storyboard和.xib文件实现。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814201716.png" alt=""><br>选中preview之后我们可以通过其右下角的语言选项切换不同语言，然后我们可以实时观察调换语言之后的效果。</p>
<h3 id="通过伪语言功能测试"><a href="#通过伪语言功能测试" class="headerlink" title="通过伪语言功能测试"></a>通过伪语言功能测试</h3><p>通过<code>Edit Schema &gt; Run &gt; Options</code> 然后点开语言选项，除了各种系统支持语言外，翻到最下面可以看到这几个选项。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190814214907.png" alt=""><br>1.Double-Length Pseudolanguage<br>可以将文本内容变成两倍长度。</p>
<p>2.Right-to-Left Pseudolanguage<br>将语言方向改成从右往左，也可以将语言改成阿拉伯文或者希伯来文。</p>
<p>3.Accented Pseudolanguage<br>带重音符号。</p>
<p>4.Bounded String Pseudolanguage<br>带边界的字符串。</p>
<p>5.Right-to-Left Pseudolanguage With Right-to-Left Strings<br>同从右往左语言。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>苹果文档：<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i-CH1-SW1">Internationzlization and Localization Guide</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>本地化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#13|201907</title>
    <url>/2019/07/31/monthly_13/</url>
    <content><![CDATA[<p>这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。<br>欢迎推荐内容，可以前往<a href="https://github.com/zhangferry/iOSMonthlyReport">zhangferry/iOSMonthlyReport</a>提交issue。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190731213558.png" alt=""></p>
<a id="more"></a>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Golbal-queues的优先级"><a href="#Golbal-queues的优先级" class="headerlink" title="Golbal queues的优先级"></a>Golbal queues的优先级</h3><p>如果要在后台执行非UI相关的工作, 一般把这部分工作放在Global queue. Global queue是一种系统内共享的并行的队列。申请Global queue的方法很简单:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let userQueue &#x3D; DispatchQueue.global(qos: .userInitiated)</span><br></pre></td></tr></table></figure>
<p>其中后面的<code>.userInitiated</code>参数代表队列的优先级。该优先级公有6中分类，有高到低为：<br><code>userInteractive&gt;default&gt;unspecified&gt;userInitiated&gt;utility&gt;background</code><br>通过该段代码验证：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span>.<span class="keyword">default</span>).async &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"DispatchQoS.QoSClass.default, %d"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span>.background).async &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"DispatchQoS.QoSClass.background, %d"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span>.unspecified).async &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"DispatchQoS.QoSClass.unspecified, %d"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span>.userInitiated).async &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"DispatchQoS.QoSClass.userInitiated, %d"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span>.userInteractive).async &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"DispatchQoS.QoSClass.userInteractive, %d"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span>.utility).async &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"DispatchQoS.QoSClass.utility, %d"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>userInitiated</code>为<code>LIFO(后进先出)</code>，即如果有新插入的<code>userInteractive</code>级别的队列任务，为先执行新任务之后再执行之前该级别任务。其余优先级的队列任务均是<code>FIFO(先进先出)</code>。</p>
<h3 id="“No-such-module”-when-using-testable-in-Xcode-Unit-tests"><a href="#“No-such-module”-when-using-testable-in-Xcode-Unit-tests" class="headerlink" title="“No such module” when using @testable in Xcode Unit tests"></a>“No such module” when using @testable in Xcode Unit tests</h3><p>因为测试工程和主工程分属不同<code>Module</code>，所以如果我们想在测试项目中调用主工程代码需要导入主工程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> moduleName</span><br></pre></td></tr></table></figure>
<p>这个时候如果报以上错误，会有以下可能：<br>1、targetName错误<br>这个可以去<code>Target-&gt;Build Setting-&gt;Product Module Name</code>确认。<br>2、主工程和测试模块支持版本号不一致<br>保证<code>Build Setting-&gt;iOS Deployment Target</code>中的版本号在主工程和测试工程中一致。</p>
<h3 id="authenticating-with-the-app-store上传卡顿"><a href="#authenticating-with-the-app-store上传卡顿" class="headerlink" title="authenticating with the app store上传卡顿"></a>authenticating with the app store上传卡顿</h3><p>如果往AppStoreConnect传包一直卡在这个步骤，可以试一下这种方式：<br>第一步：<code>cd ~</code><br>第二步：<code>mv .itmstransporter/ .old_itmstransporter/</code><br>第三步：<code>&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter&quot;</code><br>等待执行完成。</p>
<h3 id="订阅的freetrial没有标明截止时间被拒"><a href="#订阅的freetrial没有标明截止时间被拒" class="headerlink" title="订阅的freetrial没有标明截止时间被拒"></a>订阅的freetrial没有标明截止时间被拒</h3><p>如题，如果订阅功能含freetrial，一定要在freetrial按钮旁边标清楚试用的截止时间。</p>
<h3 id="WakaTime"><a href="#WakaTime" class="headerlink" title="WakaTime"></a><a href="https://wakatime.com/dashboard">WakaTime</a></h3><p>一款能够统计开发时间的网页端应用，支持众多IDE。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190731203414.png" alt=""><br>集成到IDE之后，注册账号然后会获取到一个Key，绑定该值。然后当我们愉快的开发时，一些开发的信息就会被记录下来。我们可以通过其网页端的dashboard查看我们开发的情况。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190731203603.png" alt=""><br>因为前几天升级XCode，需要重新装插件，所以最近几天的开发记录为空。</p>
<h3 id="Lookin-免费好用的iOS-UI调试软件"><a href="#Lookin-免费好用的iOS-UI调试软件" class="headerlink" title="Lookin | 免费好用的iOS UI调试软件"></a><a href="https://lookin.work/">Lookin | 免费好用的iOS UI调试软件</a></h3><p>出自QMUI团队，可能是小集的影响力已经很大了，这个软件首发之后竟发现已经有一众人开始关注这个东西了。可能因为UI调试这个操作是一个高频的行为，而Xcode目前又做的不够好，所以大家都期待有一个高效的UI调试工具。我也是下下来试了下，结合之前对<a href="https://revealapp.com/">Reveal</a>和<a href="https://sherlock.inspiredcode.io">Sherlock</a>的使用，说下自己的体会吧，首先是优点：<br>1、免费<br>2、支持动态修改UI元素属性，例如位置，颜色，圆角这些<br>3、可以查看CALayer的信息<br>因为是刚发布没多久，还是有些需要改进的地方的<br>1、动态修改UI元素的信息，均是通过UIView，和CALayer的信息进行修改，无法实现像UILabel改文案，更新行数等操作<br>2、3D的渲染有时候会有bug出现，位置不正确，另外仅支持一个左右的旋转不支持上下<br>3、屏幕适配还不支持，不能修改屏幕<br>其实我对sherlock也都仅限于使用，中和频率不高的使用性和高昂的费用，我选择试用结束就放弃，虽然Lookin还存在一些不足，但是免费大于一切啊，希望可以做的更好，为更多开发者带来便利。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="R-swift"><a href="#R-swift" class="headerlink" title="R.swift"></a><a href="https://github.com/mac-cain13/R.swift">R.swift</a></h3><p>Android开发中引用资源可以通过<code>R机制</code>，所谓<code>R机制</code>就是在我们创建一个Android项目的时候，IDE会自动帮我们创建一个名为R的类型，它所在的文件名称也是叫做R.java，R类型中没有任何方法，包含的是代表不同类型资源的内部静态类，而这些内部静态类中，也只有静态的属性，每个属性代表一个资源，故我们要引用某个资源类型中的某个资源，可用R.资源类型.资源名来引用。下面就是代码中的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  从图片资源文件夹中加载名为"image_test"的图片以其创建位图</span></span><br><span class="line">Bitmap aBitmap = BitmapFactory.decodeResource(<span class="keyword">this</span>.getResources(), R.drawable.image_test);</span><br></pre></td></tr></table></figure>
<p>相对来说iOS中的资源引用就麻烦很多，需要通过字符串引用，无法代码补全，资源更换无法自检查。解决iOS资源引用的这些问题而借鉴Android方案的<code>R.Swift</code>应运而生。<br>传统的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> settingsIcon = <span class="type">UIImage</span>(named: <span class="string">"settings-icon"</span>)</span><br><span class="line"><span class="keyword">let</span> gradientBackground = <span class="type">UIImage</span>(named: <span class="string">"gradient.jpg"</span>)</span><br></pre></td></tr></table></figure>
<p>使用R.Swift</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let settingsIcon &#x3D; R.image.settingsIcon()</span><br><span class="line">let gradientBackground &#x3D; R.image.gradientJpg()</span><br></pre></td></tr></table></figure>
<p>不光图片，它还支持<code>Fonts</code>，<code>Resource files</code>，<code>Colors</code>，<code>Localized strings</code>，<code>Storyboards</code>，<code>Segues</code>，<code>Nibs</code>，<code>Reuseable Cells</code>。<br>我第一次见到这玩意的时候就一个感受：wocao，🐂🍺！<br>更多关于R.Swift的使用规则参照官网说明。</p>
<h3 id="Swift-Books"><a href="#Swift-Books" class="headerlink" title="Swift-Books"></a><a href="https://github.com/longsirhero/Swift-Books">Swift-Books</a></h3><p>github上的内容，可以分为两类，纯干货和干货的整理。这个库属于后者，是一个收录Swift&amp;Object-C相关资料的仓库。收录的都是比较经典的学习资料，而且非常全！<br>建库已经两年了，但是star却不多，不知道是因为曝光度的问题，还是因为大家对设计版权问题的内容有些警惕。但不管怎样吧，我还是要推一推这个库。</p>
<h3 id="open-source-ios-apps"><a href="#open-source-ios-apps" class="headerlink" title="open-source-ios-apps"></a><a href="https://github.com/dkhamsing/open-source-ios-apps">open-source-ios-apps</a></h3><p>开源的iOS应用列表。基本涵盖了iOS开发涉及的所有领域，通过完整的app去学习别人的开发技巧是一个相对直观的方式，面对这个大礼包，记得来看一看哈。</p>
<h3 id="Chinese-Podcasts"><a href="#Chinese-Podcasts" class="headerlink" title="Chinese-Podcasts"></a><a href="https://github.com/alaskasquirrel/Chinese-Podcasts">Chinese-Podcasts</a></h3><p>中文博客的收录，包含科技，风投，生活，电影，设计等领域。<br>音频内容最大的优势就是便捷，你可以在走路，跑步，甚至休息的时候使用它。音频相比视频还有一个更大的好处是，它会给大脑预留更多的想象空间，听音频我们会思考的更多一些。<br>去年一直在听东吴同学会，最近一段时间则听ggtalk和硅谷早知道多一些。</p>
<h2 id="文摘"><a href="#文摘" class="headerlink" title="文摘"></a>文摘</h2><p>1、</p>
<blockquote>
<p>生存是一种即时策略游戏，所有的人都是这场游戏的玩家。财务自由了，就是游戏赢家。<br>–《科技爱好者周刊：66期》</p>
</blockquote>
<p>2、</p>
<blockquote>
<p>我以为别人尊重我，是因为我很优秀。慢慢的我明白了，别人尊重我，是别人很优秀；优秀的人更懂得尊重别人，对人恭敬其实是在庄严你自己。</p>
</blockquote>
<p>3、</p>
<blockquote>
<p>所谓成熟的人，就是精神上能够自给自足的人。</p>
</blockquote>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#12|201906</title>
    <url>/2019/06/29/monthly_12/</url>
    <content><![CDATA[<p>这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。<br>欢迎推荐内容，可以前往<a href="https://github.com/zhangferry/iOSMonthlyReport">zhangferry/iOSMonthlyReport</a>提交issue。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/C6B082E3EE78560B53A3C9A99698359F.jpg" alt=""></p>
<a id="more"></a>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="闪光动画"><a href="#闪光动画" class="headerlink" title="闪光动画"></a>闪光动画</h3><p>图片上的闪光动画，类似这种效果：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/2019-06-30%2014.24.47.gif" alt=""><br>分析拆解可知这是一个带透明的白色渐变移动产生的效果。渐变+移动，我们可以使用<code>CAGradientLayer</code> + <code>CABasicAnimation</code>实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showGradientAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> gradient = <span class="type">CAGradientLayer</span>()</span><br><span class="line">    gradient.frame = canvasView.bounds</span><br><span class="line">    <span class="comment">//左上角到右下角的渐变</span></span><br><span class="line">    gradient.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">    gradient.endPoint = <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">    gradient.locations = [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">    <span class="comment">//调透明度渐变要使用白色</span></span><br><span class="line">    gradient.colors = [<span class="type">UIColor</span>.<span class="keyword">init</span>(white: <span class="number">1</span>, alpha: <span class="number">0.0</span>).cgColor,</span><br><span class="line">                           <span class="type">UIColor</span>.<span class="keyword">init</span>(white: <span class="number">1</span>, alpha: <span class="number">0.3</span>).cgColor,</span><br><span class="line">                           <span class="type">UIColor</span>.<span class="keyword">init</span>(white: <span class="number">1</span>, alpha: <span class="number">0.0</span>).cgColor]</span><br><span class="line">    </span><br><span class="line">    canvasView.layer.addSublayer(gradient)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> animation = <span class="type">CABasicAnimation</span>.<span class="keyword">init</span>(keyPath: <span class="string">"locations"</span>)</span><br><span class="line">    <span class="comment">//从0位置开始从1位置结束</span></span><br><span class="line">    animation.fromValue = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>]</span><br><span class="line">    animation.toValue = [<span class="number">0.7</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    animation.duration = gradientAnimationDuration</span><br><span class="line">    animation.repeatCount = <span class="number">1</span></span><br><span class="line">    animation.isRemovedOnCompletion = <span class="literal">true</span></span><br><span class="line">    gradient.add(animation, forKey: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集成Universal-Links时的几点注意事项"><a href="#集成Universal-Links时的几点注意事项" class="headerlink" title="集成Universal Links时的几点注意事项"></a>集成Universal Links时的几点注意事项</h3><p>这个是onlink总结对于各个平台对应用间跳转的支持情况，其中deeplink指Universal Links：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/C8614AF1-9B2E-4CA5-A771-B1BA59F87868.png" alt=""></p>
<h4 id="跳转至facebook指定页面"><a href="#跳转至facebook指定页面" class="headerlink" title="跳转至facebook指定页面"></a>跳转至facebook指定页面</h4><p>如果是facebook某一主页，可以通过：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里可以替换成自己的主页id</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"fb://page?id=**"</span>)! </span><br><span class="line"><span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url, options: [:], completionHandler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这是使用了app scheme的方式进行跳转的，要求本机安装了facebook才能跳转成功。</p>
<p>如果是跳转到某一个主页的某一个帖子，可以通过：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里替换成固定的帖子链接</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.facebook.com/**/posts/**"</span>)! </span><br><span class="line"><span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url, options: [:], completionHandler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这是通过<code>Universal Links</code>方式跳转的，该链接可以通过苹果的<a href="https://search.developer.apple.com/appsearch-validation-tool/">验证</a>。如果未安装应用会跳转到网页端，如果安装了就直接跳到指定页面。</p>
<p>那正常来说，facebook主页也应该可以通过支持deep link的https链接跳转才对，但实际测试来看是不行的。所以如果要加上是否安装的逻辑的话，就是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: kFacebookHomePageSchemeUrl)!</span><br><span class="line"><span class="keyword">if</span> <span class="type">UIApplication</span>.shared.canOpenURL(url) &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url, options: [:], completionHandler: <span class="literal">nil</span>)   </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(<span class="type">URL</span>(string: kFacebookHomePageUrl)!, options: [:], completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>推荐：将连接复制到便签，邮件，短信，或者使用二维码的形式使用。</p>
<p><strong>不要将链接粘贴到 Safari 中 - iOS 目前阻止从任何浏览器的地址栏进行深度链接。</strong></p>
<p>验证apple-app-site-association的连接，可以苹果的<a href="https://search.developer.apple.com/appsearch-validation-tool/">验证工具</a></p>
<h3 id="lottie动画效果在安卓和网页端正常在iOS端不正常"><a href="#lottie动画效果在安卓和网页端正常在iOS端不正常" class="headerlink" title="lottie动画效果在安卓和网页端正常在iOS端不正常"></a>lottie动画效果在安卓和网页端正常在iOS端不正常</h3><p>在一次使用<a href="https://github.com/airbnb/lottie-ios">lottie</a>调用设计提供的动画时，该动画是一个放烟花，然后散开的动画。用<a href="https://lottiefiles.com/preview">网页预览</a>可以完美展示效果，但是放到客户端运行时，却只展示一部分即烟花上飞过程，而没有散开效果。最后仔细查看文档，找到这个：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190630120203.png" alt=""><br>经设计确认，烟花绽放的效果使用了AE中的<code>Repeater（中继器）</code>控件，而该控件在lottie的3.0版本还不支持，但是在2.5.2版本是支持的，回退版本至2.5.2解决了动画确认问题。</p>
<p><strong>PS：一些古怪问题，第一反应要从官网文档说明、Issues、QA中找答案</strong></p>
<h3 id="几个产品相关概念"><a href="#几个产品相关概念" class="headerlink" title="几个产品相关概念"></a>几个产品相关概念</h3><p><strong>ROI(return on investment)：投资回报率</strong><br>反应产品的盈利情况，用百分比表示。<br>市场营销、运营活动，都是企业获利为出发点，通过利润/投资量化目标。利润的计算涉及财务，很多时候用更简单的收入作分子。当运营活动的ROI大于1，说明这个活动是成功的，能赚钱。<br><strong>ecpm(effective cost per mille)：每千次展示可以获得的广告收入</strong><br>这是广告主预估自身收益的指标。<br><strong>arpu(Average Revenue Per User)：每用户平均收入</strong><br>ARPU注重的是一个时间段内运营商从每个用户所得到的利润。很明显，高端的用户越多，ARPU越高。<br><strong>LTV(life time value)：生命周期总价值</strong><br>意为客户终生价值，是公司从用户所有的互动中所得到的全部经济收益的总和。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="23-位开发者告诉你这次-WWDC-最让他们兴奋的新事物"><a href="#23-位开发者告诉你这次-WWDC-最让他们兴奋的新事物" class="headerlink" title="23 位开发者告诉你这次 WWDC 最让他们兴奋的新事物"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU2NjM2NDkxNg==&mid=2247488121&idx=1&sn=c336a82dea45fc58ad70f563876b2e5d&chksm=fcaccde2cbdb44f4516a54416fd0e0ce4fdd08d29e2a9963fce1933902fad5cffafcbcfc9e32&token=407105051&lang=zh_CN&scene=21#wechat_redirect">23 位开发者告诉你这次 WWDC 最让他们兴奋的新事物</a></h3><p>对23位iOS开发者的采访，一起来看下他们眼中这届WWDC什么最让人兴奋。</p>
<h3 id="免费领取小专栏-–-WWDC2019-内参"><a href="#免费领取小专栏-–-WWDC2019-内参" class="headerlink" title="免费领取小专栏 – WWDC2019 内参"></a><a href="https://xiaozhuanlan.com/wwdc19/present/380ad33db882a12ae9c0b2402d386ef10ecafa51">免费领取小专栏 – WWDC2019 内参</a></h3><p>6月份的WWDC给我们开发者带来了很多东西，Dark Mode、Swift UI、Combine、iPad OS等等。也是我感觉近几年WWDC干货最多的一界了。干货太多不知道怎么学习怎么办？这里<a href="https://juejin.im/user/5624c86b60b2b199f7611227">没故事的卓同学</a>分享的<code>WWDC2019 内参</code>免费领取名额。可以看各位大佬对WWDC的最新解读分析，目前二十多天里已经更新了30篇文章！。</p>
<h3 id="SwiftUI-的一些初步探索-一"><a href="#SwiftUI-的一些初步探索-一" class="headerlink" title="SwiftUI 的一些初步探索 (一)"></a><a href="https://onevcat.com/2019/06/swift-ui-firstlook/">SwiftUI 的一些初步探索 (一)</a></h3><p>这是一篇解读SwiftUI的文章，目前还有<a href="https://onevcat.com/2019/06/swift-ui-firstlook-2/">第二篇</a>。而喵神也在计划写一本关于<code>SwiftUI</code> 和<code>Combine</code> 的书籍</p>
<blockquote>
<p>我已经计划写一本关于 SwiftUI 和 Combine 编程的书籍，希望能通过一些实践案例帮助您快速上手 SwiftUI 及 Combine 响应式编程框架，掌握下一代客户端 UI 开发技术。现在这本书已经开始预售，预计能在 10 月左右完成。如果您对此有兴趣，可以查看 ObjC 中国的产品页面了解详情及购买。十分感谢！</p>
</blockquote>
<p>我发现喵神总能一下找到作为新概念最应该注意的问题，比如SwiftUI和Swift5.1的关系，为什么需要新系统才能预览以及ViewBuilder里接受那些条件语句等。想了解SwiftUI 这篇文章真是必读</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="About-SwiftUI"><a href="#About-SwiftUI" class="headerlink" title="About-SwiftUI"></a><a href="https://github.com/Juanpe/About-SwiftUI">About-SwiftUI</a></h3><p><img src="https://raw.githubusercontent.com/Juanpe/About-SwiftUI/master/Assets/banner_about_swift.jpg" alt=""><br>WWDC当天开始建立的一个专门收集SwiftUI资料的仓库，应该是史上最全了。果然大家还是最爱SwiftUI！</p>
<h3 id="MovieSwiftUI"><a href="#MovieSwiftUI" class="headerlink" title="MovieSwiftUI"></a><a href="https://github.com/Dimillian/MovieSwiftUI">MovieSwiftUI</a></h3><p>使用 <code>SwiftUI</code> &amp; <code>Combine</code>和MovieDB API实现的一款应用。<br>Talk is cheap, show me the code.<br>结合实践是最快速的了解一个概念的方式。这也是最近一段时间上升最快的<code>SwiftUI&amp;Combine</code>相关仓库了。</p>
<h3 id="CombineSwiftPlayground"><a href="#CombineSwiftPlayground" class="headerlink" title="CombineSwiftPlayground"></a><a href="https://github.com/AvdLee/CombineSwiftPlayground">CombineSwiftPlayground</a></h3><p>一个帮助理解<code>Combine</code>概念的 Swift Playground。对于首次接触响应式编程的人来说具体事例是帮助理解概念很好的方式。</p>
<p>该Playgrounds要求Xcode11 beta2及以上版本才能查看。</p>
<h3 id="rxswift-to-combine-cheatsheet"><a href="#rxswift-to-combine-cheatsheet" class="headerlink" title="rxswift-to-combine-cheatsheet"></a><a href="https://github.com/freak4pc/rxswift-to-combine-cheatsheet">rxswift-to-combine-cheatsheet</a></h3><p>列举了<code>Combine</code>和<code>RxSwift</code>之间的差别和一些概念上的对比，对于有一点RxSwift概念的人来说可以快速的理解Combine，也是对于想从RxSwift迁移至Combine的一份参考。</p>
<h2 id="文摘"><a href="#文摘" class="headerlink" title="文摘"></a>文摘</h2><blockquote>
<p>普通选民也开始意识到，民主机制已经不再能够为他们带来权力。世界正在变化，但他们摸不清变化的方式和原因。权力正在转移，但选民不知道权力去了哪儿。在英国选民的想象中，权力被欧盟夺走了，所以他们投票脱欧。而在美国选民的想象中，是既得利益者垄断了权力，所以他们支持反体制的候选人，比如伯尼·桑德斯和唐纳德·特朗普。但可悲的事实是，没有人知道所有的权力去了哪儿。就算英国离开欧盟、特朗普接掌白宫，权力也绝不会回到普通选民身上。<br>–未来简史</p>
</blockquote>
<h2 id="月度小结"><a href="#月度小结" class="headerlink" title="月度小结"></a>月度小结</h2><h3 id="关于WWDC"><a href="#关于WWDC" class="headerlink" title="关于WWDC"></a>关于WWDC</h3><p>WWDC发布的信息里面最让我感兴趣的就是<code>SwiftUI</code>和<code>Combine</code>，目前从Github的活跃情况来看也是这两个技术相关仓亏最多。SwiftUI解决了写UI布局的痛点，而Combine的出现表明了苹果对响应式编程的认可，对于我这种使用了一年RxSwift的人来说简直是一种福音。还有一点是这两个大招都是对Swift的支持，这是一个很明显的信号：Swift已经很成熟了，很强大了，以后还会有更多更好的优化。</p>
<p>过去几年，你可以忽视 Swift，但是，未来几年，如果不拥抱 Swift，将无法紧跟着 Apple 生态圈。</p>
<h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>从上个月开始有规律的进行跑步，上个月跑步里程是60km，这个月是70km，距年初定的目标已经完成了56%。<br>跑步带来的一个好处是最近一段时间的睡眠质量有显著提高，睡得更香了。如果你有睡眠质量问题，可以考虑跑步这个方式尝试解决哦。</p>
<p>封面图来自于在公司园区跑道上的拍摄。</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#11|201905</title>
    <url>/2019/06/03/monthly_11/</url>
    <content><![CDATA[<p>这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。<br>欢迎推荐内容，可以前往<a href="https://github.com/zhangferry/iOSMonthlyReport">zhangferry/iOSMonthlyReport</a>提交issue。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/marc-olivier-jodoin-291607-unsplash.jpg" alt=""></p>
<a id="more"></a>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="对UISearchBar样式的修改"><a href="#对UISearchBar样式的修改" class="headerlink" title="对UISearchBar样式的修改"></a>对UISearchBar样式的修改</h3><p>1、完成一次搜索之后，调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchBar.resignFirstResponder()</span><br></pre></td></tr></table></figure>
<p>隐藏键盘，会将<br>searchBar的取消按钮默认置为<code>disEnable</code>。如果我们需要此时能够监听取消按钮的点击状态，需要恢复其可用状态:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if let cancelButton &#x3D; searchBar.value(forKey: &quot;cancelButton&quot;) as? UIButton</span><br><span class="line">    cancelButton.isEnabled &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、修改取消按钮的文案</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改searchbar的取消按钮文案</span></span><br><span class="line">searchBar.setValue(<span class="string">"delete"</span>, forKey: <span class="string">"cancelButtonText"</span>)</span><br></pre></td></tr></table></figure>
<p>3、更改取消按钮文案样式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIBarButtonItem</span>.appearance(whenContainedInInstancesOf: [<span class="type">UISearchBar</span>.<span class="keyword">self</span>])</span><br><span class="line">            .setTitleTextAttributes([<span class="type">NSAttributedString</span>.<span class="type">Key</span>.font: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)], <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure>
<p>4、更改searchBar文本框文字样式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UITextField</span>.appearance(whenContainedInInstancesOf: [<span class="type">UISearchBar</span>.<span class="keyword">self</span>])</span><br><span class="line">         .defaultTextAttributes = [<span class="type">NSAttributedString</span>.<span class="type">Key</span>.font: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="上传IAP时出现TCP-443问题"><a href="#上传IAP时出现TCP-443问题" class="headerlink" title="上传IAP时出现TCP 443问题"></a>上传IAP时出现TCP 443问题</h3><p>具体错误为： </p>
<blockquote>
<p>Communication error. Please use diagnostic mode to check connectivity. You need to have outbound access to TCP port 443.</p>
</blockquote>
<p>这是由于代理问题引起的上传错误，上传IAP至App Store Connect不需要代理，关掉代理继续上传就可以了。</p>
<h3 id="上传IAP时出现：WARNING-ITMS-90176"><a href="#上传IAP时出现：WARNING-ITMS-90176" class="headerlink" title="上传IAP时出现：WARNING ITMS-90176"></a>上传IAP时出现：WARNING ITMS-90176</h3><p>完整错误为：</p>
<blockquote>
<p>WARNING ITMS-90176: “Unrecognized Locale - The locale names used in localization directories at ( “Payload/sandbox.app/AccountKitStrings.bundle/Resources/cb_IQ.lproj” ) are invalid. iTunes supports BCP47 but not the UN M.49 specification. Refer to the Language and Locale Designations guide at <a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPInternational/LanguageandLocaleIDs/LanguageandLocaleIDs.html">https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPInternational/LanguageandLocaleIDs/LanguageandLocaleIDs.html</a> for more information on naming your language-specific directories.”</p>
</blockquote>
<p>该错误是由Xcode9不再兼容<code>cb_IQ.lproj</code>这个格式，所以只要一出<code>AccountKitStrings.bundle</code>中的<code>cb_IQ.lproj</code>文件即可。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="Core-Image-之自定义-Filter"><a href="#Core-Image-之自定义-Filter" class="headerlink" title="Core Image 之自定义 Filter~"></a><a href="http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/">Core Image 之自定义 Filter~</a></h3><p>非常详细的介绍<code>Core Image</code>中<code>Filter</code>(滤镜)涉及的概念和使用方法。<br>作者是美图的iOS开发工程师，博客多讲解图像处理相关知识，是iOS图像领域的大牛，推荐关注。</p>
<h3 id="iOS图形处理概论：OpenGL-ES，Metal，Core-Graphics，Core-Image，GPUImage，OpenCV等"><a href="#iOS图形处理概论：OpenGL-ES，Metal，Core-Graphics，Core-Image，GPUImage，OpenCV等" class="headerlink" title="iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，OpenCV等"></a><a href="https://juejin.im/post/5b5681b6f265da0f61320b0a">iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，OpenCV等</a></h3><p>对于刚接触iOS图形相关框架的小白，有一些图形框架在字面上和功能上非常容易混淆。这里旨在总结一下各种框架，区分它们的概念和功能，以作日后进一步细分学习的指引。</p>
<h3 id="Swift-5-字符串插值之美"><a href="#Swift-5-字符串插值之美" class="headerlink" title="Swift 5 字符串插值之美"></a><a href="https://swift.gg/2019/02/21/the-beauty-of-swift-5-string-interpolation/">Swift 5 字符串插值之美</a></h3><p>Swift5除了ABI稳定并没有带来很多语法上的变化，你如果以为Swift5只有ABI稳定那你就错了，它还带来了一个很强的特性—字符串插值。一开始我还以为它是一个小特性，但是当我把它和<code>AttributedStrings</code>, <code>sql</code>联系到一块时，我才发现他的强大之处！</p>
<p>还有一篇将字符串插值应用到<code>AttributedStrings</code>上的文章: <a href="https://alisoftware.github.io/swift/2018/12/16/swift5-stringinterpolation-part2/">StringInterpolation in Swift 5 — AttributedStrings</a></p>
<h3 id="如何选择开源许可证"><a href="#如何选择开源许可证" class="headerlink" title="如何选择开源许可证"></a><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证</a></h3><p>关于几种常见开源许可证的区别：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190603164444.jpg" alt=""></p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="Python-100-Days"><a href="#Python-100-Days" class="headerlink" title="Python-100-Days"></a><a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a></h3><p>Python - 100天从新手到大师。<br>作为一线移动端开发，或多或少都有着一个全栈的目标，而作为后端语言的Python无疑是最佳选择。一个star数多达3w+的Python教学项目，这足以说明Python的受欢迎程度，这份教程的受欢迎程度。</p>
<h3 id="markdown-weixin"><a href="#markdown-weixin" class="headerlink" title="markdown-weixin"></a><a href="https://github.com/cnych/markdown-weixin">markdown-weixin</a></h3><p>一个在线将 Markdown 转换为微信公众帐号文章格式的工具。<br><a href="http://md.qikqiak.com/">http://md.qikqiak.com/</a></p>
<h3 id="AssetsExtractor"><a href="#AssetsExtractor" class="headerlink" title="AssetsExtractor"></a><a href="https://github.com/pcjbird/AssetsExtractor">AssetsExtractor</a></h3><p>『Assets提取工具』是一款OSX平台上用于将Assets.car或xxx.app中打包的png图片、pdf等资源重新提取出来的开发者工具。Assets.car常见于iOS/Mac/Unity等开发中的资源打包。</p>
<h3 id="awesome-ios-bluetooth"><a href="#awesome-ios-bluetooth" class="headerlink" title="awesome-ios-bluetooth"></a><a href="https://github.com/zhangferry/awesome-ios-bluetooth">awesome-ios-bluetooth</a></h3><p>一个收集开发iOS蓝牙功能资料的仓库。从入门必读、蓝牙升级、ANCS、调试工具都有介绍。目前该库由我维护，大家有什么蓝牙相关的问题可以提issue给我。</p>
<h3 id="firefox-ios"><a href="#firefox-ios" class="headerlink" title="firefox-ios"></a><a href="https://github.com/mozilla-mobile/firefox-ios">firefox-ios</a></h3><p>火狐浏览器的iOS开源库，由Swift4.2编写。是一个优秀的可供参考学习的开源项目。</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>将黑苹果系统升级至macOS 10.14.4(Mojave)</title>
    <url>/2019/05/17/hackintosh_os_update/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190517203841.png" alt=""></p>
<h2 id="原有配置"><a href="#原有配置" class="headerlink" title="原有配置"></a>原有配置</h2><p>操作系统: macOS 10.13.6<br>主板：AORUS MASTER z390<br>CPU: intel core i7-8700<br>显卡：NVIDIA GTX 750<br>内存：Geil 8G * 2<br>硬盘：tigo SSD 240G</p>
<p>如果要升10.14的系统，首先需要确认的是当前显卡是否支持。</p>
<a id="more"></a>
<p>可以参照这个表<a href="https://blog.daliansky.net/Mojave-Hardware-Support-List.html">Mojave硬件支持列表（持续更新中）</a></p>
<p>可以看到GTX 750已经无法驱动了，所以显卡要换。最好换成免驱的，我这里选了RX 560D。</p>
<p><strong>注意事项</strong><br>gtx750是即插即用，而rx560d有专门的供电线，所以更换显卡时一定要注意别忘了插rx560d的供电线。</p>
<h2 id="升级准备"><a href="#升级准备" class="headerlink" title="升级准备"></a>升级准备</h2><p>不管是装黑苹果还是升级黑苹果都需要有一个启动U盘，它可以在我们系统配置错误无法进入的时候，帮助我们通过U盘进入，然后我们再把配置改回来就行了。</p>
<h3 id="制作启动U盘（大于8G"><a href="#制作启动U盘（大于8G" class="headerlink" title="制作启动U盘（大于8G)"></a>制作启动U盘（大于8G)</h3><p>1、插入U盘<br>2、打开 /Applications/Utilities/Disk Utility（磁盘工具）<br>3、选中U盘<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190517181447.png" alt=""><br>4、点击上方 Erase 选项按钮<br>5、你可以修改U盘名称<br>6、Format：选择Mac OS Extended(Journaled)，中文对应：Mac OS扩展(日志)；<br>Scheme：选择GUID Partition Map，中文对应：GUID 分区映射<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190517182006.png" alt=""><br>7、点击Erase按钮<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190517182411.png" alt=""><br>8、下载<a href="https://www.tonymacx86.com/resources/unibeast-9-2-0-mojave.426/">UniBeast</a><br>UniBeast版本要跟系统版本对应，需要注册tonymacx86账号才能下载。<br>9、安装UniBeast，需要把系统需要设置成英文才能进行安装。设置完毕，一路Continue。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190517183045.png" alt=""><br>10、根据提示，选择Installation Type/Bootloader Configuration/Graphics Configuration然后完成，开始Copy系统文件。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190517183045.png" alt=""><br>11、把<a href="https://www.tonymacx86.com/resources/multibeast-11-2-1-mojave.425/">MultiBeast</a>拖进U盘</p>
<p>翻译自<a href="https://www.tonymacx86.com/threads/unibeast-install-macos-mojave-on-any-supported-intel-based-pc.259381/">tonymacx86</a></p>
<h3 id="升级Clover"><a href="#升级Clover" class="headerlink" title="升级Clover"></a>升级Clover</h3><p>如果想要安装macOS Mojave 10.14，它要求你的<code>Clover Bootloader</code>版本不低于r4515。最新的Clover版本可以在这<a href="https://github.com/Dids/clover-builder/releases">下载</a>。</p>
<h2 id="升级系统"><a href="#升级系统" class="headerlink" title="升级系统"></a>升级系统</h2><p>下载好升级程序之后，直接进行安装。会重启两次，之后是较长一段时间的等待（20-30分钟），跟正常macbook升级一样的流程。如果没有意外，那么恭喜你，黑苹果升级成功了。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190517203514.png" alt=""></p>
<h2 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="关机无法断电"><a href="#关机无法断电" class="headerlink" title="关机无法断电"></a>关机无法断电</h3><p>这个问题网上有的说在config文件中的Acpi将FixShutdown选为true，有的说是增加电量修复的efi文件。我都试过，均无效，我看这方面的回答时间都比较久，应该是旧版本的解决方案。新版本只需要将FixShutdown制为false即可。</p>
<h3 id="安装过程卡在最后2分钟或者卡在最开始18分钟"><a href="#安装过程卡在最后2分钟或者卡在最开始18分钟" class="headerlink" title="安装过程卡在最后2分钟或者卡在最开始18分钟"></a>安装过程卡在最后2分钟或者卡在最开始18分钟</h3><p>在EFI的drivers64UEFI文件中增加<code>OsxAptioFixDrv3-64.efi</code>文件即可。<br>完整的<a href="https://pan.baidu.com/s/1faSAQm7RbTGRqc6_y6P9Ug">EFI</a>文件，提取码：awxl。</p>
<h3 id="如果因为配置出错无法进入系统"><a href="#如果因为配置出错无法进入系统" class="headerlink" title="如果因为配置出错无法进入系统"></a>如果因为配置出错无法进入系统</h3><p>在BIOS界面选择U盘启动，即可通过U盘配置的EFI进入系统。然后更改正确设置即可。</p>
<h3 id="重要文件记得备份"><a href="#重要文件记得备份" class="headerlink" title="重要文件记得备份"></a>重要文件记得备份</h3><ul>
<li>Time Machine 免费</li>
<li><a href="https://bombich.com/">Carbon Copy Cloner</a> ￥290.15</li>
<li><a href="https://www.shirt-pocket.com/SuperDuper/SuperDuperDescription.html">Super Duper</a> $27.95</li>
</ul>
<p>Time Machine因为是苹果自带的功能，而且还免费，比较推荐使用这个。附一份<a href="https://support.apple.com/zh-cn/HT201250">教程</a></p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>当然配置黑苹果的机型组合有很多种，可能会遇到各式各样的问题。这里再贴几个可以参考的链接：<br><a href="https://blog.daliansky.net/Common-problems-and-solutions-in-macOS-Mojave-10.14-installation.html">macOS Mojave 10.14安装中常见的问题及解决方法</a><br><a href="https://github.com/tsingui/clover-efi">Hackintosh黑苹果驱动Clover</a></p>
]]></content>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】iOS13新特性抢鲜看</title>
    <url>/2019/05/10/iOS13_new_features/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.macrumors.com/roundup/ios-13/">原文链接</a><br>作者：MacRumors Staff<br>原文日期：2019-5-2</p>
</blockquote>
<h2 id="初览"><a href="#初览" class="headerlink" title="初览"></a>初览</h2><p>iOS13是苹果针对iPhone和iPad的下一代操作系统，将会在6月份的WWDC上和大家初次见面。传闻的功能包括夜间模式、iPad界面更新和新的主屏幕。</p>
<a id="more"></a>
<h2 id="我们可以期待什么"><a href="#我们可以期待什么" class="headerlink" title="我们可以期待什么"></a>我们可以期待什么</h2><p>苹果位于加州的总部已经在开发iOS操作系统的下一个升级版本，该系统可以在iPhone、iPad和iPod touch上运行。</p>
<p>虽然目前我们对这款新软件的了解有限，但我们已经听到了一些有趣的传言，这些传言透露了一些我们有望在此次更新中看到的功能和变化，根据之前的更新，这次更新将被命名为“iOS 13”。<a href="https://www.macrumors.com/roundup/ios-12/">iOS 12</a>标志着苹果iOS开发政策的重大转变，工程师们现在有了更多的自由，可以在必要时推出尚未准备好的功能。</p>
<p>由于这个原因，iOS 13可能比之前的更新更加成熟，同时，任何未最终确定的功能都有可能被推迟。</p>
<p>由于苹果在iOS 12到iOS 13之间专注于bug修复和底层改进所引起的延迟，我们已经获取了惊人数量的泄漏信息，所以可以预见6月份iOS 13不少的特性。</p>
<p>我们可以预见的功能包括夜晚模式，音量外观的改变，iPad上关于多任务的更新，新的撤销手势，一个合并了“寻找手机”和“寻找朋友”的APP：“寻找我的手机”，闹钟和邮件的更新，以及像iOS app可以很容易的在Mac上使用这样的扩平台能力。</p>
<p>我们有望在6月份的WWDC首次一睹iOS 13的风采，届时将正式发布新款iPhone。开发者和开放的测试人员将更早一点使用到这次更新，beta版本系统测试期间，我们也会在MacRumors.com上持续跟进新的特性和改变。</p>
<h2 id="可能的特性"><a href="#可能的特性" class="headerlink" title="可能的特性"></a>可能的特性</h2><h3 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h3><p>iOS 13将首次拥有夜间模式，这个功能iOS用户已经期盼了相当一段时间了。这个夜间模式和MacOS Mojave里的夜间模式相呼应，它会会使用户拥有一个更好的夜晚观看体验。今年的WWDC里有一张夜间主题的效果图，可能正暗示了即将到来的iOS 13的夜间模式。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190506161208.jpg" alt=""></p>
<h3 id="iPad调整"><a href="#iPad调整" class="headerlink" title="iPad调整"></a>iPad调整</h3><p>iOS 13中将有几个特性是关于iPad的。据说，苹果将推出一项功能，可以在一个iPad应用程序中使用tab视图显示多个窗口。改进的多任务处理功能将在iOS 13中实现，iPad应用程序支持多个窗口和应用程序内的可堆叠卡。应用程序的特点是，最初附加在屏幕某一部分上的表格，可以通过拖动手势分离，变成一张可以操纵的卡片。</p>
<p>卡片可以叠在另一张上面，深度效果将指示卡片的上下效果，快速滑动卡片将使它消失。</p>
<h3 id="新的手势"><a href="#新的手势" class="headerlink" title="新的手势"></a>新的手势</h3><p>iPad或将拥有一个新的对于标准文本输入时的撤销手势，用户可以通过三根手指轻敲键盘区域，然后向左或者向右滑动，就可以撤销或者重做一个动作。</p>
<p>新的手势将允许用户在表视图和集合视图中选择多个项目，允许他们在项目列表上拖动多个手指来绘制选择，类似于Mac上的单击和拖动Finder。</p>
<h3 id="音量指示器更新"><a href="#音量指示器更新" class="headerlink" title="音量指示器更新"></a>音量指示器更新</h3><p>iOS 13获奖包含一个新的音量指示器，它会比现在的指示器样式更缓和。</p>
<h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p>新的邮件app将把邮件内容分成市场、购买、旅游、不重要、更多等可搜索分类。此外还有一个稍后阅读的队列和一个针对特殊邮件线程的静音收件选项。</p>
<h3 id="跨平台的iOS和Mac应用"><a href="#跨平台的iOS和Mac应用" class="headerlink" title="跨平台的iOS和Mac应用"></a>跨平台的iOS和Mac应用</h3><p>在iOS 12和macOS Mojave的时候，苹果引入了一个新框架桥接iOS和Mac之间的应用，作为测试，像股票、家庭和录音等iOS独享的app被发布到macOS上。在iOS 13和macOS10.15, 苹果计划向开发者扩大这个功能，这将使得应用从iOS平台到Mac上的迁移更加容易。</p>
<h3 id="新版“找到我的手机”"><a href="#新版“找到我的手机”" class="headerlink" title="新版“找到我的手机”"></a>新版“找到我的手机”</h3><p>苹果正在开发一个融合“查找朋友”和“查找iPhone”的新应用，它很可能会随着iOS 13和macOS 10.15一同发布。该应用程序将包括一个新的“查找网络”功能，允许苹果设备被跟踪，即使没有连接到Wi-Fi或蜂窝网络，原理是利用附近的其他设备。</p>
<p>这个应用将包括已有的查找手机功能，像丢失模式、远程擦除设备。从“查找朋友”中提取的基于位置的共享选项也仍然可用。</p>
<p>据说苹果还在研究一个相关的硬件产品，像是瓦片一样的跟踪器。它被描述为一个“标签”，能够附着在任何设备上，并且通过用户的iCloud账号进行配对。当用户距离他们绑定的设备太远的话，这个小东西就会发出报警声，它是基于与iPhone之间的距离工作的。苹果没说什么时候发布它，但是有可能是跟新版iPhone一同发布。</p>
<h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3><p>新版的地图应用将使哪些常用地址像是家或者公司的设置和导航更简单。频繁使用的地址信息将会更高效的分类，并且可以为他们配上图片。</p>
<h3 id="提醒事项"><a href="#提醒事项" class="headerlink" title="提醒事项"></a>提醒事项</h3><p>一个新的提醒应用程序将在一个网格中包含四个默认部分，包括今天要完成的任务、所有任务、计划任务和标记任务。</p>
<h3 id="图书"><a href="#图书" class="headerlink" title="图书"></a>图书</h3><p>新版的图书应用将包含一个新的进度追踪功能和一个旨在鼓励用户阅读的奖励系统。</p>
<h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><p>新的家庭应用将更好地与安全摄像头集成，并将提供一项无需第三方应用就能查看过去录音的功能。</p>
<h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><p>新的健康应用将有一个改良的每日活动视图和更加全面的月经周期跟踪。还会有一个“听力健康”的功能，它可以测量你耳机和周围环境的音量。</p>
<h2 id="其他新功能"><a href="#其他新功能" class="headerlink" title="其他新功能"></a>其他新功能</h2><h3 id="速度提升和bug修复"><a href="#速度提升和bug修复" class="headerlink" title="速度提升和bug修复"></a>速度提升和bug修复</h3><p>iOS 13和iOS 12很像，将会提高运行速度，并修复一个bug。</p>
<h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>将会有一个新的默认的基于滑动的键盘可用，类似于SwiftKey。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>字体管理将在iOS 13中得到改进，设置应用程序将获得一个新的字体管理菜单。</p>
<h3 id="更新分享栏"><a href="#更新分享栏" class="headerlink" title="更新分享栏"></a>更新分享栏</h3><p>在iOS 13中，用于共享照片和web链接的共享表单界面将变得更加智能，这意味着用户可以向其中发送内容。</p>
<h3 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h3><p>在iPad的iOS 13系统中，Safari会在必要时自动加载桌面版本的网站。苹果正在测试一款Safari下载管理器，用户可以在一个地方下载。</p>
<h3 id="照片实况更新"><a href="#照片实况更新" class="headerlink" title="照片实况更新"></a>照片实况更新</h3><p>苹果计划将照片实况的视频长度延长至原来的两倍，也就是从3秒变成6秒。</p>
<h3 id="嗨Siri"><a href="#嗨Siri" class="headerlink" title="嗨Siri"></a>嗨Siri</h3><p>”嗨Siri“将会更好的过滤像是笑声和孩子哭声这种环境音。</p>
<h3 id="屏幕使用时间"><a href="#屏幕使用时间" class="headerlink" title="屏幕使用时间"></a>屏幕使用时间</h3><p>屏幕使用时间功能将增加一个新功能用于限制孩子对手机的使用，可以设定一个可以和不可以玩的时间。</p>
<h3 id="界面的更新"><a href="#界面的更新" class="headerlink" title="界面的更新"></a>界面的更新</h3><p>当启动多任务处理面板并关闭应用程序时，将会有一个新的动画，iPad的主屏幕将会发生一些变化。</p>
<h3 id="文件应用的修改"><a href="#文件应用的修改" class="headerlink" title="文件应用的修改"></a>文件应用的修改</h3><p>虽然关于一个改版后的文件应用程序会是什么样子的细节很少，但据说苹果正在为它开发新的功能，比如更好的第三方软件集成。</p>
<h3 id="新版的Emojis"><a href="#新版的Emojis" class="headerlink" title="新版的Emojis"></a>新版的Emojis</h3><p>新表情符号将不会在iOS 13发布时出现，但在2019年晚些时候的iOS 13更新中，苹果将会引入他们。Unicode联盟已经确定了加入表情符号标准的<a href="https://www.macrumors.com/2019/02/05/2019-new-emoji-list/">字符</a>，其中包括火鸟、水獭、华夫饼、树懒、白心、牵手的人、冰块、潜水器、猩猩、果汁盒、沙拉三明治等等。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190510115235.jpg" alt=""></p>
<h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>一个更全面的辅助功能菜单将出现在设置应用程序的主页上，其中包括改进的助听器支持等。</p>
<h3 id="iPad-Pro支持鼠标"><a href="#iPad-Pro支持鼠标" class="headerlink" title="iPad Pro支持鼠标"></a>iPad Pro支持鼠标</h3><p>有传言称，苹果公司可能计划在iPad Pro上添加USB鼠标支持，作为一项辅助功能，而不需要使用适配器。</p>
<p>据报道，iPad Pro的USB-C接口将允许你插入USB鼠标，作为那些无法使用触摸屏的用户的另一种输入方式。目前还不清楚该功能何时会实现，但它最早可能在iOS 13中实现。</p>
<h2 id="跟开发者相关的变化"><a href="#跟开发者相关的变化" class="headerlink" title="跟开发者相关的变化"></a>跟开发者相关的变化</h2><p>对于开发者来说，iOS 13将为媒体播放、搜索、语音呼叫、活动票务、消息附件、航班等功能带来改进的<a href="https://www.macrumors.com/2019/04/22/wwdc-2019-developer-features-rumors/">Siri集成</a>。</p>
<p>其他面向开发者的功能还包括ARKit的改进，它为增强现实提供了一个全新的快速框架，以及一个配套的应用程序，让开发者可以在视觉上创建增强现实体验。ARKit还将支持游戏控制器和立体声AR耳机。</p>
<p>新框架将包括扩展使用Taptic引擎，对第三方应用程序的文档扫描支持，以及无需使用照片应用程序即可从外部设备捕捉照片的功能。</p>
<p>NFC将得到改进，开发人员将能够在他们的应用程序中添加对扩展的NFC格式的支持，并且还将添加CoreML的更新版本。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#10|201904</title>
    <url>/2019/04/30/monthly_10/</url>
    <content><![CDATA[<p>这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。<br>欢迎推荐内容，可以前往<a href="https://github.com/zhangferry/iOSMonthlyReport">zhangferry/iOSMonthlyReport</a>提交issue。</p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190428174837.jpg" alt=""></p>
<a id="more"></a>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="关于分享中的一些问题"><a href="#关于分享中的一些问题" class="headerlink" title="关于分享中的一些问题"></a>关于分享中的一些问题</h3><p><strong>微博</strong></p>
<ul>
<li>多媒体内容的缩略图，即thumbnialData的大小应小于32K。否则会导致分享失败</li>
<li>微博分享的AppStore下载链接无法打开，这是因为微博屏蔽了指向AppStore的链接。一个可行的做法的将微博的下载链接增加一个引导页，提醒用户通过Safari打开。</li>
</ul>
<p><strong>微信</strong></p>
<ul>
<li>多媒体缩略图不能超过64K。</li>
<li>微信分享从6.7.2之后无法获知是否真的分享成功。这个是官方的调整，旨在减少“强制分享至不同群”等滥用分享能力。</li>
</ul>
<p><strong>facebook</strong><br>关于facebook分享的采坑可以查看这篇文章，基本也都是我遇到的问题。<a href="https://www.jianshu.com/p/0e9c73e310c8">iOS Facebook 分享中的坑</a></p>
<p><strong>Twitter</strong><br>相同内容分享两次之后再分享将失败。</p>
<h3 id="SWIFT-VERSION-‘5-0’-is-unsupported-supported-versions-are-3-0-4-0-4-2-in-target-‘SwiftyJSON’"><a href="#SWIFT-VERSION-‘5-0’-is-unsupported-supported-versions-are-3-0-4-0-4-2-in-target-‘SwiftyJSON’" class="headerlink" title="SWIFT_VERSION ‘5.0’ is unsupported, supported versions are: 3.0, 4.0, 4.2. (in target ‘SwiftyJSON’)"></a>SWIFT_VERSION ‘5.0’ is unsupported, supported versions are: 3.0, 4.0, 4.2. (in target ‘SwiftyJSON’)</h3><p>这个问题是多人写作开发引起的，有一个同事将<code>SwiftJSON</code>的版本升级至4.3.0，使其支持Swift5.0，但是Swift5.0跟Swift4.0+不兼容，导致出现上面的错误提示。</p>
<p>修复方式，手动指定<code>SwiftJSON</code>版本，使其低于或者等于4.2.0。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">'SwiftyJSON'</span>, <span class="string">'~&gt; 4.2.0'</span></span><br></pre></td></tr></table></figure>
<h3 id="Encountered-an-unknown-error-Unable-to-find-a-specification-for-FrameworkA-depended-upon-by-FrameworkB"><a href="#Encountered-an-unknown-error-Unable-to-find-a-specification-for-FrameworkA-depended-upon-by-FrameworkB" class="headerlink" title="Encountered an unknown error (Unable to find a specification for FrameworkA depended upon by FrameworkB"></a>Encountered an unknown error (Unable to find a specification for FrameworkA depended upon by FrameworkB</h3><p><code>FrameworkA</code>和<code>FrameworkB</code>都是私有的<code>Cocoapods</code>库，在制作<code>FrameworkA</code>时引用了<code>FrameworkB</code>，如果执行<code>pod spec lint</code>就会出现如上的提示，到时lint无法通过。</p>
<p>这是因为lint在对引用库验证时，默认只验证官网的仓库，我们需要手动添加验证源才能通过，方法是：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod spec lint --sources=git@bitbucket.<span class="symbol">org:</span>company/privateRepo.git,<span class="symbol">https:</span>/<span class="regexp">/github.com/</span>CocoaPods/Specs --allow-warnings</span><br></pre></td></tr></table></figure>
<h3 id="Tabbar的初始化会立即调用viewDidLoad方法"><a href="#Tabbar的初始化会立即调用viewDidLoad方法" class="headerlink" title="Tabbar的初始化会立即调用viewDidLoad方法"></a>Tabbar的初始化会立即调用viewDidLoad方法</h3><p>正常当我们初始一个<code>UIViewController</code>的时候，总是先执行<code>init</code>方法，执行完之后才会调用<code>viewDidLoad</code>方法。但是如果是<code>UITabbarViewController</code>的初始化则不同，它会在执行<code>init</code>方法的时候立即调用<code>viewDidLoad</code>。</p>
<p>来自Stack Overflow的解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UITabBarControllers call loadView inside [super init] method, which causes the call to viewDidLoad. So the viewDidLoad method will be called before init has finished its job.</span><br><span class="line"></span><br><span class="line">If you have some thing to setup in viewDidLoad you should perhaps do it inside init method after the call to [super init].</span><br></pre></td></tr></table></figure>

<h3 id="AppleScript打印换行"><a href="#AppleScript打印换行" class="headerlink" title="AppleScript打印换行"></a>AppleScript打印换行</h3><p>当我使用AppleScript编辑一段脚本时，有一个需求是打印一段换行的文本，试了很多方案，包括<code>\n</code>,<code>\r</code>, <code>ASCII码</code>等都不行，脚本执行时会忽略<code>\</code>符合自动换行，分开执行输入内容。</p>
<p>最后在不断尝试中找到了一种方案，直接敲出换行，如下，在变量<code>_input</code>后拼接一个换行符：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tell</span> note1 <span class="keyword">to</span> append <span class="built_in">text</span> <span class="string">"[*]"</span> &amp; _input &amp; <span class="string">"</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>

<h3 id="由于第三方SDK使用了用于定位的功能，导致收到苹果的隐私警告邮件"><a href="#由于第三方SDK使用了用于定位的功能，导致收到苹果的隐私警告邮件" class="headerlink" title="由于第三方SDK使用了用于定位的功能，导致收到苹果的隐私警告邮件"></a>由于第三方SDK使用了用于定位的功能，导致收到苹果的隐私警告邮件</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190428151857.png" alt=""><br>后来定位的到的原因是<code>Facebook</code>相关的几个库均使用了<code>CoreLocation</code>，也就是说<code>Facebook</code>有偷偷使用用户地理位置权限的嫌疑。当然联系他们提供不带此功能的SDK也不显示，后来在react的issuse中也发现了对于此问题的讨论。<a href="https://github.com/facebook/react-native/issues/20879">#20879</a></p>
<p>解决方案如下，即增加对应的隐私条款选项：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190428153423.png" alt=""></p>
<h3 id="违反Guideline2-3-1被打回"><a href="#违反Guideline2-3-1被打回" class="headerlink" title="违反Guideline2.3.1被打回"></a>违反Guideline2.3.1被打回</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190430101209.png" alt=""><br>在一次小版本提交时，遇到了这个违反Guideline2.3.1被打回的问题，也是第一次遇到。原因描述是含有模糊代码，选择器错误或者误导审核的功能。实际排查中我们并未猜想到哪里可能导致这些问题。</p>
<p>后来通过邮件跟审核人员沟通，得到如下回复：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190430103042.png" alt=""><br>问题又好了？猜想可能是苹果审核的问题，他们也是会犯错误的。</p>
<p>后来在网上查过这种问题的处理情况，从资料时间来看，可以确定这个是最近一年才出现过的问题。处理方法是，首先是应该跟审核人员联系，让他们告知是哪里的问题；然后再根据情况进行修改。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="作为面试官，哪类-iOS-开发更容易被你青睐？"><a href="#作为面试官，哪类-iOS-开发更容易被你青睐？" class="headerlink" title="作为面试官，哪类 iOS 开发更容易被你青睐？"></a><a href="https://mp.weixin.qq.com/s/IpbKUX7562uGA9caYdV-3w">作为面试官，哪类 iOS 开发更容易被你青睐？</a></h3><p>来自老司机团队的文章，正在找工作的你肯定能从中有所收获。</p>
<p>再贴一个我司的<a href="https://zhangferry.com/2019/04/12/ios-interview/">招聘信息</a>，有意愿的小伙伴赶紧简历投过来。</p>
<h3 id="用户端智能的应用实践"><a href="#用户端智能的应用实践" class="headerlink" title="用户端智能的应用实践"></a><a href="http://blog.cnbang.net/tech/3643/">用户端智能的应用实践</a></h3><p>bang写的关于应用功能优化的几个点，根据用户的特征推荐金额，根据用户使用习惯调整push的时间，有些方案不一定能够为我们所用但是解决问题的思路还是挺不错的。</p>
<h3 id="谈Linux，Windows-和Mac"><a href="#谈Linux，Windows-和Mac" class="headerlink" title="谈Linux，Windows,和Mac"></a><a href="http://www.yinwang.org/blog-cn/2013/03/07/linux-windows-mac">谈Linux，Windows,和Mac</a></h3><p><a href="http://www.yinwang.org/">王垠</a>的博客其实已经被删除了，这个是网络留存的快照文件。牛B的人总是能留下牛B的话，这是王垠关于Linux、Windows和Mac的看法。</p>
<h3 id="Swift语言的设计错误"><a href="#Swift语言的设计错误" class="headerlink" title="Swift语言的设计错误"></a><a href="http://www.yinwang.org/blog-cn/2016/06/06/swift">Swift语言的设计错误</a></h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line"><span class="comment">//这么写应不应该报错？</span></span><br><span class="line">shoppingList[<span class="number">0</span>] = <span class="string">"Salad"</span></span><br></pre></td></tr></table></figure>
<p>关于以上问题的讨论。当前Swift是不允许对<code>let</code>生命的数字修改内部元素的。在王垠看来这是一个低级的错误，具体为什么这么定义“不对”，可以看文章讨论。</p>
<h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="iOS-Source-Probe"><a href="#iOS-Source-Probe" class="headerlink" title="iOS-Source-Probe"></a><a href="https://github.com/Desgard/iOS-Source-Probe">iOS-Source-Probe</a></h3><p>iOS源码探求系列，是iOS相关源码的分析合集。</p>
<h3 id="AutoInch"><a href="#AutoInch" class="headerlink" title="AutoInch"></a><a href="https://github.com/lixiang1994/AutoInch">AutoInch</a></h3><p>优雅的iPhone全尺寸/等比例精准适配工具，可以通过设置一个屏幕的尺寸值，而自动配置其他尺寸值。支持代码和xib两种方式。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190428173326.png" alt=""></p>
<h3 id="SwiftTips"><a href="#SwiftTips" class="headerlink" title="SwiftTips"></a><a href="https://github.com/Luur/SwiftTips">SwiftTips</a></h3><p>作者总结的Swift使用中的一些小技巧，和喵神的<a href="https://leanpub.com/swifter">《100 个 Swift 必备 tips》</a>有异曲同工之妙。作为一名刚入门的Swifter，这两个资料都是非常推荐看一看的。</p>
<h3 id="ZFPlayer"><a href="#ZFPlayer" class="headerlink" title="ZFPlayer"></a><a href="https://github.com/renzifeng/ZFPlayer">ZFPlayer</a></h3><p>非常全面的一款iOS播放器，支持AVPlayer和ijkplayer两种播放模块。项目包含主流的视频播放场景，抖音、微博短视频等样式。如果是对视频功能有需求的小伙伴非常建议看一看。</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>一则iOS招聘信息</title>
    <url>/2019/04/12/ios-interview/</url>
    <content><![CDATA[<p>今天放出一波我司的招聘信息吧，这里只说了iOS的招聘要求。其实还有Android + Unity + 游戏测试等一大波岗位虚位以待，如果有意愿的小伙伴可以私信我哦。</p>
<a id="more"></a>
<h2 id="公司介绍"><a href="#公司介绍" class="headerlink" title="公司介绍"></a>公司介绍</h2><p>乐信圣文（Learnings）是一家全球领先的移动出海应用开发商，致力于未全球用户提供卓越的移动应用。公司成立于2016年2月份，是行业成长最快的企业之一，是Google，Facebook和Apple的全球战略合作伙伴。<br>截至2018年11月，公司产品在全球移动端月活用户超过2000万，累计用户超过3亿；其中70来自欧美地区。</p>
<p>团队规模：150人<br>公司地址：海淀区东升科技园（地铁8号线西小口站）</p>
<h2 id="明星产品-Peace冥想"><a href="#明星产品-Peace冥想" class="headerlink" title="明星产品-Peace冥想"></a>明星产品-Peace冥想</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/peace.home.png" alt=""><br>【App Store 2018年11月编辑最爱】<br>【App Stroe 首页《生活解决方案》专题推荐】<br>【App Store 健康健美分类编辑推荐】</p>
<p>“Peace”冥想是一款你的负面情绪排解神器，随时随地帮你在短短5分钟内与自己和解。助眠，减压，它是都市快生活下的一剂良药。</p>
<p>Peace上线不到一年，就表现出了巨大的成长潜力，它的未来将会更加灿烂。</p>
<h2 id="任职要求"><a href="#任职要求" class="headerlink" title="任职要求"></a>任职要求</h2><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/glenn-carstens-peters-203007-unsplash.jpg" alt=""><br><strong>职位：</strong><br>iOS中高级开发<br><strong>薪资：</strong><br>15<del>30k + 年终奖（1</del>6个月薪资）<br><strong>任职要求：</strong></p>
<ul>
<li>我们期望你有3年以上开发经验，当然如果你能力够强，这条可以忽略。</li>
<li>对数据结构、面向对象、设计模式有一定的认识</li>
<li>具备独立开发一款产品的能力</li>
<li>乐观、主动、具备团队合作精神</li>
</ul>
<h2 id="福利待遇"><a href="#福利待遇" class="headerlink" title="福利待遇"></a>福利待遇</h2><ul>
<li>双休（非996！）</li>
<li>一日三餐</li>
<li>运动健身（室内台球、乒乓球每周篮球训练）</li>
<li>顶配Macbook Pro + 升降办公桌</li>
<li>零食下午茶</li>
<li>节日福利</li>
<li>不打卡</li>
<li>…<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/WechatIMG55.jpeg" alt=""></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/taiqiu.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/WechatIMG54.jpeg" alt=""></p>
<h2 id="欢迎你的加入"><a href="#欢迎你的加入" class="headerlink" title="欢迎你的加入"></a>欢迎你的加入</h2><p>有没有心动呢，心动不如行动，有兴趣，有需求的小伙伴赶紧把简历砸过来吧！</p>
<p>我们有各个技术栈的大牛，可以让你进步更快；我们敢于尝试新技术，一年前就已经使用纯Swift开发项目；我们重视人才，只要你够牛，薪资+年终奖拿到你手软。</p>
<p>来到公司之后，我们将一起经营维护Peace这颗新星产品，一起见证它的成长吧。</p>
]]></content>
      <tags>
        <tag>工作</tag>
        <tag>招聘</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#9|201903</title>
    <url>/2019/03/31/monthly_9/</url>
    <content><![CDATA[<p>这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。<br>欢迎推荐内容，可以前往<a href="https://github.com/zhangferry/iOSMonthlyReport">zhangferry/iOSMonthlyReport</a>提交issue。<br><img src="http://upload-images.jianshu.io/upload_images/1059465-afa5d63933b5bf3c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<a id="more"></a>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Spine-SpriteKit"><a href="#Spine-SpriteKit" class="headerlink" title="Spine + SpriteKit"></a>Spine + SpriteKit</h3><p>项目中需要引入一些实物动画，每个动画之间有不同形态的切换，考虑过gif, mp4, AE + lottie, Spine + SpriteKit。</p>
<p>最后确定使用<a href="http://zh.esotericsoftware.com/">Spine</a>做动画效果，用SpriteKit处理动画。Spin并没有官方支持SpirteKit的库，但有一个做的比较好的第三方库<a href="https://github.com/maxgribov/Spine">maxgribov/Spine</a>，支持Swift4.1。</p>
<p>该库支持Bones, Slots, Skins等常用的动画要素，通过Spine导出的json文件和动画素材做出各种动画效果，是仅有的近期还在维护的支持SpriteKit的Spine运行时库。但它也存在一个问题，还不支持Mesh Animation(网格动画)。如果所需的动画效果不需要网格的话，非常推荐使用这个库。</p>
<p>而我们所需的动画效果又必须用到网格动画，思考再三考虑决定放弃使用这个库，使用SKTextureAtlas(纹理集) + 逐帧动画来实现特殊的动画效果。虽然输出的还是png序列，但是SpriteKit对纹理集有足够的优化，Xcode会在打包时把.atlas文件夹中的所有图片做成一张合图，然后生成一个plist文件描述每个小图片的位置信息，所以包的大小和渲染成本都会大大降低。</p>
<h3 id="快速创建转场样式"><a href="#快速创建转场样式" class="headerlink" title="快速创建转场样式"></a>快速创建转场样式</h3><p>说到自定义转场我们可能会直接想到<code>UIViewControllerAnimatedTransitioning</code>，结合这个类我们可以实现多种多样的订阅样式。但是使用这种方式做转场，我们需要引入很多代码。有一种简单的实现转场的方式是通过<code>CATransition</code></p>
<blockquote>
<p>An object that provides an animated transition between a layer’s states.</p>
</blockquote>
<p>通过文档的介绍我们知道，这个类就是用来做转场的，只不过支持的样式有限，但如果正好满足你需要的话，推荐使用这种方式来实现转场。</p>
<p>我们来实现一个present的渐变效果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建transition对象</span></span><br><span class="line"><span class="keyword">let</span> transition = <span class="type">CATransition</span>()</span><br><span class="line">transition.duration = <span class="number">0.5</span></span><br><span class="line"><span class="comment">//动画样式</span></span><br><span class="line"><span class="comment">//type: .fade, .moveIn, .push, .reveal</span></span><br><span class="line">transition.type = .fade</span><br><span class="line"><span class="comment">//动画出现方位</span></span><br><span class="line"><span class="comment">//subtype: .fromRight, .fromLeft, .fromTop, .fromBottem</span></span><br><span class="line"><span class="comment">//transition.subtype = .fromRight</span></span><br><span class="line">transition.timingFunction = <span class="type">CAMediaTimingFunction</span>(name: .easeIn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.view.window?.layer.add(transition, forKey: <span class="string">"present"</span>)</span><br><span class="line"><span class="keyword">self</span>.present(targetVc, animated: <span class="literal">false</span>, completion: completion)</span><br></pre></td></tr></table></figure>
<p>如果是做push的渐变，我们只需要改变最后的控制动画的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父容器为UINavigationController</span></span><br><span class="line"><span class="keyword">self</span>.view.layer.add(transition, forKey: <span class="string">"push"</span>)</span><br><span class="line"><span class="keyword">self</span>.present(targetVc, animated: <span class="literal">false</span>, completion: completion)</span><br><span class="line"></span><br><span class="line"><span class="comment">//父容器为UITabbarController</span></span><br><span class="line"><span class="keyword">self</span>.tabBarController?.view.layer.add(transition, forKey: <span class="string">"push"</span>)</span><br><span class="line"><span class="keyword">self</span>.present(targetVc, animated: <span class="literal">false</span>, completion: completion)</span><br></pre></td></tr></table></figure>

<h3 id="什么是UserAgent"><a href="#什么是UserAgent" class="headerlink" title="什么是UserAgent"></a>什么是UserAgent</h3><p><code>User-Agent</code> 首部包含了一个特征字符串，用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号，然后前端的展示就可以根据这些信息进行针对性的优化。</p>
<p>我们打开Chrome浏览器，生成一个请求，然后用Charles抓包，可以看到对应的<code>User-Agent</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">user-agent  Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10</span>_13_6) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">74.0</span><span class="number">.3729</span><span class="number">.28</span> Safari/<span class="number">537.36</span></span><br></pre></td></tr></table></figure>
<p>通过UA我们可以得到以下信息：</p>
<table>
<thead>
<tr>
<th>信息项</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器名称</td>
<td>Chrome</td>
</tr>
<tr>
<td>浏览器版本号</td>
<td>70.4.3729.28</td>
</tr>
<tr>
<td>渲染引擎</td>
<td>WebKit 537.36</td>
</tr>
<tr>
<td>操作系统</td>
<td>Mac OS 10.13.6</td>
</tr>
</tbody></table>
<h3 id="Apple-Configurator-2-出现-Unauthorized-Error"><a href="#Apple-Configurator-2-出现-Unauthorized-Error" class="headerlink" title="Apple Configurator 2 出现 Unauthorized Error"></a>Apple Configurator 2 出现 Unauthorized Error</h3><p>注销账号，再次登录</p>
<h3 id="Command-PhaseScriptExecution-failed-with-a-nonzero-exit-code"><a href="#Command-PhaseScriptExecution-failed-with-a-nonzero-exit-code" class="headerlink" title="Command PhaseScriptExecution failed with a nonzero exit code"></a>Command PhaseScriptExecution failed with a nonzero exit code</h3><p>运行一个项目时遇到了这个bug提示，一直编译不过去，这其实是一个Xcode10引起的bug<a href=""></a>。<br>解决方案：<br>在Xcode菜单栏选择File -&gt; Workspace Setting -&gt; Build System 选择Legacy Build System 重新运行即可。<br>参考：<a href="https://juejin.im/post/5ba35cc05188255c7c655a8c">踩坑Xcode 10之New Build System</a></p>
<h3 id="斐波那契函数"><a href="#斐波那契函数" class="headerlink" title="斐波那契函数"></a>斐波那契函数</h3><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>
<p>这个是我们公司技术面试的必问题目，也是筛掉人数最多的一个问题。有一部分同学会使用数组尝试解决这个问题，但这会把问题复杂度升级，还有些可能根本没有思路。但其实这个问题不复杂的，用到递归可以很快的解决。斐波那契函数的数学表达是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(1)&#x3D;1</span><br><span class="line">F(2)&#x3D;1</span><br><span class="line">F(n)&#x3D;F(n-1)+F(n-2)（n&gt;&#x3D;3，n∈N*）</span><br></pre></td></tr></table></figure>
<p>用Swift实现就是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n: n - <span class="number">1</span>) + fibonacci(n: n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="SpriteKit-Tutorial-for-Beginners"><a href="#SpriteKit-Tutorial-for-Beginners" class="headerlink" title="SpriteKit Tutorial for Beginners"></a><a href="https://www.raywenderlich.com/71-spritekit-tutorial-for-beginners">SpriteKit Tutorial for Beginners</a></h3><p>raywenderlich上介绍SpriteKit入门的一篇教程，通过这篇文章你可以实现一个忍者击杀怪物的小游戏，理解SpriteKit框架里常用的几种游戏元素。不得不说这个教程做的是真的棒👍</p>
<h3 id="开发小知识"><a href="#开发小知识" class="headerlink" title="开发小知识"></a><a href="https://www.jianshu.com/p/5a4ba3c165b9">开发小知识</a></h3><p>该文章主要整理一些小知识点，主要涉及 iOS 以及计算基础相关知识点，某些知识点暂时只有标题，后续会持续更新。笔者最近一段时间面试过程中发现一些普遍现象，对于一些很不起眼的问题，很多开发者都只停留在知道、听说过的层面，但是一旦问 是什么 和 为什么 ，很多应试者回答的并不理想。<br>大家可以对着这篇文章查找自己的知识盲区。</p>
<h3 id="Swift-5-终于来了，快来看看有什么更新！！"><a href="#Swift-5-终于来了，快来看看有什么更新！！" class="headerlink" title="Swift 5 终于来了，快来看看有什么更新！！"></a><a href="https://mp.weixin.qq.com/s/-fLVdoTz3lT5Kxnea0-Avg">Swift 5 终于来了，快来看看有什么更新！！</a></h3><p>Xcode10.2 已经发布，是时候开始使用 Swift5 了，可以提前看下老司机周报总结的Swift5 更新内容，对适配工作做好准备。</p>
<h3 id="苹果开了一场没有任何硬件的发布会"><a href="#苹果开了一场没有任何硬件的发布会" class="headerlink" title="苹果开了一场没有任何硬件的发布会"></a><a href="https://mp.weixin.qq.com/s/ggqK8kzU0efgTdPIZ5vbVw">苹果开了一场没有任何硬件的发布会</a></h3><p>3 月 26 日凌晨 1 点，苹果在 Apple Park 新总部的乔布斯剧院召开了春季特别活动。</p>
<p>在活动现场，苹果发布了：</p>
<ul>
<li>新闻服务 Apple News+</li>
<li>可以返现的 Apple Card</li>
<li>游戏服务 Apple Arcade</li>
<li>全新的 Apple TV App 服务</li>
<li>Apple TV+ 原创视频服务</li>
</ul>
<p>全部是软件和服务，没有新硬件的出现——这或许意味着，苹果正在寻找下一个十年的生长空间。</p>
<h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><h3 id="辞职环游中国的程序员小-K"><a href="#辞职环游中国的程序员小-K" class="headerlink" title="辞职环游中国的程序员小 K"></a><a href="https://talk.swift.gg/19">辞职环游中国的程序员小 K</a></h3><p>大概每个人都有过这种冲动，辞掉工作出去旅行，想去哪就去哪，再也不用赶需求修 bug 通宵加班。不过对大多数人来说，也就止步于“想想”，并不会付诸行动。但是我身边有一位朋友，真的做到了这件事：辞职一年环游中国！</p>
<p>这是最近几期ggtalk对我触动最大的一期，同样是做iOS开发的，为什么人家那么优秀🙃</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="996-ICU"><a href="#996-ICU" class="headerlink" title="996.ICU"></a><a href="https://github.com/996icu/996.ICU">996.ICU</a></h3><p>工作996，生病ICU。这段时间的“明星项目”，旨在反抗国内互联网公司形成的每周工作6天，每天工作早9点到晚9点的不良加班风气。截止到3月30号，仅四天时间star已经超11万。</p>
<h3 id="XVim2"><a href="#XVim2" class="headerlink" title="XVim2"></a><a href="https://github.com/XVimProject/XVim2">XVim2</a></h3><p>XVim2是一个用于Xcode的Vim插件。如果你是一个Vim党，你可以直接在Xcode代码编辑界面使用Vim的各种特性。我是最近开始接触，也在慢慢适应Vim的远离鼠标工作模式。另附送一个安装流程：</p>
<p>1、关闭Xcode<br>2、钥匙串-&gt;证书助理-&gt;证书创建<br>    名称：XcodeSigner<br>    身份类型：自签名根证书<br>    证书类型：代码签名<br>3、重新签署Xcode</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#需要等待一段时间</span></span><br><span class="line">sudo codesign -f -s XcodeSigner /Applications/Xcode.app</span><br></pre></td></tr></table></figure>
<p>4、按照官方步骤安装XVim2</p>
<h2 id="文摘"><a href="#文摘" class="headerlink" title="文摘"></a>文摘</h2><p>1、培养出在没人监督自己的时候也能高效工作的自我责任感非常重要。你也可以拔这称为是具有一种性格或者具有一种素质，它们都是同一个概念。如果缺乏对自己的责任感，你将永远依赖外部动机来驱使你努力工作。你容易折服于一根胡萝卜的诱惑，也容易屈从于一根大棒的威胁。<br>–《软技能：代码之外的生存指南》</p>
<p>2、最终，它成为我自己的知识体系中严重的短板。没有花时间去彻底掌握Lambda表达式的工作原理，结果浪费了大把的时间。最后当我下决心花时间去了解Lambda表达式的时候，我只花了几个小时阅读并实践，就领会了这一概念。<br>–《软技能：代码之外的生存指南》</p>
<p>3、回到从前，在我们刚开始一起生活的时候，我们就决定将我们收入的10%用于风险什一税–实际上我们把这部分收入捐给一家慈善机构，以帮助印度的孤儿。在我们第一次奉献什一税的第二周，我的妻子就得到了加薪，加薪的数额正好是我们当时奉献什一税的数额。我个人认为，我们的成功很大一部分就是因为这种对奉献的承诺，一直恪守到今天。<br>即使你不信仰任何宗教，我认为这一点也有某种符合逻辑的解释。我认为，你把钱看的越重，你就越难以在理财方面做出明智的、成功的投资选择。自愿把自己收入的固定数额奉献或者捐赠给慈善机构，可以改变你对金钱的看法。这一思想上的转变让你从金钱的所有者变成管理者。<br>–《软技能：代码之外的生存指南》</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>关于996ICU的一些看法</title>
    <url>/2019/03/31/996-ICU/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1059465-693ded7ab49b4da3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="996ICU"></p>
<p>这个项目在有7k多star的时候我就看到有人推了，当时也就是看看而已，了解了这个标识的意思，并没有点进去，更没有star。再之后随着越来越多的star和关注量，公众号、社区、论坛，但凡有程序员的角落，大家都在争先传播着“996ICU”这个概念，每一次转发、star都是对996这种工作制的无声抵抗。</p>
<a id="more"></a>
<p>刚才看了一眼star已经12w+，马上就要超过react，这足以说明忍受着996的程序员是多么大的一个群体。我这里不想跟大部分人一样，痛斥996，歌颂这种行为，我想说些不一样的东西。</p>
<p>从自己经历出发吧，2015年刚出来工作的时候是996，当时我并没有不情愿或者觉得累，因为我很清楚自己就是个菜鸟，996可以让自己有更多的时间用来学习东西，提升技术。这种工作节奏持续了大半年，这段时间的感受也是即充实又满足的。后来公司业绩好转，改成大小周，再几个月后又改成双休。当然最开始享受双休的那几天还是很爽的，后来就慢慢习惯了，996前后我的工作状态并没有什么变化。</p>
<p>再后来进了现在的公司，人事告诉我大小周，那时我已经保持了将近一年的双休节奏，稍微犹豫了那么一会，但考虑到公司不错的发展前景，我还是答应进来了。从双休切换到大小周之后，我才意识到双休是多么爽的一件事。。。真的深刻体会到得到了就习以为常，失去了才懂的珍惜的感受。</p>
<p>在我进来不到半年的时间，公司运行的大小周调整为975，因为晚上7点公司提供晚餐，其实开发这边都是吃完饭休息一会再继续回去工作，大约也是9点走，可以说是995。</p>
<p>得知双休之后，我的学习状态也高涨起来了，规划着两天的自由时间可以做很多事情了，睡懒觉、打游戏、学一些自己感兴趣的东西、跑步。然而实际情况却是开始双休之后的很长一段时间里，我完成度最高的是睡懒觉、打游戏，对于学习，健身基本没怎么执行。有那么几个周末我深深地体会到舒适区只要进入，是很难挣脱出来。周末的早上醒来就感觉自己是被封印在床上了一样，除了刷手机什么都不想做，哪都不想去，早上喝水，中午叫外卖，晚上再来一份外卖，一天结束了。</p>
<p>同时我又是一个反省意识很强的人，在虚度了一个周末之后心里就会非常自责。一个被荒废的周末还不如忙碌一天的工作给我带来的满足感，我甚至产生了想要回到996的状态，以此来约束自律性很差的自己。</p>
<p>再后来也就是最近一段时间，为了达成近两个月的OKR，我“如愿以偿”地又回到了996的模式。因为早有准备，多上一天班并没有让我感觉失去多少自由。公司也考虑大家劳逸结合的情况，搭建了台球，乒乓球，Switch游戏机这种娱乐措施。周六加班，也就是做一些修修补补的任务，中午吃完饭会打一会台球，乒乓球，或者玩一会农药，回来继续工作。有时候会感觉周六加班更像是换了一个地方过周末。</p>
<p>但其实我也不是完全接受996的，它解决了我的时间配比问题，但也会给我引起其他不便。比如我想和女朋友周末出去就近玩一下，北京以内还好，如果想出北京就会时间安排不过来。当然还有其他的不便，要知道休息两天和休息一天可是相差一倍呢。</p>
<p>那回到这个话题，996这个制度是否OK呢？</p>
<p>如果你自律性很强，有很多想法想要实现，也有较好的时间规划，那多一些自己的私人时间是再好不过的了，996对你的确不能让你发挥更大的作用。如果你自律性很差，也没考虑过多出来的时间用来干嘛（玩和睡除外），那我建议你可以先好好想想双休之后你会做什么，双休对你来说生活品质是提高了还是降低了。当然如果你认为自己就是不想加班，只想过平淡恬静的生活，上班对你来说就是为了赚钱，这种想法也没错。因为不是每个程序员都热爱着这份工作，能从中获取到乐趣的，那就换份轻松点的工作呗。我下面讨论的内容对这类人群也是不适用的，你们可以看到这就结束了。</p>
<p>说些不那么中听的话，如果你自律性差，公司的996相当于帮你加了一道屏障，这个时间段它帮你隔开舒适区，迫使你投入到工作中。而我公司也有不少，没有加班任务，时不时也会主动来公司加班的人。那最理想的情况其实就是，公司相信员工，不强制加班，大家想休息了，该休息了就休息，保证把工作效率提上去。员工呢，同时为自己和公司负责，没完成工作，学习新东西，就可以来公司主动加班。</p>
<p>之所以说他理想，是因为很多公司不信任员工，很多员工也没有那种对自己和公司强烈的责任感。所以互联网行业出现这么多的996不是单纯公司的问题，一些程序员也负有一定的责任。</p>
<p>再说一些特殊情况，如果是无良公司，不考虑员工效率问题，各种强制加班，搞996，那我也是坚决反对的。</p>
<p>996ICU项目里有提《劳动法》，标准工时一周最高为48小时，而996是72小时，超标不少；以及超时薪资应为平日工资的150%。这让我想到了大二寒假在电子厂打工的经历，标标准准的按照劳动法来的，基本都是按时薪算的。为什么同样是受劳务合同保护，不同的行业却有着不同的处理方式呢？</p>
<p>我认为一个重要的原因是，电子厂流水线上的那是标准的工人，计时或者计件，可以清清楚楚的搞清楚。而程序员呢，智力劳动，没法准确的衡量一个人的工作价值。你加班两小时，是因为水平问题还是别的原因，如果是自己原因的话，公司需要付钱吗，这个说不清的。所以是否要按照劳动法付给雇员加班费，存在很多不确定因素，这个是不现实也是不合理的。</p>
<p>我们很多人其实心理也明白，去给996ICU点一个star并不会让自己摆脱996现状。但我们还是那样做了，这其中有一点抗争精神，但抗争之后我希望大家能够更清楚的看待996这个问题。</p>
<p>我更希望996这个含义可以适当拓宽一点，包含我们工作及工作以外提升自我的时间。<br>如果公司要求996，分出一些时间做自己的事情，保证工作学习的82配比。如果不要求996，那就尽可能合理分配时间，保证每周有72小时是投入到这个行业里来的。在这段时间里你可以用来提升自我，或者是听我给你们吹水🙃</p>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#8|201902</title>
    <url>/2019/02/28/monthly_8/</url>
    <content><![CDATA[<p>这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。<br>欢迎推荐内容，可以前往<a href="https://github.com/zhangferry/iOSMonthlyReport">zhangferry/iOSMonthlyReport</a>提交issue。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190228110103.jpg" alt=""></p>
<a id="more"></a>
<h2 id="新闻一览"><a href="#新闻一览" class="headerlink" title="新闻一览"></a>新闻一览</h2><p><a href="https://research.hackerrank.com/developer-skills/2019">2019年开发人员技能报告</a></p>
<p>这是<a href="https://www.hackerrank.com/">HackerRank</a>平台通过对7万多名开发人员做的一项调查，问题从他们认为最有前途的技术到他们在工作中和面试过程中想要的是什么，甚至还有coding过程中听什么音乐最有帮助！一起看下吧。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="presentedviewcontroller和presentingViewController"><a href="#presentedviewcontroller和presentingViewController" class="headerlink" title="presentedviewcontroller和presentingViewController"></a>presentedviewcontroller和presentingViewController</h3><p>假设从A控制器通过present的方式跳转到了B控制器，那么 <code>A.presentedViewController</code> 就是B控制器；<br><code>B.presentingViewController</code> 就是A控制器。如果没有对应关系会返回<code>nil</code></p>
<h3 id="获取类名"><a href="#获取类名" class="headerlink" title="获取类名"></a>获取类名</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入实例对象object</span></span><br><span class="line"><span class="keyword">let</span> typeName = <span class="type">String</span>(describing: type(of: object))</span><br></pre></td></tr></table></figure>
<h3 id="隐藏NavigationBar导致手势返回失效"><a href="#隐藏NavigationBar导致手势返回失效" class="headerlink" title="隐藏NavigationBar导致手势返回失效"></a>隐藏NavigationBar导致手势返回失效</h3><p>当我们从一个A(NavigationController)界面通过push进入B界面，如果要隐藏B的NavigationBar，那么从B到A的返回手势也会被屏蔽掉。<br>如果需要加回来我们可以这么做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.给需要添加返回手势的ViewController增加UIGestureRecognizerDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.由当前ViewController接管pop手势</span></span><br><span class="line"><span class="keyword">self</span>.navigationController?.interactivePopGestureRecognizer?.delegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure>
<h3 id="关于-Decimal"><a href="#关于-Decimal" class="headerlink" title="关于 Decimal"></a>关于 Decimal</h3><p>官方对<code>Decimal</code>介绍就一句话</p>
<blockquote>
<p>A structure representing a base-10 number.</p>
</blockquote>
<p>表示以10为基数的数的结构体，就是十进制的表示方法。<br>它可以通过 <code>mantissa * 10 ^ exponent</code>的形式表示任意数值。<code>mantissa</code>(尾数)是最长38位的整数，<code>exponent</code>(指数)是 -128到127的整数。</p>
<p>你也可以把Decimal理解成跟Int, Float, Double一样的数据类型，那有了整形，浮点型数值还会出现Decimal这个类型？<br>可以看一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">stride</span>: <span class="type">Float</span> = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">var</span> sum: <span class="type">Float</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">100</span> &#123;</span><br><span class="line">    sum += <span class="built_in">stride</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sum)<span class="comment">//0.99999934</span></span><br></pre></td></tr></table></figure>
<p>sum的值不是1，这是因为精度的问题，那如果把Float换成Decimal就会完全等于1。</p>
<p><code>SKProduct</code>的<code>price</code>属性就是Decimal类型</p>
<h3 id="违反5-5条款被打回的经历"><a href="#违反5-5条款被打回的经历" class="headerlink" title="违反5.5条款被打回的经历"></a>违反5.5条款被打回的经历</h3><p>在一次有关内购项审核被打回的经历中，遇到了一个新问题，错误描述中提示违反了条款<code>5.5 Developer Code of Conduct</code>。<br>简单看下这一条</p>
<blockquote>
<p>Please treat everyone with respect, whether in your responses to App Store reviews, customer support requests, or when communicating with Apple, including your responses in Resolution Center. Do not engage in harassment of any kind, discriminatory practices, intimidation, bullying, and don’t encourage others to engage in any of the above.<br>Customer trust is the cornerstone of the App Store’s success. Apps should never prey on users or attempt to rip-off customers, trick them into making unwanted purchases, force them to share unnecessary data, raise prices in a tricky manner, charge for features or content that are not delivered, or engage in any other manipulative practices within or outside of the app.</p>
</blockquote>
<p>总结一下就是要尊重用户。</p>
<p>在联系过苹果审核客服之后，被告知是因为在引导过程中弹了两次订阅弹窗（一次订阅，一次freetrial）被拒的。但其实这个流程已经跑了大半年，一直没问题，这次却突然被揪出来了，有点莫名其妙。</p>
<p>可能审核人员认为，这种行为有诱导或者强迫用户付费的嫌疑。由此也可以看出审核人员对项目流程的管理越来越严格了。去掉一个步骤之后再次提交就过审了。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="Swift-ABI-稳定对我们到底意味着什么"><a href="#Swift-ABI-稳定对我们到底意味着什么" class="headerlink" title="Swift ABI 稳定对我们到底意味着什么"></a><a href="https://onevcat.com/2019/02/swift-abi/">Swift ABI 稳定对我们到底意味着什么</a></h3><p>Swift 社区最近最重大的新闻应该就是 ABI 稳定了。这个话题虽然已经讨论了有一阵子了，但随着 Xcode 10.2 beta 的迭代和 Swift 5 的 release 被提上日程，最终 Swift ABI 稳定能做到什么程度，我们开发者能做些什么，需要做些什么，就变成了一个重要的话题。</p>
<p>一起来看下使用 Swift 5 会对我们的项目有什么影响以及怎么处理。</p>
<h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a><a href="https://juejin.im/post/5c73af896fb9a049cb1963d4">Void</a></h3><p>SwiftGG翻译组翻译的Mattt一篇介绍Void的文章。<br><code>Void</code>是什么，它和<code>nil</code>有什么区别，这个我们经常用但不一定真的理解的东西，一起通过这篇文章看下吧。</p>
<h3 id="love2-io"><a href="#love2-io" class="headerlink" title="love2.io"></a><a href="https://love2.io/@tzivanmoe/doc/a-programmer-prepares/README.md">love2.io</a></h3><p>程序员的自我修养，作为一个合格的程序员需要具备哪些知识呢？</p>
<p>数据结构、算法、代码架构、项目管理工具、网络知识等？可能还不够，还需要懂点设计、学着当一个合格的PM、学会团队合作、学会学习、提升效率等等；够了吗？你还需要了解一下创业流程、关注自己的身体健康。。。</p>
<p>太多了，不列举了，因为这里都有。</p>
<h3 id="为什么数字下标要从-0-开始而不是-1？"><a href="#为什么数字下标要从-0-开始而不是-1？" class="headerlink" title="为什么数字下标要从 0 开始而不是 1？"></a><a href="http://czheo.github.io/2019/02/24/why-numbering-should-start-at-zero/">为什么数字下标要从 0 开始而不是 1？</a></h3><p>大家都知道数字下标是从0开始的，那为什么是0而不是1呢？说实话在看这篇文章之前我也不能很清楚的说明白，如果你也有这种疑惑就看看这个文章吧。</p>
<h3 id="什么叫有知识"><a href="#什么叫有知识" class="headerlink" title="什么叫有知识"></a><a href="https://mp.weixin.qq.com/s/P87aDQ5h5qfy27bc77fOUg">什么叫有知识</a></h3><p>选自罗胖60秒：<br>1、话说什么叫做有知识？最近我看万维钢老师有一个有趣的定义。他说，考试得了高分，不叫有知识。茶余饭后能高谈阔论，这也不叫有知识。</p>
<p>你发现没有，这些场合下，知识虽然有用，但是这些知识都不太牵扯到具体的得失，所以只是智力游戏。</p>
<p>2、那什么才叫有知识呢？万维钢老师说，只有当局势不明朗，没有人告诉你该怎么办，而错误的判断又会导致一些不良后果，这个时候，如果你因为有知识而敢于拿一个主意，你才算是真有知识。</p>
<p>3、请注意，这不是在说，实用的知识才是知识，而是在说，只有当知识能够帮助你做实际决策的时候，它才是你的知识。</p>
<p>4、这种决策当然可大可小，大到你选择什么样的职业，选择听医生的哪个建议；小到帮你选择看哪一部电影，或者是为孩子挑选买哪一本书。这都是具体的决策。</p>
<h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><p><a href="https://www.gcores.com/radios/106545">苏俄科幻简史：直指星海的冒险时代</a></p>
<p>最近在机核（gamecores）上听到的一段讲述苏俄科幻的音频，可以当故事听，也可以当一段历史去听，非常有意思。</p>
<p>对于很多人而言，苏俄的科幻文学、电影乃至游戏都是一个比较陌生的概念。事实上从沙俄末期到苏联再到今天的俄罗斯，来自极北之地的斯拉夫人民也曾在科幻这个领域上走了很远很远，取得了惊人的成绩。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="DoraemonKit"><a href="#DoraemonKit" class="headerlink" title="DoraemonKit"></a><a href="https://github.com/didi/DoraemonKit">DoraemonKit</a></h3><p>由滴滴团队开源，中文名“哆啦A梦”。</p>
<p>DoraemonKit 是一个功能集合面板，能够让每一个 App 快速接入一些常用的或者你没有实现的一些辅助开发工具、测试效率工具、视觉辅助工具，而且能够完美在 Doraemon 面板中接入你已经实现的与业务紧密耦合的一些非通有的辅助工具，功能强大，接入方便，便于扩展。</p>
<h3 id="git-history"><a href="#git-history" class="headerlink" title="git-history"></a><a href="https://github.com/pomber/git-history">git-history</a></h3><p>这个项目可以让你在浏览器动态地查看Github库上代码的变动历史。</p>
<p>使用方法非常简单：<br>1、在对应的文件url中把<code>github.com</code>替换成<code>github.githistory.xyz</code><br>2、没有第二步</p>
<h3 id="resume-github-com"><a href="#resume-github-com" class="headerlink" title="resume.github.com"></a><a href="https://github.com/resume/resume.github.com">resume.github.com</a></h3><p>这个库可以通过你仓库的活跃事件来生成一份在线简历。使用很简单，直接访问以下网址：<a href="https://resume.github.io/?yourusername">https://resume.github.io/?yourusername</a></p>
<p>需要将<code>yourusername</code>替换成你的用户名，别忘了那个<code>?</code></p>
<h3 id="iOS-Developer-Roadmap"><a href="#iOS-Developer-Roadmap" class="headerlink" title="iOS-Developer-Roadmap"></a><a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap">iOS-Developer-Roadmap</a></h3><p>一名iOS开发人员需要具备哪些知识呢？这个库做了比较详尽的总结，以技能树的形式对iOS开发所需知识点，知识面做了整理，我们可以作为参照，查看自己有哪些缺失。</p>
<ul>
<li><a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap/blob/master/RoadmapProject/Script/Generated/ROADMAP.md">文本版本</a></li>
<li>图片版本(<a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap/blob/master/RoadmapProject/Script/Generated/ESSENTIALROADMAP.png">基础版本</a>, <a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap/blob/master/RoadmapProject/Script/Generated/ROADMAP.png">完整版本</a>)</li>
</ul>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>关于消息摘要及对应的Swift实现</title>
    <url>/2019/02/27/digest_introduction/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/20190227163346.jpg" alt=""><br>开发过程中我们经常会遇到对数据进行一些类似<code>MD5</code>，<code>SHA-256</code>等的处理，那处理的作用是什么以及为什么要这么做，就是今天要讨论的内容。如果你对这些算法的概念已经很熟悉，那就不用继续往下看了，如果你感觉生疏，或者并不能说清楚他们的作用，那就跟着我一起回顾一下吧。</p>
<a id="more"></a>
<h2 id="从MD5说起"><a href="#从MD5说起" class="headerlink" title="从MD5说起"></a>从MD5说起</h2><p>我门从最常见的<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>说起。下面是维基百科对MD5的定义：</p>
<blockquote>
<p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。</p>
</blockquote>
<p>MD5的概念中出现了两个名词：<strong>信息摘要算法</strong> + <strong>密码散列函数</strong>。<br>我们再分别来看这两个概念的含义。</p>
<h3 id="信息摘要算法"><a href="#信息摘要算法" class="headerlink" title="信息摘要算法"></a>信息摘要算法</h3><p><a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/3286770?fromtitle=%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95&fromid=12011257">消息摘要算法</a>消息摘要是把任意长度的输入揉和而产生长度固定的伪随机输入的算法。</p>
<p>它具有以下特点：</p>
<ul>
<li><p>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，一般认为，摘要的最终输出越长，该摘要算法就越安全。变长输入，定长输出。</p>
</li>
<li><p>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。</p>
</li>
<li><p>消息摘要函数是单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。</p>
</li>
<li><p>好的摘要算法，没有人能从中找到“碰撞”，即无法找到两条不同的消息，使它们的摘要相同。</p>
</li>
</ul>
<p>从理论上来说，不管使用什么样的摘要算法，必然存在2个不同的消息，对应同样的摘要。因为输入是一个无穷集合，而输出是一个有限集合。但是实际上，很难或者说根本不可能人为的造出具有同样摘要的2个不同消息。</p>
<h3 id="密码散列函数："><a href="#密码散列函数：" class="headerlink" title="密码散列函数："></a>密码散列函数：</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数（Cryptographic hash function）</a>，又译为加密散列函数，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的数据是什么。</p>
<h3 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h3><p>这里比较重要的就是理解信息摘要，它概念就是把一段数据压缩成固定长度的数据，但是我们不能通过压缩后的数据反推原始数据。</p>
<p>有一种应用场景比较能说明问题：<br>我们在登录的时候，对用户密码进行MD5计算之后再传到服务器，之后数据库显示的用户信息就是MD5之后的16字节字符串。管理员即使能访问用户数据库但他并不能由MD5处理之后的数据得知原始密码。<br>而客户端这边却可以在输入密码之后，进行MD5计算然后与服务器密码进行比较。</p>
<h2 id="SHA家族"><a href="#SHA家族" class="headerlink" title="SHA家族"></a>SHA家族</h2><p><a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">安全散列算法</a>（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。</p>
<p>SHA的出现就是解决MD5不安全的问题，它是一种比MD5更安全的密码散列函数。</p>
<p>SHA家族的算法，由美国国家安全局（NSA）所设计，并由美国国家标准与技术研究院（NIST）发布，是美国的政府标准，其分别是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
<th>应用范围</th>
<th>发布时间</th>
</tr>
</thead>
<tbody><tr>
<td>SHA-0</td>
<td>SHA-1前身</td>
<td>-</td>
<td>1993</td>
</tr>
<tr>
<td>SHA-1</td>
<td>曾被视为MD5的后继者，但SHA-1的安全性在2000年以后已经不被大多数的加密场景所接受。</td>
<td>广泛</td>
<td>1995</td>
</tr>
<tr>
<td>SHA-2</td>
<td>包括SHA-224/SHA-256/SHA-384/SHA-512，目前并未被破解</td>
<td>广泛</td>
<td>2001</td>
</tr>
<tr>
<td>SHA-3</td>
<td>比SHA-2更安全的散列函数，并无替代SHA-2的计划</td>
<td>较小</td>
<td>2015</td>
</tr>
</tbody></table>
<h2 id="散列函数的安全性"><a href="#散列函数的安全性" class="headerlink" title="散列函数的安全性"></a>散列函数的安全性</h2><p>上面说到了MD5是不安全的，不安全意味着可以找到MD5的“碰撞”，就是两个文件可以产生相同的“指纹”。这意味着，当你在网络上使用电子签名签署一份合同后，还可能找到另外一份具有相同签名但内容迥异的合同，这样两份合同的真伪性便无从辨别。</p>
<p>2004年8月17日，在CRYPTO 2004的Rump会议上，王小云，冯登国、来学嘉，和于红波宣布了攻击MD5、SHA-0 和其他杂凑函数的初步结果。他们攻击SHA-0的计算复杂度是2的40次方，这意味着他们的攻击成果比Joux还有其他人所做的更好。</p>
<p>2005年二月，王小云和殷益群、于红波再度发表了对SHA-0破密的算法，可在2的39次方的计算复杂度内就找到碰撞。</p>
<p>2009年，中国科学院的谢涛和冯登国仅用了2的20.96次方的碰撞算法复杂度，破解了MD5的碰撞抵抗，该攻击在普通计算机上运行只需要数秒钟。</p>
<p>2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1。</p>
<h2 id="摘要的Swift实现"><a href="#摘要的Swift实现" class="headerlink" title="摘要的Swift实现"></a>摘要的Swift实现</h2><p>Swift有一个比较成熟的专门处理摘要，加密等安全相关的框架<a href="https://github.com/krzyzanowskim/CryptoSwift">CryptoSwift</a>。</p>
<p>以下是Swift对摘要算法的原生实现，需要引入<code>CommonCrypto</code>框架，这个已经内置到Xcode里面了，列出了对String和Data的摘要扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CommonCrypto</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CryptoAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MD5</span>, <span class="type">SHA1</span>, <span class="type">SHA224</span>, <span class="type">SHA256</span>, <span class="type">SHA384</span>, <span class="type">SHA512</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> digestLength: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">Int32</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">MD5</span>:      result = <span class="type">CC_MD5_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA1</span>:     result = <span class="type">CC_SHA1_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA224</span>:   result = <span class="type">CC_SHA224_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA256</span>:   result = <span class="type">CC_SHA256_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA384</span>:   result = <span class="type">CC_SHA384_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA512</span>:   result = <span class="type">CC_SHA512_DIGEST_LENGTH</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> md5:    <span class="type">String</span> &#123; <span class="keyword">return</span> digest(string: <span class="keyword">self</span>, algorithm: .<span class="type">MD5</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha1:   <span class="type">String</span> &#123; <span class="keyword">return</span> digest(string: <span class="keyword">self</span>, algorithm: .<span class="type">SHA1</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha224: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(string: <span class="keyword">self</span>, algorithm: .<span class="type">SHA224</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha256: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(string: <span class="keyword">self</span>, algorithm: .<span class="type">SHA256</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha384: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(string: <span class="keyword">self</span>, algorithm: .<span class="type">SHA384</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha512: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(string: <span class="keyword">self</span>, algorithm: .<span class="type">SHA512</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">digest</span><span class="params">(string: String, algorithm: CryptoAlgorithm)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">CUnsignedChar</span>]</span><br><span class="line">        <span class="keyword">let</span> digestLength = <span class="type">Int</span>(algorithm.digestLength)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cdata = string.cString(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8) &#123;</span><br><span class="line">            result = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: digestLength)</span><br><span class="line">            <span class="keyword">switch</span> algorithm &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">MD5</span>:      <span class="type">CC_MD5</span>(cdata, <span class="type">CC_LONG</span>(cdata.<span class="built_in">count</span>-<span class="number">1</span>), &amp;result)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">SHA1</span>:     <span class="type">CC_SHA1</span>(cdata, <span class="type">CC_LONG</span>(cdata.<span class="built_in">count</span>-<span class="number">1</span>), &amp;result)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">SHA224</span>:   <span class="type">CC_SHA224</span>(cdata, <span class="type">CC_LONG</span>(cdata.<span class="built_in">count</span>-<span class="number">1</span>), &amp;result)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">SHA256</span>:   <span class="type">CC_SHA256</span>(cdata, <span class="type">CC_LONG</span>(cdata.<span class="built_in">count</span>-<span class="number">1</span>), &amp;result)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">SHA384</span>:   <span class="type">CC_SHA384</span>(cdata, <span class="type">CC_LONG</span>(cdata.<span class="built_in">count</span>-<span class="number">1</span>), &amp;result)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">SHA512</span>:   <span class="type">CC_SHA512</span>(cdata, <span class="type">CC_LONG</span>(cdata.<span class="built_in">count</span>-<span class="number">1</span>), &amp;result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Nil returned when processing input strings as UTF8"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>..&lt;digestLength).<span class="built_in">reduce</span>(<span class="string">""</span>) &#123; $<span class="number">0</span> + <span class="type">String</span>(format: <span class="string">"%02hhx"</span>, result[$<span class="number">1</span>])&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> md5:    <span class="type">String</span> &#123; <span class="keyword">return</span> digest(data: <span class="keyword">self</span>, algorithm: .<span class="type">MD5</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha1:   <span class="type">String</span> &#123; <span class="keyword">return</span> digest(data: <span class="keyword">self</span>, algorithm: .<span class="type">SHA1</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha224: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(data: <span class="keyword">self</span>, algorithm: .<span class="type">SHA224</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha256: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(data: <span class="keyword">self</span>, algorithm: .<span class="type">SHA256</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha384: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(data: <span class="keyword">self</span>, algorithm: .<span class="type">SHA384</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> sha512: <span class="type">String</span> &#123; <span class="keyword">return</span> digest(data: <span class="keyword">self</span>, algorithm: .<span class="type">SHA512</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">digest</span><span class="params">(data: Data, algorithm: CryptoAlgorithm)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">CUnsignedChar</span>]</span><br><span class="line">        <span class="keyword">let</span> digestLength = <span class="type">Int</span>(algorithm.digestLength)</span><br><span class="line">        <span class="keyword">let</span> pdata = (data <span class="keyword">as</span> <span class="type">NSData</span>).bytes</span><br><span class="line">        result = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: digestLength)</span><br><span class="line">        <span class="keyword">switch</span> algorithm &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">MD5</span>:      <span class="type">CC_MD5</span>(pdata, <span class="type">CC_LONG</span>(data.<span class="built_in">count</span>), &amp;result)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA1</span>:     <span class="type">CC_SHA1</span>(pdata, <span class="type">CC_LONG</span>(data.<span class="built_in">count</span>), &amp;result)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA224</span>:   <span class="type">CC_SHA224</span>(pdata, <span class="type">CC_LONG</span>(data.<span class="built_in">count</span>), &amp;result)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA256</span>:   <span class="type">CC_SHA256</span>(pdata, <span class="type">CC_LONG</span>(data.<span class="built_in">count</span>), &amp;result)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA384</span>:   <span class="type">CC_SHA384</span>(pdata, <span class="type">CC_LONG</span>(data.<span class="built_in">count</span>), &amp;result)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA512</span>:   <span class="type">CC_SHA512</span>(pdata, <span class="type">CC_LONG</span>(data.<span class="built_in">count</span>), &amp;result)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>..&lt;digestLength).<span class="built_in">reduce</span>(<span class="string">""</span>) &#123; $<span class="number">0</span> + <span class="type">String</span>(format: <span class="string">"%02hhx"</span>, result[$<span class="number">1</span>])&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>艰难的图床优化方案(MWeb+PicGo+Github)</title>
    <url>/2019/02/20/figure_bed_github/</url>
    <content><![CDATA[<h2 id="博客写作优化"><a href="#博客写作优化" class="headerlink" title="博客写作优化"></a>博客写作优化</h2><p>写博客就肯定会遇到插入图片的情况，我之前的做法是先在<a href="https://boostnote.io/">Boostnote</a>这种Markdown编辑器里面写个草稿，如果有图片就附上图片，然后再粘到简书的web端。当然图片也需要另拖，会生成一个简书的图片链接，相当于把简书作为图床，然后我再把简书排好版的文章发布到自己的博客。。。</p>
<a id="more"></a>
<p>当然是很麻烦的方式，这种写法持续了大半年之后，开始寻找更高效的写博客的方式。首先客户端，最终选了MWeb。然后是要解决麻烦的图床问题，因为MWeb内嵌了七牛云图传服务，所以申请了七牛云账号，用了一段时间感觉真是如丝般顺滑。</p>
<h2 id="图床历险记"><a href="#图床历险记" class="headerlink" title="图床历险记"></a>图床历险记</h2><p>直到我收到了这个：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/15504845205127.jpg" alt=""></p>
<p>在七牛云上申请的只是测试域名服务，只有一个月的有效期。如果想继续使用就需要绑定自己的域名，而且这个域名还需要备案。</p>
<p>于是我在腾讯云上注册了两年的<a href="http://www.zhangferry.com">zhangferry.com</a>这个域名。填写资料时，我看到系统提示域名要进行备案，备案过程中又发现，要有绑定腾讯云服务才能进行备案。？？我只是要域名并不需要云服务啊。隐约感觉好像被下套了，需要解决的问题一个套一个。我还怀着侥幸的心理看了下腾讯云服务的价格，用不起用不起。。。<br>看到提示说如果不备案域名，三个月后会被回收，有点慌。询问客服之后得知，服务器在国内且没有备案的情况下才会被回收，因为我的博客是搭在Github上的，所以可以不备案，松了一口气，域名保住了。但是，不备案七牛云又不干了，what f。。。</p>
<p>纠结一段时间之后我只能放弃七牛云，寻找其他的图床服务，知乎上有一个总结比较全的文章<a href="https://zhuanlan.zhihu.com/p/35270383">盘点一下免费好用的图床</a>。原来是有很多免费服务的，感觉找到了解决方案。但是，又是一个但是，图床这个东西，免费就意味着不稳定，万一哪天挂了，图片就都丢了。最后文末有总结：<strong>如果打算长期稳定使用请优先选择又拍云或者七牛云，如果是存储并不重要的图片可以使用免费不限大小的SM.MS图床</strong>。</p>
<p>再结合我对图床的需求：免费+稳定。<a href="https://sm.ms/">SM.MS</a>好像是最接近的方案了，虽然SM.MS知名度不算低，但是我还是有点担心它的稳定性。</p>
<p>再继续找，找到了这个<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>，一个图床管理工具，顺着PicGo（v2.0.3）我找到了Github作为图床这一方案。Github，对啊，我直接就确认了这种方案。虽然有人说Github图片国内访问会慢一些，但是它肯定能保证数据的稳定性啊。这样图床工具和图床服务都找好了，喜大普奔！</p>
<h2 id="Github图床配置"><a href="#Github图床配置" class="headerlink" title="Github图床配置"></a>Github图床配置</h2><p>说了很多废话，终于到了这个理想图床的配置阶段了，比较简单。</p>
<h3 id="1、建一个仓库"><a href="#1、建一个仓库" class="headerlink" title="1、建一个仓库"></a>1、建一个仓库</h3><p>用于存需要上传的图片。这个仓库最好是public的，因为private的仓库，图片链接会带token，这个token又存在过期的问题。</p>
<h3 id="2、获取授权token"><a href="#2、获取授权token" class="headerlink" title="2、获取授权token"></a>2、获取授权token</h3><p>在Github的<a href="https://github.com/settings/tokens">Developer setting</a>界面生一个token。记得保存，因为它只会显示一次。<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/02060BA7-54CC-448B-ABFE-ADFE6E72FF1B.png" alt=""></p>
<h3 id="3、配置PicGo"><a href="#3、配置PicGo" class="headerlink" title="3、配置PicGo"></a>3、配置PicGo</h3><p>根据图示：<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/15504954147366.jpg" alt=""></p>
<h3 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h3><p>使用也很方便，PicGo有两种方式：<br><strong>屏幕截图</strong><br>截取图片之后，图片会出现在PicGo的待上传列表里面。我们手动点一下会触发上传，上传成功之后，剪贴板会有对应markdown格式的图片文本，直接粘贴可以使用。<br><strong>固定图片</strong><br>我们需要将需要使用的图片拖到PicGo的客户端内手动上传，上传成功之后，会自动复制成markdown文本，可以直接粘贴使用。</p>
<p>终于搞定了，撒花！</p>
]]></content>
      <tags>
        <tag>博客</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#7|201901</title>
    <url>/2019/01/31/monthly_7/</url>
    <content><![CDATA[<p>这里记录过去一个月，我看到的值得分享的内容，包含但不限于iOS知识，每个月的最后一天发布。<br>欢迎推荐内容，可以前往<a href="https://github.com/zhangferry/iOSMonthlyReport">zhangferry/iOSMonthlyReport</a>提交issue。</p>
<p>另外，马上就要过年了，提前祝大家春节快乐！<br><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/freestocks-org-506237-unsplash.jpg" alt=""></p>
<a id="more"></a>
<h2 id="新闻一览"><a href="#新闻一览" class="headerlink" title="新闻一览"></a>新闻一览</h2><h3 id="Github宣布私有库免费"><a href="#Github宣布私有库免费" class="headerlink" title="Github宣布私有库免费"></a><a href="https://github.blog/2019-01-07-new-year-new-github/">Github宣布私有库免费</a></h3><p>Github宣布提供免费且不限量的私有仓库服务，如果协作者超过3个仍需购买付费服务。<br>喜大普奔啊，得知消息之后，我赶紧就建立一个私有仓库，放一些不想让你们看到的东西🙃</p>
<h3 id="Swift-5-Release-Notes-for-Xcode-10-2-beta"><a href="#Swift-5-Release-Notes-for-Xcode-10-2-beta" class="headerlink" title="Swift 5 Release Notes for Xcode 10.2 beta"></a><a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_10_2_beta_release_notes/swift_5_release_notes_for_xcode_10_2_beta?language=objc">Swift 5 Release Notes for Xcode 10.2 beta</a></h3><p>Swift5 版本终于发布了，最低可以使用Xcode10.2beta 查看。Swift5 带来了ABI稳定，届时系统将自带Swift动态库，由Swift编译的项目将不会自动把运行库打到包里。</p>
<p>Swift5 具体还有哪些特性，可以参考知识小集团队的<a href="https://juejin.im/post/5c4b3e91e51d452c8e6d6bcc">翻译版本</a></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Dictionary的merge操作"><a href="#Dictionary的merge操作" class="headerlink" title="Dictionary的merge操作"></a>Dictionary的merge操作</h3><p><code>Dictionary</code>的merge可能平常用的不多，我是在一次bug排查的过程中，发现自己对merge操作理解也有些偏差。这里做个简单梳理。<br>看其中一种情况：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dictionary = [<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keeping existing value for key "a":</span></span><br><span class="line">dictionary.merge([<span class="string">"a"</span>: <span class="number">3</span>, <span class="string">"c"</span>: <span class="number">4</span>]) &#123; (current, <span class="number">_</span>) <span class="keyword">in</span> current &#125;</span><br><span class="line"><span class="comment">// ["b": 2, "a": 1, "c": 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Taking the new value for key "a":</span></span><br><span class="line">dictionary.merge([<span class="string">"a"</span>: <span class="number">5</span>, <span class="string">"d"</span>: <span class="number">6</span>]) &#123; (<span class="number">_</span>, new) <span class="keyword">in</span> new &#125;</span><br><span class="line"><span class="comment">// ["b": 2, "a": 5, "c": 4, "d": 6]</span></span><br></pre></td></tr></table></figure>
<p>注意尾随闭包中有两个参数，返回第一个参数，表示如果merge操作有重复key值，将保留merge前的value不变。如果闭包返回第二个参数，如果merge有重复key，将更新至最新值。<br><code>Dictionary</code>向关的merge函数一共有四个，使用类似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">merge</span>&lt;S&gt;<span class="params">(<span class="number">_</span> other: S, uniquingKeysWith combine: <span class="params">([Key : Value].Value, [Key : Value].Value)</span></span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Value</span>) <span class="keyword">rethrows</span> <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Sequence</span>, <span class="type">S</span>.<span class="type">Element</span> == (<span class="type">Key</span>, <span class="type">Value</span>)</span><br><span class="line"><span class="comment">//上面示例对应方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(<span class="number">_</span> other: [[Key : Value].Key : [Key : Value].Value], uniquingKeysWith combine: <span class="params">([Key : Value].Value, [Key : Value].Value)</span></span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Value</span>) <span class="keyword">rethrows</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">merging</span>&lt;S&gt;<span class="params">(<span class="number">_</span> other: S, uniquingKeysWith combine: <span class="params">([Key : Value].Value, [Key : Value].Value)</span></span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Value</span>) <span class="keyword">rethrows</span> -&gt; [[<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Key</span> : [<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Value</span>] <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Sequence</span>, <span class="type">S</span>.<span class="type">Element</span> == (<span class="type">Key</span>, <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">merging</span><span class="params">(<span class="number">_</span> other: [[Key : Value].Key : [Key : Value].Value], uniquingKeysWith combine: <span class="params">([Key : Value].Value, [Key : Value].Value)</span></span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Value</span>) <span class="keyword">rethrows</span> -&gt; [[<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Key</span> : [<span class="type">Key</span> : <span class="type">Value</span>].<span class="type">Value</span>]</span><br></pre></td></tr></table></figure>
<h3 id="一些Git操作"><a href="#一些Git操作" class="headerlink" title="一些Git操作"></a>一些Git操作</h3><p><strong>删除子目录git</strong><br>当一个含git的目录包含了其他含git目录时，外部git是不能将内部git纳入版本管理的。有一种解决方案是，移除内部的git仓库。<br>1、删除内部git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 需要移除的git目录</span><br><span class="line">rm -rf .git  # 或者显示隐藏目录手动删除.git文件夹</span><br></pre></td></tr></table></figure>
<p>此时虽然已经删除了<code>.git</code>但是原目录还存在缓存，无法添加到外部git中。<br>2、删除缓存内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -r --cached next</span><br></pre></td></tr></table></figure>
<p><strong>git pull强制覆盖本地文件</strong><br>当我们需要将某一分支，跟远程对应分支保持一致时，可以做如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git reset --hard origin/branch_name</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p><strong>fatal:refusing to merge unrelated histories</strong><br>当我们为一个项目关联了一个远程仓库，执行pull的操作时出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; origin&#x2F;master</span><br><span class="line">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure>
<p>这是因为git从2.9.0版本开始，预设行为不允许合并没有共同祖先的分支。如果你非要合并，需要加上<code>--allow-unrelated-histories</code>参数才行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>
<h3 id="几个提高效率的快捷键"><a href="#几个提高效率的快捷键" class="headerlink" title="几个提高效率的快捷键"></a>几个提高效率的快捷键</h3><p>最近在熟练使用了几个快捷键后，明显感觉开发效率提高了不少，这里总结了几个常用但不是非常常用的快捷键（Command + C 和 Command V等）。另外</p>
<ul>
<li>Command（或 Cmd）⌘</li>
<li>Shift ⇧</li>
<li>Option（或 Alt）⌥</li>
<li>Control（或 Ctrl）⌃</li>
<li>Power 电源键</li>
</ul>
<p><strong>Xcode</strong><br>Command + Shift + J 文件目录指向当前文件<br>Command + Shift + O 文件、对象搜索<br>Command + Shift + F 全局搜索<br>Command + shift + , 编辑 scheme<br>Command + Control + Left/Right 浏览历史切换<br>Command + Option + Left/Right 折叠、展开当前代码段<br>Command + Option + C 显示Commit界面<br><strong>系统操作</strong><br>Command + Option + Power 睡眠状态<br>Power 1.5s睡眠状态<br>Command + Control + Power 强制Mac重启</p>
<p><strong>适用其他程序</strong><br>Command + , 打开偏好设置<br>Command + W 关闭最前面的窗口<br>Command + Option + W 关闭应用所有窗口<br>Command + Q 推出应用<br>Command + M 最小化<br>Command + Shift + [/] 左右切换应用tab</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="未来世界的幸存者"><a href="#未来世界的幸存者" class="headerlink" title="未来世界的幸存者"></a><a href="http://survivor.ruanyifeng.com/index.html">未来世界的幸存者</a></h3><p>今年市场经济不景气，很多互联网公司经历“裁员潮”，其实不光是换联网行业，其他行业也面临同样的问题。那怎么提高自己的核心竞争力，是每一个从事互联网行业的人都应该考虑的。我们不应该只满足于日常开发，要找准自己的定位，提早做职业规划。另外不断尝试拓展自己的知识面，增加自己的影响力，这样才能让自己在不断变化的市场中立于不败之地。</p>
<p>除了阮老师的这本书，还推荐<br>卓同学的<a href="https://juejin.im/post/5c45c999e51d4551cd71f4e2">iOS 2019 隆中对</a></p>
<h3 id="什么是真正的程序员"><a href="#什么是真正的程序员" class="headerlink" title="什么是真正的程序员"></a><a href="https://www.cnblogs.com/xueweihan/p/5220513.html">什么是真正的程序员</a></h3><p>作者仿照《小王子》中的情节，通过小printf遇见的不同类型的程序员，最后悟出什么才是真正的程序员！<br>有两个概念比较有意思：</p>
<ul>
<li>达克效应：能力强的人总是低估自己，能力弱的人总是高估自己。</li>
<li>能够为人们解决真正需要解决的问题的程序员，才是真正的程序员</li>
</ul>
<h3 id="Language-Server-Protocol"><a href="#Language-Server-Protocol" class="headerlink" title="Language Server Protocol"></a><a href="https://swift.gg/2019/01/15/nshipster-language-server-protocol/">Language Server Protocol</a></h3><p>来自SwiftGG翻译组的一篇文章。<br>苹果公司 在 <a href="https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024">Swift.org</a> 论坛上宣布，正在着手为 Swift 和 C 语言支持 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>（语言服务器协议，LSP）。<br>那这意味着什么呢？这可能是苹果自 2014 年将 Swift 作为开源软件发布以来，为 Swift 做出的最重要的决定。它意味着我们可以不必使用Xcode去开发Swift项目，而是可以选择像是Visual Studio, Atom这些IDE。Swift将变成一种更加通用的变成语言。</p>
<h3 id="Hashable-Hasher"><a href="#Hashable-Hasher" class="headerlink" title="Hashable / Hasher"></a><a href="https://nshipster.cn/hashable/">Hashable / Hasher</a></h3><p>Hash是程序开发过程中很重要的一个概念，它可以让我们查找集合特定元素的时间复杂度由O(n)降低到O(1)。<br>这篇文章介绍了Swift中关于哈希的实现，哈希冲突的改变，以及Swift4.1之后关于自动化实现<code>Equatable</code>的相关介绍。</p>
<h3 id="Table-View-太複雜？利用-MVVM-和-Protocol-就可以為它重構瘦身！"><a href="#Table-View-太複雜？利用-MVVM-和-Protocol-就可以為它重構瘦身！" class="headerlink" title="Table View 太複雜？利用 MVVM 和 Protocol 就可以為它重構瘦身！"></a><a href="https://www.appcoda.com.tw/tableview-mvvm/">Table View 太複雜？利用 MVVM 和 Protocol 就可以為它重構瘦身！</a></h3><p>TableView是我们常用的系统部件，随着业务逻辑的不断迭代它内部的逻辑可能会越来越复杂，代码量也越来越多，如果不能很好的组织逻辑架构，这里会变得非常臃肿。<br>作者利用<code>MVVM pattern</code>，加上一点<code>Protocol</code>技巧，来简化dataSource的工作，把UI和逻辑解耦合，并且最大化这个tableView模组的扩展性。</p>
<h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><p>临近年关，可能很多人会考虑年后换工作的情况，最近几期的ggtalk也在讨论跳槽这个大家比较关注的话题，希望大家收听之后能够有所收获：<br><a href="https://talk.swift.gg/12">狭义跳槽论：面试官，大厂新人和准备起跳的某 C</a><br><a href="https://talk.swift.gg/13">广义跳槽论：简洁明了的方法论</a><br>附带之前的几期关于升职加薪的节目：<br><a href="https://talk.swift.gg/0">聊聊程序员的升职加薪（上）</a><br><a href="https://talk.swift.gg/4">聊聊程序员的升职加薪（下）</a></p>
<h3 id="程序员的春节趣事"><a href="#程序员的春节趣事" class="headerlink" title="程序员的春节趣事"></a><a href="https://talk.swift.gg/14">程序员的春节趣事</a></h3><p>今天上班路上听了这期节目，全程非常的欢快。我是今天晚上回家的火车，那些相似的春节趣事我也马上要经历一次了，是需要提前准备下怎么应对了🙃。</p>
<p>以下是官方内容介绍：<br>快过年了，估计大家也没心情工作学习，准备进入放假状态。严肃的话题放到年后，这期我们请到了袁滚滚、张思琦和老朋友莲叔，围绕着春节轻松愉快的聊一期。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>本篇GitHub模块，介绍几个Git和GitHub相关的项目。</p>
<h3 id="Git中文教程"><a href="#Git中文教程" class="headerlink" title="Git中文教程"></a><a href="https://github.com/geeeeeeeeek/git-recipes">Git中文教程</a></h3><p>来自<a href="https://github.com/geeeeeeeeek">geeeeeeeeek</a>的高质量Git中文教程，在GitHub已经获得了1w+的start。对git操作还有疑问的同学可以借助这份教程，完整的梳理一下git相关的知识，或者扫一下git盲区。 </p>
<h3 id="Git的奇技淫巧"><a href="#Git的奇技淫巧" class="headerlink" title="Git的奇技淫巧"></a><a href="https://github.com/521xueweihan/git-tips">Git的奇技淫巧</a></h3><p>我们在使用git的时候，有时候会被一些具体的问题难住，这篇文章从具体操作入手，介绍一些我们知道但不一定都用过的git指令。<br>等等，我也想写一份我自己的Git奇淫技巧了，因为git这个东西是真的庞大。</p>
<h3 id="HelloGitHub"><a href="#HelloGitHub" class="headerlink" title="HelloGitHub"></a><a href="https://github.com/521xueweihan/HelloGitHub">HelloGitHub</a></h3><p>这是一个面向编程新手、热爱编程、对开源社区感兴趣人群的项目，内容以月刊的形式更新发布。内容包括：流行项目、入门级项目、让生活变得更美好的工具、书籍、学习心得笔记、企业级项目等，这些开源项目大多都是非常容易上手、很 Cool，能够让你用很短时间感受到编程的魅力和便捷。从而让大家感受到编程的乐趣，动手开始编程。</p>
<h3 id="GitHub漫游指南"><a href="#GitHub漫游指南" class="headerlink" title="GitHub漫游指南"></a><a href="https://github.com/phodal/github">GitHub漫游指南</a></h3><p>介绍你可能在Github上遇到的所有问题，从如何起一个好名字到如何推广项目，GitHub用户分析，每一个环节都非常详细。无论你处于编程的哪个阶段，我认为你都能从这份指南中获取到灵感和帮助。</p>
<h3 id="README"><a href="#README" class="headerlink" title="README"></a><a href="https://github.com/guodongxiaren/README">README</a></h3><p>该文件用来测试和展示书写README的各种markdown语法。GitHub的markdown语法在标准的markdown语法基础上做了扩充，称之为GitHub Flavored Markdown。简称GFM，GFM在GitHub上有广泛应用，除了README文件外，issues和wiki均支持markdown语法。</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#6|201812</title>
    <url>/2019/01/02/monthly_6/</url>
    <content><![CDATA[<h2 id="大事件"><a href="#大事件" class="headerlink" title="大事件"></a>大事件</h2><p>这个月的大事件是高通与苹果之间的专利大战。高通分别在中国和德国对苹果公司提起专利诉讼，结果均胜。苹果将在中国禁售iPhoneX及之前的机型。在德国则是全面禁售。</p>
<a id="more"></a>
<p>加上新品手机的创新力度不够，导致苹果股票持续走低，四个月前，苹果还是首个突破万亿美元市值的上市公司，到现在股价已经下跌了 36%，市值只有 7160 亿美元，几个月内市值损失接近 3000 亿美元。<br><img src="https://upload-images.jianshu.io/upload_images/1059465-4e4811eeba166496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="news.png"></p>
<!--more-->
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="更换启动图不生效"><a href="#更换启动图不生效" class="headerlink" title="更换启动图不生效"></a>更换启动图不生效</h3><p><strong>现象</strong>：更换启动图，不生效，即使删除旧图，运行程序启动图仍然是之前的版本。<br>尝试了删除app重装，clean、重启Xcode，删除DriverData，还试过挪图片位置，改名字，均无效。最后尝试了重启手机-&gt;再安装才正常。</p>
<p><strong>问题分析</strong>：这个是系统问题，为了加快程序启动的速度系统会把启动图做个缓存，之后每次启动是加载缓存启动图，所以才会出现修改不生效问题。但我们也并不知道系统会什么时候更新启动图，这个就有点尴尬😓<br>stackoverflow上有关于这个问题的讨论：<br><a href="https://stackoverflow.com/questions/33002829/ios-keeping-old-launch-screen-and-app-icon-after-update">iOS Keeping old launch screen and app icon after update</a></p>
<p>有人说这个不影响线上版本，从上线之后的测试来看，大部分用户没有受到影响，但还是出现了部分手机升级却未更换启动图的问题。<br>因为是系统层面控制，没有太好的解决方案，如果有人遇到这个情况，需要注意一下。</p>
<h3 id="赋值权限"><a href="#赋值权限" class="headerlink" title="赋值权限"></a>赋值权限</h3><p>在Mac 系统的终端上修改文件权限使用的是 Linux 中的 chmod 命令：<br>r：可读，表示可以读取内容<br>w:可写，表示可以编辑内容，但是不可以删除文件<br>x: 可执行，表示可以执行文件。</p>
<p>r:4<br>w:2<br>x:1<br>rwx=4+2+1=7</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1059465-078779097f1aa66f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="rwx.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 777 file</span></span><br></pre></td></tr></table></figure>
<p>这行命令的意思就是：文件所有者权限是7，同用户组的权限是7，其他非本地用户组的权限是7。同理可以出现这样的命令 chmod740.barshrc</p>
<p>再讲两个：<br>chmod u=rwx, go=rx .barshrc 这个命令中u表示拥有者，g表示group中的用户，o表示others，和上面的想对应。注意go=rx，这里go是拼接起来的，表示g和o的用户有读和执行的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod a+w .barshrc</span></span><br></pre></td></tr></table></figure>
<p>表示所有的用户（a表示all）增加写的权限。</p>
<h3 id="App图片瘦身"><a href="#App图片瘦身" class="headerlink" title="App图片瘦身"></a>App图片瘦身</h3><p>随着项目版本的不断迭代，会很容易积累越来越多的图片，对这些图片我们有两个主要方面可以优化：</p>
<h4 id="1、删除不用的图片"><a href="#1、删除不用的图片" class="headerlink" title="1、删除不用的图片"></a>1、删除不用的图片</h4><p>我们需要借助一个工具<a href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a><br>它可以检索项目中未使用的图片资源，我们可以指定检索图片的路径，后缀进行过滤。<br><strong>注意</strong>：无法区分png序列的引用。最好手动删除</p>
<h4 id="2、图片压缩"><a href="#2、图片压缩" class="headerlink" title="2、图片压缩"></a>2、图片压缩</h4><p>可以通过<a href="https://imageoptim.com/mac">ImageOptim</a>，对图片进行无损压缩。使用时只需将要压缩的文件拖到程序中即可。<br>如果图片较多时，可以借助其命令行工具：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;ImageOptim.app&#x2F;Contents&#x2F;MacOS&#x2F;ImageOptim $file_name</span><br></pre></td></tr></table></figure>
<p>对应的shell脚本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 处理文件名出现空格问题</span><br><span class="line">MY_IFS&#x3D;$IFS</span><br><span class="line">IFS&#x3D;$&#39;\n&#39;</span><br><span class="line">for file_name in $(find &quot;$1&quot; -name &quot;*.png&quot; -type f); do</span><br><span class="line">echo $file_name</span><br><span class="line">&#x2F;Applications&#x2F;ImageOptim.app&#x2F;Contents&#x2F;MacOS&#x2F;ImageOptim $file_name</span><br><span class="line">done</span><br><span class="line">IFS&#x3D;$MY_IFS</span><br></pre></td></tr></table></figure>
<p>该工具还有一个Sketch插件：<a href="https://imageoptim.com/sketch">Plugin for Sketch
</a>，可以在输出icon的时候直接进行压缩优化。</p>
<h3 id="后台音频耗电问题"><a href="#后台音频耗电问题" class="headerlink" title="后台音频耗电问题"></a>后台音频耗电问题</h3><p><strong>功能：</strong>一段助眠音频可以后台播放，播放完成后如果返回app，会跳到对应的完成界面。<br><strong>问题：</strong>有用户反馈，听音频睡着了，早上醒来，电量掉了很多（40%）。<br><strong>调研：</strong><br>使用Xcode中 <code>Debug Navigator</code>栏的<code>Energy Debug Gauge</code>（需真机）测试。播放完成4分钟左右的后台耗电状态如下：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-4dc9ec91be8167f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Energy Debug Gauge.png"><br>分析可知虽然此时app停止了所有行为，但是生命周期仍处于<code>Background</code>状态，耗电量也还是存在的。暂时认为问题是客户端一直处于<code>Background</code>模式，并未被<code>Suspend</code>，导致一直被系统维护着，所以一直有耗电情况。</p>
<p>再一次查看苹果关于后台模式的文档：</p>
<blockquote>
<p>When the UIBackgroundModes key contains the audio value, the system’s media frameworks automatically prevent the corresponding app from being suspended when it moves to the background. As long as it is playing audio or video content or recording audio content, the app continues to run in the background. However, if recording or playback stops, the system suspends the app.</p>
</blockquote>
<p>可知，只要播放器未被销毁，就会一直占用后台模式！<br><strong>解决方案：</strong><br>在播放完成时销毁播放器。</p>
<p><strong>检验：</strong><br>再次观察播放音频完成一段时间之后的后台耗电情况：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-941fcf791ca2dc28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>此时app被挂起，耗电量基本为0，唤醒app，仍能正常工作。问题解决。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>尝试分模块整理推荐阅读的内容</p>
<h3 id="iOS开发过程中的设计模式"><a href="#iOS开发过程中的设计模式" class="headerlink" title="iOS开发过程中的设计模式"></a>iOS开发过程中的设计模式</h3><p><img src="https://upload-images.jianshu.io/upload_images/1059465-e0dc16cd94be1833.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="design pattern.jpeg"></p>
<blockquote>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
</blockquote>
<p>以上摘自<a href="http://www.runoob.com/design-pattern/design-pattern-intro.html">菜鸟教程</a></p>
<p><a href="https://medium.com/flawless-app-stories/strategy-pattern-in-swift-1462dbddd9fe">Swift中的策略模式</a><br>从一个小例子入手，讲解策略模式在swift中的使用。</p>
<p><a href="https://swift.gg/2018/09/10/design-pattern-creational/">Swift 中的设计模式 #1 工厂方法与单例方法</a><br><a href="https://swift.gg/2018/11/26/design-pattern-behavorial/">Swift 中的设计模式 #2 观察者模式与备忘录模式</a><br><a href="https://swift.gg/2018/11/29/design-pattern-structural/">Swift 中的设计模式 #3 外观模式与适配器模式</a><br>SwiftGG翻译组翻译的设计模式系列文章。</p>
<p><a href="https://github.com/skyming/Trip-to-iOS-Design-Patterns">设计模式资料整理</a><br>应该是目前总结最全的适合iOS开发的设计模式资料汇总。</p>
<h3 id="iOS逆向"><a href="#iOS逆向" class="headerlink" title="iOS逆向"></a>iOS逆向</h3><p><img src="https://upload-images.jianshu.io/upload_images/1059465-f0ddd03518d37a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apple-hook.png"></p>
<blockquote>
<p>iOS应用逆向工程，是指从目标应用的界面及功能表现入手，使用不同的工具和理论知识去分析其实现原理，得出应用的代码结构、整体设计、功能实现、执行流程等，然后利用iOS的系统知识和语言特性，借鉴或修改原有实现流程的技术。</p>
</blockquote>
<p>推荐两篇掘金上关于iOS逆向的文章：<br><a href="https://juejin.im/post/5c19a38ae51d453e0a209256">TikTok(抖音国际版)逆向，全球的小姐姐们，我来啦！</a><br><a href="https://juejin.im/post/5bc425495188255c9d564044">逆向 Mac 应用 Bartender</a><br>这两篇都是通过具体实例入手，讲解逆向常用的工具和一些逆向的思路，非常适合新手。最好跟着介绍实际操作一番，第一次成功逆向一个项目之后，那种爽歪歪的感觉，你懂的！</p>
<p>另外推荐一位逆向领域的牛人刘培庆（<a href="https://www.alonemonkey.com/">博客</a>，<a href="https://github.com/AloneMonkey">github</a>），了解逆向的同学大多应该都不陌生，iOS方面的逆向优先参照 <strong><a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a></strong>。<br>刘总今年出了新书《iOS应用逆向与安全》，非常适合对逆向有兴趣的同学。</p>
<h3 id="利用脚本提高工作效率"><a href="#利用脚本提高工作效率" class="headerlink" title="利用脚本提高工作效率"></a>利用脚本提高工作效率</h3><blockquote>
<p>脚本语言（英语：Scripting language）是为了缩短传统的“编写、编译、链接、运行”（edit-compile-link-run）过程而创建的计算机编程语言。早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作</p>
</blockquote>
<p><a href="https://sspai.com/post/46912">AppleScript入门：探索macOS自动化</a></p>
<p>文章选自少数派，讲述了：</p>
<ul>
<li>什么是 AppleScript？</li>
<li>我使用 AppleScript 的情境</li>
<li>AppleScript 基础语法</li>
<li>AppleScript suite 之外的解法：模拟键鼠</li>
</ul>
<p>非常清晰详细的AppleScript入门文章。<br><a href="https://juejin.im/post/5bfac61ee51d454af013a900">如何提高工作效率 - 自动化篇</a><br>文章选自掘金，串联Shell Script, Apple Script, Automator, Alfred &amp; WorkFlows，告诉你如果灵活应用，达到利用脚本提高工作效率的目的。</p>
<p>我写了一个利用AppleScript和Alfred的WorkFlows在命令行打开指定路径的工具。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1059465-4ada69de8b235846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="workflow.png"></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> argv</span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Finder"</span></span><br><span class="line"><span class="comment">-- get selection path</span></span><br><span class="line"><span class="keyword">set</span> pathFile <span class="keyword">to</span> selection <span class="keyword">as</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">set</span> pathFile <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> pathFile</span><br><span class="line"><span class="comment">-- fix space problem in the directory</span></span><br><span class="line"><span class="keyword">set</span> pathFile <span class="keyword">to</span> <span class="keyword">quoted form</span> <span class="keyword">of</span> pathFile</span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Terminal"</span></span><br><span class="line"><span class="built_in">activate</span></span><br><span class="line"><span class="keyword">tell</span> window <span class="number">1</span></span><br><span class="line">do <span class="keyword">script</span> <span class="string">"cd "</span> &amp; pathFile</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure>

<p>使用方法是：点击选中文件夹，按下热键<code>CMD + T</code>。</p>
<h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><p><strong><a href="https://talk.swift.gg/9">创业那点事：听莲叔和羊叔回忆峥嵘岁月</a></strong><br>莲叔和羊叔是 SwiftGG 翻译组的真·大佬。成绩好，学历高，思维缜密，能力很强。听过《升职加薪》那期节目的朋友应该都有印象。作为标准的技术人才，在创业大潮中自然也想试试身手，打拼一番。</p>
<p><strong><a href="https://talk.swift.gg/8">和 Cee 聊聊如何拿 Google Offer</a></strong><br>翻译组里真是人才辈出啊，前几天 Cee 在群里说了个好消息，他拿到了美国 Google 的 Offer。群友们纷纷表示祝贺并进行了隆重的认哥仪式，将 SwiftGG 诞生以来第一个 GG（哥哥） 称号颁发给我们公认的大哥 Cee。</p>
<p>以上两个音频来自于(ggtalk)[<a href="https://talk.swift.gg/]，也是我最近上下班路上用来消遣的音频节目，墙裂推荐！">https://talk.swift.gg/]，也是我最近上下班路上用来消遣的音频节目，墙裂推荐！</a></p>
<p><strong><a href="https://www.bilibili.com/video/av21376839">计算机科学速成课</a></strong><br>由<a href="https://twitter.com/missphilbin">Carrie Anne Philbin</a>主讲，Carrie Anne Philbin是一名计算机科学教师和作家。她是树莓派基金会的教育主管，也是学校(CAS)多样性和包容组的主席。她为青少年写了电脑书《树莓派历险记》。特意介绍是因为我感觉这个课程因为这个主讲人的个人魅力而趣味十足😄。不管你是不是计算机专业的学生，看过之后应该都能有所收获。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="12306ForMac"><a href="#12306ForMac" class="headerlink" title="12306ForMac"></a><a href="https://github.com/fancymax/12306ForMac">12306ForMac</a></h3><p>以前要么开Windows虚拟机，要么使用官方Web，现在可以使用12306ForMac订票助手啦。希望对大家有所帮助！</p>
<h3 id="LongestCocoa"><a href="#LongestCocoa" class="headerlink" title="LongestCocoa"></a><a href="https://github.com/Quotation/LongestCocoa">LongestCocoa</a></h3><p>SoWhatIsTheLongestMethodOrConstantNamesInCocoaFramework? （那么，Cocoa框架中最长的方法名或常量名是什么？）答案是：</p>
<ul>
<li><p>outputImageProviderFromBufferWithPixelFormat:pixelsWide:pixelsHigh:baseAddress:bytesPerRow:releaseCallback:releaseContext:colorSpace:shouldColorMatch:</p>
</li>
<li><p>kCMSampleBufferConduitNotificationParameter_UpcomingOutputPTSRangeMayOverlapQueuedOutputPTSRange</p>
</li>
</ul>
<p>这个项目有一定的调侃意味，so what? 我选择swift🤣</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年总结</title>
    <url>/2019/01/01/2018-year-summary/</url>
    <content><![CDATA[<blockquote>
<p>写的有点晚了，因为一些事情耽搁，本来想干脆不写了。但有股力量不断催促着自己要写下来，于是就有了这篇文章。今年对我是意义重大的一年，从几个方面说吧，工作，生活和2019年的目标。</p>
</blockquote>
<a id="more"></a>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/16823bc1cd33e59c?w=1240&h=827&f=jpeg&s=59357" alt="work.jpg"></p>
<p>3月底进了新公司，换工作主要原因是在之前的公司遇到了上升瓶颈，对当时的我来说一直待下去也无法看到清晰的未来。从新公司开始，今年变化了很多，也成长了不少。</p>
<!--more-->
<h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3><p>首先技术语言从OC转到了Swift，也是首次用Swift进行项目开发，并没有太大障碍。因为是经手新项目，所有也没有太多历史包袱（兼容OC），使用Swift+RxSwift+<a href="https://github.com/sergdort/CleanArchitectureRxSwift">Clean architecture</a>的进行开发。我对Swift的感觉还是很好的，值得大家花时间去学去适应，毕竟Swfit代表着未来，是苹果推荐语言。<br>都9102年了，ABI稳定版Swift5.0马上就要来了，没有什么理由不使用它了，不是吗。</p>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>一直都是使用MacBook Pro+Xcode的环境进行开发，之后使用fastlane进行打包，每次编译打包都将近40分钟。为了提高开发效率，开始考虑黑苹果方案。配置一台i7处理器+16G内存的台式机，4000左右，开始搞黑苹果。</p>
<p>附送一个教程<a href="https://www.tonymacx86.com/threads/unibeast-install-macos-sierra-on-any-supported-intel-based-pc.200564/"><strong>传送门</strong></a>，以下是黑苹果配置：<br><img src="https://user-gold-cdn.xitu.io/2019/1/6/16823bc1cd42588f?w=586&h=335&f=png&s=88723" alt="hackintosh.png"></p>
<p>有两个需要注意的地方：<br>1、显卡无法驱动。<br>使用免驱显卡。<br>当时装的时候Mojave版本还没有正式版，想升级时才发现macOS10.14及之后的版本将不再识别NVIDIA的显卡，除非换成AMD显卡，遂放弃升级。<br>2、网卡问题<br>可以在天猫购买一个支持黑苹果的网卡，收到货之后向店主要个网卡驱动，之后就能正常wifi上网啦。<br><img src="https://user-gold-cdn.xitu.io/2019/1/6/16823bc1cd56e94c?w=1240&h=791&f=png&s=372767" alt="network card"></p>
<p>其他如蓝牙问题因为基本不用，没有搞，也可以使用黑苹果专用外设解决。</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a><a href="https://zhangferry.github.io/">博客</a></h3><p>2018年共写了12篇播放，看了下日期，第一篇是从7月份开始写的，也就是说这12篇都是后半年写出来的。</p>
<p>关于写博客这件事，之前是一直有种迷茫的状态，一查就懂的不想写，太复杂的又不愿花时间整理。后来慢慢不知怎么地就又找到了点感觉，其实也没有什么规律，只是写的时候不那么被动了。<br>之前博客都是发的<a href="https://www.jianshu.com/u/5a644cf7cd17">简书</a>，后来觉得简书环境不太好了，不光是对程序员不友好了，简书整体也脱离了那种小清新的感觉，不知道从那个版本开始简书客户端UI突变，整个头条风，就不爱了。转到了<a href="https://juejin.im/user/5b0b99e8518825157b615922">掘金</a>，不过之前的文章并没有搬运过来。</p>
<p>如果有留意我最近博客的话，可以看到我正在弄一个iOS月报的东西。这个想法的产生是因为，每隔一段时间都会积攒一些知识点，一些学习感悟，因为是零碎的东西，又不便于整合成一篇博客。后来关注到<a href="https://juejin.im/user/5a52075e6fb9a01c9d31b107">老司机周报</a>、<a href="https://juejin.im/user/5a9a7c4ef265da239d48c115">知识小集</a>、<a href="http://url.cn/5evuc7e">阮一峰的网络日志</a>这几个栏目，收到启发，于是整合出iOS开发月报这种形式。毕竟一个月整理一次对我来说是一件可以做到的事。因为是一个人在做，每个月接触的东西也都会不一样，可能形式会有大大小小的差别。配图不好，语言不通顺也请大家多包涵，如果有什么意见或者好的内容可以给我推荐。我会持续努力的，争取做好这个栏目，给大家带来更多有质量的东西。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/16823bc1cd2fb1e9?w=1240&h=827&f=jpeg&s=123211" alt="life style.jpg"></p>
<h3 id="那些经历"><a href="#那些经历" class="headerlink" title="那些经历"></a>那些经历</h3><p>翻了下相册来给过去的一年做下汇总：</p>
<p>在17年的最后一天跟一个团体，参加跨年夜行活动，从奥林匹克公园走到天安门广场，看1月1号的升旗仪式。</p>
<p>1月份在中关村创业大街跟一个高中时的朋友一起去听了哈默的如何成为斜杆青年的讲座。</p>
<p>同样是一月开始追《海贼》，从第一话开始，一直都是看的漫画，到顶上战争知道这将是场精彩的对决，转为动漫，之后就一直是动漫了，目前看到大妈篇打卡二。</p>
<p>一月份还参加了极客公园创新大会，见到了傅盛、王小川、黎万强、李彦宏、罗振宇等一众大佬本人。</p>
<p>3月份裸辞，在家闲置了半个月。<br>跟女朋友从苹果园开始骑行，去了位于门头沟的京西古道。到了地方，视野所见游客不足十人，人家都快下班了，说要关门不推荐我们进去，于是歇了会就原路返回了。</p>
<p>4月份进了新公司。<br>第二次参加北京国际半程马拉松，提前一个月开始准备，期间每天早上两公里，周末五公里。成绩是2小时20分钟。</p>
<p>5月份跟女朋友去了青岛，当时天气还比较冷，只记得吃了两次九龙餐厅的饭，真香。</p>
<p>7月份跟女朋友去了秦皇岛的孤独图书馆，她预约了一个月才预约上。到了之后感觉一般，图书馆很小，书也不多，不让拍照。图书馆旁边是阿那亚教堂，也感觉一般吧，不推荐去。<br>还去了十渡，玩了玻璃栈道和漂流。这个非常推荐。</p>
<p>8月份对我来说是灾难性的，母亲被一场突如其来的疾病夺去了年轻的生命。我无助绝望过，一蹶不振过，也悲观厌世过，好在女朋友陪在身边，给了我足够的陪伴与安慰，才让我重新振作起来，真的非常感谢她。后来我不断的回忆与后悔，为什么没有坚持每年对父母做一个体检，我明明是知道的。<br>所以我也再次郑重建议大家，每年带父母至少体检一次，多陪陪他们，真的这没那么难。</p>
<p>之后的下半年除了跟我爸，我女朋友分别爬了两次香山，基本就没什么活动了。</p>
<h3 id="关于理财"><a href="#关于理财" class="headerlink" title="关于理财"></a>关于理财</h3><p>16年接触基金，17年开始定投，一开始对定投的理解就是分摊风险，比股票稳定，大概率会盈利。18年年初收益率达到15%时，当时定投已经达到我的设定预期。但我却仍坚定的相信，继续持有会获得更大收益。之后经历中美贸易战，股市重挫，之后持续的经济低迷，我都相信会涨回来，直到年末基金亏损达30%。我才意识到，当初自己那盲目的乐观是多么不正确。</p>
<p>后来听了一些大佬对19年经济形势的预测，大概率经济不会转好。所以基金定投这个事也会停止下来，这对我来说是一个教训，以后对理财会更加谨慎。</p>
<h3 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h3><p>今年阅读量比较小，就这几本：<br>《Objective-C高级编程》<br>《Swift面向协议编程》<br>《大话设计模式》<br>《人类群星闪耀时》<br>《巨人的陨落》<br>《精进》<br>《钝感力》<br>《把生命浪费在美好的事物上》<br>《你一定爱的欧洲极简史》</p>
<p>正在看的有：<br>《重构》<br>《未来简史》<br>《iOS逆向与安全》<br>计划要看的是：<br>《代码的未来》<br>《学习之道》<br>《老人与海》<br>《天才在左疯子在右》<br>《解忧杂货铺》<br>《怪诞行为学》<br>《百年孤独》<br>《菊与刀》</p>
<h2 id="2019年OKR"><a href="#2019年OKR" class="headerlink" title="2019年OKR"></a>2019年OKR</h2><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/16823bc1cd5274cc?w=1240&h=827&f=jpeg&s=111890" alt="tomorrow.jpg"></p>
<p>O1:精进技术栈<br>KR1:刷50道LeetCode题，写5篇左右博客总结解题思路。<br>KR2:做3个iOS、mac客户端的逆向。<br>KR3:翻译5篇Swift相关技术文章。<br>KR4:学习前端知识，给博客换个面貌。<br>KR5:开发一款微习惯的APP<br>KR6:博客输出24篇</p>
<p>O2:攒更多的钱<br>KR1:工资外收入达到1000<br>KR2:总收入达到买房需要的首付一半</p>
<p>O3:运动健身<br>KR1:半程马拉松跑到2小时以内<br>KR2:咕咚累积里程达到500公里</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#5|201811</title>
    <url>/2018/12/01/monthly_5/</url>
    <content><![CDATA[<h2 id="大事件"><a href="#大事件" class="headerlink" title="大事件"></a>大事件</h2><p>11月27号，苹果AppStore下架包括拼多多、搜狗地图、讯飞阅读和悦跑圈在内的共718个App。据称下架原因是触发了AppStroe审核指南的2.5.2条例，即使用了热更新技术。去年6月份，苹果层因热更新下架数万款App。<br><img src="https://upload-images.jianshu.io/upload_images/1059465-14aacc2395523d81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C6D6A56886BF8346FA56A046C2BEE023.jpg"></p>
<a id="more"></a>

<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="图片渲染开销"><a href="#图片渲染开销" class="headerlink" title="图片渲染开销"></a>图片渲染开销</h3><p>我们知道，解压后的图片是由无数像素数据组成。每个像素点通常包括红、绿、蓝和 alpha 数据，每个值都是 8 位（0–255），因此一个像素通常会占用 4 个字节（32 bit per pixel。少数专业的 app 可能会用更大的空间来表示色深，消耗的内存会相应线性增加）。</p>
<p>下面我们来计算一些通常的图片开销：</p>
<p>普通图片大小，如 500 * 600 * 32bpp = 1MB<br>跟 iPhone X 屏幕一样大的：1125 * 2436 * 32bpp = 10MB<br>即刻中允许最大的图片，总像素不超过1500w：15000000 * 32bpp = 57MB<br>有了大致的概念，以后看到一张图能简单预估，大概会吃掉多少内存。</p>
<h3 id="关于iOS开发证书在钥匙串没有秘钥的问题"><a href="#关于iOS开发证书在钥匙串没有秘钥的问题" class="headerlink" title="关于iOS开发证书在钥匙串没有秘钥的问题"></a>关于iOS开发证书在钥匙串没有秘钥的问题</h3><p>当前现象<br><img src="https://upload-images.jianshu.io/upload_images/1059465-20f6c5844ca97977.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D9E4F2DFEAAA7AB5D4CEC1A380A8221E.jpg"></p>
<p>只需要将证书拖到登录，即可生成秘钥<br><img src="https://upload-images.jianshu.io/upload_images/1059465-a0cd997865427e88.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B91143F5C7B2BEA07FAF8849766D163E.jpg"></p>
<h3 id="APP内切换语言"><a href="#APP内切换语言" class="headerlink" title="APP内切换语言"></a>APP内切换语言</h3><p>APP内切换语言有一种比较简单的实现方式，实现步骤是：<br>1、存储语言状态<br>2、刷新<code>KeyWindow.rootViewController</code><br>3、刷新<code>Bundle</code><br>4、切换语言对应的更新操作<br>实现过程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、切换语言，AppleLanguages对应内容是数组，语言符合可以通过Bundle.main.localizations查看</span></span><br><span class="line"><span class="comment">//切换至繁体中文，存储状态</span></span><br><span class="line"><span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>([<span class="string">"zh-Hant"</span>], forKey: <span class="string">"AppleLanguages"</span>)</span><br><span class="line"><span class="comment">//2、刷新keyWindow，createRootViewController为创建rootViewController的方法</span></span><br><span class="line"><span class="type">UIApplication</span>.shared.keyWindow?.rootViewController = <span class="type">Application</span>.shared.createRootViewController()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、更换bundle</span></span><br><span class="line"><span class="comment">//在切换语言的时候，我们需要执行一下，Bundle的exchangeBundle方法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getLocalizedBundle</span><span class="params">()</span></span> -&gt; <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> languages = <span class="type">UserDefaults</span>.standard.object(forKey: <span class="string">"AppleLanguages"</span>) <span class="keyword">as</span>? [<span class="type">String</span>],</span><br><span class="line">                <span class="keyword">let</span> lan = languages.first,</span><br><span class="line">                <span class="keyword">let</span> path = <span class="type">Bundle</span>.main.path(forResource: lan, ofType: <span class="string">"lproj"</span>),</span><br><span class="line">                <span class="keyword">let</span> bundle = <span class="type">Bundle</span>.<span class="keyword">init</span>(path: path)&#123;</span><br><span class="line">                <span class="keyword">return</span> bundle</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Bundle</span>.main</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">exchangeBundle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//替换Bundle.main为自定义的BundleLocal</span></span><br><span class="line">        object_setClass(<span class="type">Bundle</span>.main, <span class="type">BundleLocal</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BundleLocal</span>: <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">localizedString</span><span class="params">(forKey key: String, value: String?, table tableName: String?)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.getLocalizedBundle().localizedString(forKey: key, value: value, table: tableName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、其他更新操作，如接口，UI界面</span></span><br></pre></td></tr></table></figure>

<h3 id="测试内购时长"><a href="#测试内购时长" class="headerlink" title="测试内购时长"></a>测试内购时长</h3><p>当我们测试内购时，需要考虑内购到期的情况。比如我测试购买了一个月的服务，那么购买到期的情况呢，不能傻傻地等一个月时间吧？<br>其实苹果给出了不同内购时长在Debug情况下对应的测试时间。<br><img src="https://upload-images.jianshu.io/upload_images/1059465-259f75d94a813ac2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04DF44800E5F07286951E4BE11342A89.jpg"></p>
<h3 id="AVPlayer进入前台自动播放"><a href="#AVPlayer进入前台自动播放" class="headerlink" title="AVPlayer进入前台自动播放"></a>AVPlayer进入前台自动播放</h3><p>在我们不进行任何前后台设置的情况下，AVPlayer进入后台，会自动暂停播放。再次回到前台时，播放器会有一定概率自动恢复播放（多大概率未知，测试得出的结论）。</p>
<p>如果这个恢复播放不是我们需要的，或者我们需要避免这种不确定的情况发生，我们可以手动管理这个过程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">UIApplication</span>.didEnterBackgroundNotification, object: <span class="keyword">self</span>, queue: <span class="literal">nil</span>) &#123; (notification) <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.player.pause()</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">UIApplication</span>.didEnterBackgroundNotification, object: <span class="keyword">self</span>, queue: <span class="literal">nil</span>) &#123; (notification) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//根据需要是否需要恢复播放</span></span><br><span class="line">    <span class="keyword">if</span> shouleRecoverPlayer &#123;</span><br><span class="line">        <span class="keyword">self</span>.player.play()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.player.pause()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iOS12-1关于tabbar的一个bug"><a href="#iOS12-1关于tabbar的一个bug" class="headerlink" title="iOS12.1关于tabbar的一个bug"></a>iOS12.1关于tabbar的一个bug</h3><p><strong>触发条件：</strong></p>
<ul>
<li>使用 <code>UITabBarController</code> + <code>UINavigationController</code> 组合</li>
<li><code>UITabBar</code>带半透明效果，<code>isTranslucent</code> 属性为 true</li>
<li><code>UIViewController</code>的 <code>hidesBottomBarWhenPushed</code> 属性为 true</li>
<li>通过导航栏返回上一页时(导航栏返回按钮 or 屏幕左侧的滑动返回手势)</li>
</ul>
<p><strong>问题现象：</strong><br><img src="https://upload-images.jianshu.io/upload_images/1059465-01da29cdb1811251.gif?imageMogr2/auto-orient/strip" alt="20181112163203240.gif"></p>
<p>经确认是iOS12.1上的一个bug。<br><strong>解决方案：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: - fix ios12.1 tabbar bug</span></span><br><span class="line"><span class="keyword">let</span> tabbar = <span class="type">UITabBar</span>.appearance()</span><br><span class="line">tabbar.isTranslucent = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>详细内容可以参考：<br><a href="https://blog.csdn.net/ZHFDBK/article/details/83994088">修复 iOS12.1 UITabBar 布局位移bug - ZHFDBK的博客 - CSDN博客</a><br><a href="https://stackoverflow.com/questions/53084806/uitabbar-items-jumping-on-back-navigation-on-ios-12-1">swift - UITabBar items jumping on back navigation on iOS 12.1 - Stack Overflow</a></p>
<h2 id="推荐内容"><a href="#推荐内容" class="headerlink" title="推荐内容"></a>推荐内容</h2><h3 id="重构Swift中的Identifiers"><a href="#重构Swift中的Identifiers" class="headerlink" title="重构Swift中的Identifiers"></a><a href="https://medium.com/@vatsalrustagi/ios-refactoring-in-swift-identifiers-b14d9fff20c3">重构Swift中的Identifiers</a></h3><p>面对越来越多的identifier，改如何优雅地处理？<br>文中讲了一些<code>UITableViewCell</code>、<code>UICollectionViewCell</code>、<code>segues</code>、<code>UIStoryboards</code>、<code>UIViewController</code>中关于identifiers的重构方法。</p>
<h3 id="The-End-Is-Near-for-Mobile-Apps"><a href="#The-End-Is-Near-for-Mobile-Apps" class="headerlink" title="The End Is Near for Mobile Apps"></a><a href="https://medium.com/s/story/mobile-apps-will-disappear-soon-4b4e54f46eb8">The End Is Near for Mobile Apps</a></h3><p>移动应用的末日将要来临？<br>Medium科技板块最近比较火的一篇文章，分上下两篇，讲述移动应用的前景和趋势。</p>
<h3 id="Realm学院"><a href="#Realm学院" class="headerlink" title="Realm学院"></a><a href="https://academy.realm.io/cn/">Realm学院</a></h3><p>这是Realm建立的一个用于学习编程技术的网站，主要方式是视频，内容配有字幕，并且都全部整理成文章。涵盖范围有<code>Realm</code>, <code>Android</code>, <code>iOS</code>, <code>JavaScript</code>, <code>Architecture</code>等。</p>
<p>文章质量非常高！</p>
<h2 id="开发利器"><a href="#开发利器" class="headerlink" title="开发利器"></a>开发利器</h2><h3 id="KTVHTTPCache"><a href="#KTVHTTPCache" class="headerlink" title="KTVHTTPCache"></a><a href="https://github.com/ChangbaDevs/KTVHTTPCache">KTVHTTPCache</a></h3><p>应该是iOS端目前最好的流媒体缓存框架了。</p>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><a href="https://realm.io/">Realm</a></h3><p>Realm是一个开源的对象数据库管理系统，最初用于移动(Android/iOS)，也可用于<code>Xamarin</code>或<code>React Native</code>等平台，等平台，包括桌面应用(Windows)，并获得<code>Apache</code>许可。</p>
<p>对比FMDB，他的使用成本，维护成本都更低。</p>
<h3 id="uTools"><a href="#uTools" class="headerlink" title="uTools"></a><a href="https://u.tools/">uTools</a></h3><p>uTools是一个极简、插件化、跨平台的现代化桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。<br>通过快捷键（默认alt+space）就可以快速呼出这个搜索框。它相当聪明，可以支持输入、拖拽、自动粘贴等作为输入源，相应的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到正确的结果。<br>当你熟悉它后，能够为你节约大量时间，让你可以更加专注的改变世界。</p>
<p>对比Alfred，他的不同就在于免费，使用简单，更符合国人的习惯。</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>AVPlayer支持的视频格式</title>
    <url>/2018/11/26/avplayer-supported-format/</url>
    <content><![CDATA[<p>发现很多人对视频格式存在一些误解，之前写的一篇文章讲AVPlayer的支持格式也有一些问题，所以这里单独出一篇文章讲一下，希望大家能明白。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个在线视频能够播放，大致是经过了如下步骤：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-d573ac8a2e21fb3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="video_play_progress.png"></p>
<p>可以总结为：拉数据-&gt;解协议-&gt;解封装-&gt;音视频解码-&gt;音视频同步-&gt;播放。<br>下面就针对这几个概念一一做下解释：</p>
<h3 id="播放协议"><a href="#播放协议" class="headerlink" title="播放协议"></a>播放协议</h3><p>一般点播采用HTTP，而直播的话，大部分还是采用RTMP或者私有协议，原因是延时会比较小，RTMP本身也是为了直播设计的。常见的流媒体协议：</p>
<table>
<thead>
<tr>
<th>简写</th>
<th align="center">全称</th>
<th align="center">推出机构</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>HLS</td>
<td align="center">HTTP Live Streaming</td>
<td align="center">苹果</td>
<td>多应用于苹果</td>
</tr>
<tr>
<td>RTP</td>
<td align="center">实时传输协议</td>
<td align="center">IETF</td>
<td>范围较广</td>
</tr>
<tr>
<td>RTCP</td>
<td align="center">实时传输控制协议</td>
<td align="center">IETF</td>
<td>范围较广</td>
</tr>
<tr>
<td>RTSP</td>
<td align="center">实时串流协议</td>
<td align="center">RealNetworks等</td>
<td>范围较广</td>
</tr>
<tr>
<td>RTMP</td>
<td align="center">实时消息协议</td>
<td align="center">Adobe</td>
<td>较流行</td>
</tr>
<tr>
<td>MMS</td>
<td align="center">串流媒体协议</td>
<td align="center">Microsoft</td>
<td>范围较广</td>
</tr>
</tbody></table>
<p><strong>RTP/RTSP/RTCP的区别</strong></p>
<blockquote>
<p>RTSP发起/终结流媒体、RTP传输流媒体数据 、RTCP对RTP进行控制，同步。</p>
</blockquote>
<p><strong>HLS(Http Live Streaming)</strong><br>HLS是苹果推出，实现的基于HTTP的流媒体传输协议:<br>优点：<br>1、通过m3u8索引文件可实现针对当前浏览设备的智能选择播放源，<br>2、通过m3u8索引文件可实现添加备份索引文件，防止服务器崩溃视频播放失败<br>3、和http视频一样 不需要太多服务器额外配置<br>缺点：<br>1、并非真正实时视频，30s左右时间差<br>2、需要视频处理<br>3、因为需要请求索引文件（ts视频文件）请求次数相对较多，对服务器负载较大</p>
<h3 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h3><p>所谓视频编码方式就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式。它是一种为了减少视频体积，同时保证画面质量的压缩技术，常见的视频编码有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>推出时间</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>HEVC(H.265)</td>
<td>MPEG/ITU-T</td>
<td>2013</td>
<td>研发中</td>
</tr>
<tr>
<td>H.264</td>
<td>MPEG/ITU-T</td>
<td>2003</td>
<td>各个领域</td>
</tr>
<tr>
<td>MPEG4</td>
<td>MPEG</td>
<td>2001</td>
<td>不温不火</td>
</tr>
<tr>
<td>MPEG2</td>
<td>MPEG</td>
<td>1994</td>
<td>数字电视</td>
</tr>
<tr>
<td>XviD</td>
<td>OpenDivX</td>
<td>2002</td>
<td>流行</td>
</tr>
<tr>
<td>VP9</td>
<td>Google</td>
<td>2013</td>
<td>研发中</td>
</tr>
<tr>
<td>VP8</td>
<td>Google</td>
<td>2008</td>
<td>不普及</td>
</tr>
<tr>
<td>VC-1</td>
<td>Microsoft Inc.</td>
<td>2006</td>
<td>微软</td>
</tr>
<tr>
<td><strong>H.264</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>H.264又叫AVC，是国际标准化组织（ISO）和国际电信联盟（ITU）共同提出的继MPEG4之后的新一代数字视频压缩格式，它集合了H.263和MPEG4的优点，拥有更高的数据压缩比。在同等的图像质量条件下，H.264的数据压缩比能比H.263高2倍，比MPEG-4高1.5倍。<br>也是目前苹果支持最好的编码格式。</p>
<h3 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h3><p>和视频编码类似，音频编码的作用是减少音频中的冗余，同时在保证一定音频质量的条件下作的压缩处理。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th align="center">推出时间</th>
<th align="center">目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>AAC</td>
<td>MPEG</td>
<td align="center">1997</td>
<td align="center">流媒体</td>
</tr>
<tr>
<td>AC-3</td>
<td>Dolby Inc.</td>
<td align="center">1992</td>
<td align="center">DVD, 数字电视</td>
</tr>
<tr>
<td>MP3</td>
<td>MPEG</td>
<td align="center">1993</td>
<td align="center">各个领域（旧）</td>
</tr>
<tr>
<td>WMA</td>
<td>Microsoft Inc.</td>
<td align="center">1999</td>
<td align="center">Windows</td>
</tr>
<tr>
<td><strong>AAC</strong></td>
<td></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>AAC（高级音频编码技术 Advanced Audio Coding)，出现于1997年，是基于MPEG-2的音频编码技术。由Fraunhofer IIS、杜比、苹果、AT&amp;T、索尼等公司共同开发，以取代mp3格式。2000年，MPEG-4标准出台，AAC从新整合了其特性，故现又称MPEG-4 AAC，即m4a。</td>
<td></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>苹果的CoreAudio对AAC有较好的支持。</td>
<td></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h3><p>我们常见的视频格式MP4, AVI, RMVB, 3GP, MKV都是指视频的封装格式,大部分情况就是视频文件的后缀。常见的组合方式有：</p>
<style>
table th:nth-of-type(2) {
    width: 60%;
}
</style>

<table>
<thead>
<tr>
<th>名称</th>
<th align="left">简介</th>
<th>常用编码格式</th>
<th>扩展名</th>
</tr>
</thead>
<tbody><tr>
<td>Flash Video</td>
<td align="left">由Adobe Flash延伸出来的的一种流行网络视频封装格式。随着视频网站的丰富，这个格式已经非常普及。</td>
<td>H.264+MP3</td>
<td>flv</td>
</tr>
<tr>
<td>AVI（Audio Video Interleave）</td>
<td align="left">比较早的AVI是微软开发的。其含义是Audio Video Interactive，就是把视频和音频编码混合在一起存储。AVI也是最长寿的格式，已经存在10余年了，虽然发布过改版（V2.0于1996年发布），但已显老态。AVI格式上限制比较多，只能有一个视频轨道和一个音频轨道（现在有非标准插件可加入最多两个音频轨道），还可以有一些附加轨道，如文字等。AVI格式不提供任何控制功能。</td>
<td>Xvid+MP3</td>
<td>avi</td>
</tr>
<tr>
<td>WMV（Windows Media Video）</td>
<td align="left">同样是微软开发的一组数字视频编解码格式的通称，ASF（Advanced Systems Format）是其封装格式。ASF封装的WMV档具有“数字版权保护”功能。</td>
<td>VC-1+WMA</td>
<td>wmv/asf</td>
</tr>
<tr>
<td>MPEG（Moving Picture Experts Group）</td>
<td align="left">是一个国际标准化组织（ISO）认可的媒体封装形式，受到大部分机器的支持。其存储方式多样，可以适应不同的应用环境。MPEG-4档的档容器格式在Part 1（mux）、14（asp）、15（avc）等中规定。MPEG的控制功能丰富，可以有多个视频（即角度）、音轨、字幕（位图字幕）等等。MPEG的一个简化版本3GP还广泛的用于准3G手机上。</td>
<td>H.264+AAC,H263+AAC</td>
<td>dat(VCD),vob(DVD), mp4, 3gp</td>
</tr>
<tr>
<td>Matroska</td>
<td align="left">是一种新的多媒体封装格式，这个封装格式可把多种不同编码的视频及16条或以上不同格式的音频和语言不同的字幕封装到一个Matroska Media档内。它也是其中一种开放源代码的多媒体封装格式。Matroska同时还可以提供非常好的交互功能，而且比MPEG更方便、强大。</td>
<td>各种编码格式的组合</td>
<td>mkv</td>
</tr>
<tr>
<td>Real Video Real Media（RM）</td>
<td align="left">是由RealNetworks开发的一种档容器。它通常只能容纳Real Video和Real Audio编码的媒体。该档带有一定的交互功能，允许编写脚本以控制播放。RM，尤其是可变比特率的RMVB格式，没有复杂的Profile/Level，制作起来较H.264视频格式简单，非常受到网络上传者的欢迎。此外很多人仍有RMVB体积小高质量的错误认知，这个不太正确的观念也导致很多人倾向使用rmvb，事实上在相同码率下，rmvb编码和H.264这个高度压缩的视频编码相比，体积会较大。</td>
<td>RealVideo+RealAudio</td>
<td>rm/rmvb</td>
</tr>
<tr>
<td>QuickTime File Format</td>
<td align="left">是由苹果公司开发的容器。1998年2月11日，国际标准化组织（ISO）认可QuickTime文件格式作为MPEG-4标准的基础。QuickTime可存储的内容相当丰富，除了视频、音频以外还可支持图片、文字（文本字幕）等。</td>
<td>H.264+AAC</td>
<td>mov, qt</td>
</tr>
</tbody></table>
<p><strong>MP4</strong><br>mp4格式是H.264编码指定使用的标准封装格式，3GP是MP4格式的一种简化版本，减少了储存空间和较低的频宽需求，让手机上有限的储存空间可以使用。</p>
<p>实际上这些封装格式对应的音频视频编码格式也不是固定的，就拿MP4来说，常见的MP4是由H.264+AAC封装，但是也由Xvid+AAC编码的可能。如果解码器不支持Xvid，则可能会出现无法播放，或者播放播放过程有声音无画面的情况。</p>
<h2 id="苹果支持哪些音视频编码格式"><a href="#苹果支持哪些音视频编码格式" class="headerlink" title="苹果支持哪些音视频编码格式"></a>苹果支持哪些音视频编码格式</h2><p>我们可以在手机介绍界面，找到手机支持的视频格式<a href="https://www.apple.com/iphone/compare/">iPhone - Compare Models - Apple</a></p>
<p>这里我们可以找到对应iPhone7支持的视频编码格式：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-fa95df4f7ab02bf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>Video formats supported: HEVC, H.264, MPEG-4 Part 2, and Motion JPEG</p>
</blockquote>
<p><strong>HEVC</strong><br>又叫H.265，iOS11+A9芯片才开始对HEVC的支持，iPhone6s及以前的设备不支持HEVC解码。<br>音频格式用红框标出来了，内容较多，可自行对比。</p>
<h2 id="AVPlayer支持哪些视频格式"><a href="#AVPlayer支持哪些视频格式" class="headerlink" title="AVPlayer支持哪些视频格式"></a>AVPlayer支持哪些视频格式</h2><p>苹果设备支持音视频格式并不是就代表<code>AVPlayer</code>也支持那么多格式，确定<code>AVPlayer</code>的支持格式，我们可以查看<code>AVKit</code>中的一个API:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//展示当前支持的音视频格式</span></span><br><span class="line"><span class="keyword">let</span> asset = <span class="type">AVURLAsset</span>.audiovisualTypes()</span><br><span class="line"><span class="comment">//打印asset可以得到（已经转过展示格式）</span></span><br><span class="line">asset type (</span><br><span class="line">    <span class="string">"audio/aacp"</span>,</span><br><span class="line">    <span class="string">"video/3gpp2"</span>,</span><br><span class="line">    <span class="string">"audio/mpeg3"</span>,</span><br><span class="line">    <span class="string">"audio/mp3"</span>,</span><br><span class="line">    <span class="string">"audio/x-caf"</span>,</span><br><span class="line">    <span class="string">"audio/mpeg"</span>,</span><br><span class="line">    <span class="string">"video/quicktime"</span>,</span><br><span class="line">    <span class="string">"audio/x-mpeg3"</span>,</span><br><span class="line">    <span class="string">"video/mp4"</span>,</span><br><span class="line">    <span class="string">"audio/wav"</span>,</span><br><span class="line">    <span class="string">"video/avi"</span>,</span><br><span class="line">    <span class="string">"audio/scpls"</span>,</span><br><span class="line">    <span class="string">"audio/mp4"</span>,</span><br><span class="line">    <span class="string">"audio/x-mpg"</span>,</span><br><span class="line">    <span class="string">"video/x-m4v"</span>,</span><br><span class="line">    <span class="string">"audio/x-wav"</span>,</span><br><span class="line">    <span class="string">"audio/x-aiff"</span>,</span><br><span class="line">    <span class="string">"application/vnd.apple.mpegurl"</span>,</span><br><span class="line">    <span class="string">"video/3gpp"</span>,</span><br><span class="line">    <span class="string">"text/vtt"</span>,</span><br><span class="line">    <span class="string">"audio/x-mpeg"</span>,</span><br><span class="line">    <span class="string">"audio/wave"</span>,</span><br><span class="line">    <span class="string">"audio/x-m4r"</span>,</span><br><span class="line">    <span class="string">"audio/x-mp3"</span>,</span><br><span class="line">    <span class="string">"audio/AMR"</span>,</span><br><span class="line">    <span class="string">"audio/aiff"</span>,</span><br><span class="line">    <span class="string">"audio/3gpp2"</span>,</span><br><span class="line">    <span class="string">"audio/aac"</span>,</span><br><span class="line">    <span class="string">"audio/mpg"</span>,</span><br><span class="line">    <span class="string">"audio/mpegurl"</span>,</span><br><span class="line">    <span class="string">"audio/x-m4b"</span>,</span><br><span class="line">    <span class="string">"application/mp4"</span>,</span><br><span class="line">    <span class="string">"audio/x-m4p"</span>,</span><br><span class="line">    <span class="string">"audio/x-scpls"</span>,</span><br><span class="line">    <span class="string">"audio/x-mpegurl"</span>,</span><br><span class="line">    <span class="string">"audio/x-aac"</span>,</span><br><span class="line">    <span class="string">"audio/3gpp"</span>,</span><br><span class="line">    <span class="string">"audio/basic"</span>,</span><br><span class="line">    <span class="string">"audio/x-m4a"</span>,</span><br><span class="line">    <span class="string">"application/x-mpegurl"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>还有一个方式用来判断当前格式是否可播：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//An extended MIME type string such as video/3gpp2; codecs="mp4v.20.9, mp4a.E1" or audio/aac; codecs="mp4a.E1".</span></span><br><span class="line"><span class="keyword">let</span> playable: <span class="type">Bool</span> = <span class="type">AVURLAsset</span>.isPlayableExtendedMIMEType(<span class="string">"video/3gpp2; codecs=\"mp4v.20.9, mp4a.E1\""</span>)</span><br></pre></td></tr></table></figure>
<p>这里的MIMEType可以在这里找到<br><a href="https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html">System-Declared Uniform Type Identifiers</a></p>
<p><strong>总结</strong><br>由此我们可以下一个总结，AVPlayer支持的：<br>视频编码格式：<code>H.264</code>、<code>HEVC</code>(iPhone7及以后设备)、<code>MPEG-4</code>。<br>视频格式（封装格式）：.mp4、.mov、.m4v、.3gp、.avi等。<br>如果想支持更多的视频格式，可以使用使用第三方的框架，常用的视频编码和解码框架有<a href="https://www.videolan.org/vlc/">VLC</a>和<a href="https://github.com/FFmpeg/FFmpeg">ffmpeg</a>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">视频文件格式 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83">音频编码格式的比较 - 维基百科，自由的百科全书</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>AVPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#4|201810</title>
    <url>/2018/10/31/monthly_4/</url>
    <content><![CDATA[<p>记录本月开发遇到的知识点，小tips，和bug总结。</p>
<h2 id="大事件"><a href="#大事件" class="headerlink" title="大事件"></a>大事件</h2><p>新版iPad Pro、MacBook Air、Mac mini发布，全线涨价，但是真香。。。<br><img src="https://upload-images.jianshu.io/upload_images/1059465-d64ed4ef11a3ee86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<a id="more"></a>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="适配swift4-2"><a href="#适配swift4-2" class="headerlink" title="适配swift4.2"></a>适配swift4.2</h3><p>1、利用xcode快速迁移<br>升级到Xcode10之后，我们打开项目会出现如下提示，<br><img src="https://upload-images.jianshu.io/upload_images/1059465-ac05882ccd098391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>点击会有一个版本升级窗口，如果你的的项目包含一些第三方库的话，第三方库的选型也会出现在上面：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-8041b545d62a3095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>默认勾选第三方库，但是我们适配的时候不应该让Xcode去自动检索第三方库代码。只对我们的app进行代码迁移就够了。<br>适配完后可以在这里查看我们当前的swift版本：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-6e113852a3fb4b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>对于第三方库，如果都适配了swift4.2，那么更新到对应版本就行了。如果有没适配的，可以通过制定版本的方式解决冲突，在Podfile文件末尾添加如下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span></span><br><span class="line">target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">config.build_settings[<span class="string">'SWIFT_VERSION'</span>] = <span class="string">'4.0'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="属性访问权限"><a href="#属性访问权限" class="headerlink" title="属性访问权限"></a>属性访问权限</h3><p>swift中提供的访问权限关键词由低到高有以下五种：<br>private &lt; fileprivate &lt; internal &lt; public &lt; open<br>其中internal是Swift中的默认控制级，一下介绍了这几种关键字的区别：</p>
<ul>
<li>private：当前作用域或者当前类中访问。</li>
<li>fileprivate：表示代码可以在当前文件中访问。</li>
<li>internal：在当前target中访问</li>
<li>public：可跨target使用，但不能被集成或者重写。</li>
<li>open：可跨target使用，允许被集成或者重写。</li>
</ul>
<p>对于一个严格的项目来说，精确的最小化访问控制级别对于代码的维护来说是很重要的。能用public的就别用open。</p>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>当我们执行某些命令行操作，收到如下提示时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linking &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;the_silver_searcher&#x2F;2.1.0... </span><br><span class="line">Error: Could not symlink etc&#x2F;bash_completion.d&#x2F;ag.bashcomp.sh</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;bash_completion.d is not writable.</span><br></pre></td></tr></table></figure>
<p>就表明我们对需要修改的文件权限不够，我们可以给文件加上修改的权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R $(whoami) &#x2F;usr&#x2F;local&#x2F;etc&#x2F;bash_completion.d</span><br></pre></td></tr></table></figure>
<p>其中<code>-R</code>表示对目前目录下的所有文件与子目录进行相同的拥有者变更(即以递回的方式逐个变更)</p>
<h3 id="默认关键字"><a href="#默认关键字" class="headerlink" title="默认关键字"></a>默认关键字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static let &#96;default&#96; &#x3D; ImageCache(name: &quot;default&quot;)</span><br></pre></td></tr></table></figure>
<p>default是默认关键字，如果使用要加单斜号。</p>
<h3 id="tabbar手动跳转"><a href="#tabbar手动跳转" class="headerlink" title="tabbar手动跳转"></a>tabbar手动跳转</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func tabBarController(UITabBarController, didSelect: UIViewController)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In iOS v3.0 and later, the tab bar controller calls this method regardless of whether the selected view controller changed. In addition, it is called only in response to user taps in the tab bar and is not called when your code changes the tab bar contents programmatically.<br>In versions of iOS prior to version 3.0, this method is called only when the selected view controller actually changes. In other words, it is not called when the same view controller is selected. In addition, the method was called for both programmatic and user-initiated changes to the selected view controller.</p>
</blockquote>
<p>tabbar的didSelect代理方法，只有在手动点击的时候才会触发。通过代码跳转是不会触发的。</p>
<h3 id="自定义tabbar动画"><a href="#自定义tabbar动画" class="headerlink" title="自定义tabbar动画"></a>自定义tabbar动画</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当点击tabBar的时候,自动执行该代理方法(不需要手动设置代理)  </span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tabBar</span><span class="params">(<span class="number">_</span> tabBar: UITabBar, didSelect item: UITabBarItem)</span></span> &#123;  </span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> tabBar.subviews &#123;</span><br><span class="line"><span class="comment">//控制view实现各种动画效果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NS-ASSUME-NONNULL-BEGIN-和-NS-ASSUME-NONNULL-END"><a href="#NS-ASSUME-NONNULL-BEGIN-和-NS-ASSUME-NONNULL-END" class="headerlink" title="NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END"></a>NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END</h3><p>从xcode6.3开始，为了能让OC也能表示swift的?(optional)和!功能，增加了对对象的可选指定。指定属性是否可选，可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, copy, nonnull) NSString * tickets;</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">@property (nonatomic, copy) NSString * __nonnull tickets;</span><br></pre></td></tr></table></figure>

<p>如果属性多了，每一个都这么写会很麻烦，苹果增加了一对新的宏命令，就是<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>。放在里面的对象就相当于都增加了<code>nonnull</code>命令，<code>nonull</code>为默认值。</p>
<h3 id="一个自定义collectionView布局的bug"><a href="#一个自定义collectionView布局的bug" class="headerlink" title="一个自定义collectionView布局的bug"></a>一个自定义collectionView布局的bug</h3><p><strong>bug描述：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSInternalInconsistencyException</span><br><span class="line"></span><br><span class="line">UICollectionView received layout attributes for a cell with an index path that does not exist: &lt;NSIndexPath: 0x280d2b200&gt; &#123;length &#x3D; 2, path &#x3D; 1 - 5&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原因：</strong><br><code>layoutAttributesForElementsInRect</code>返回的<code>UICollectionViewLayoutAttributes</code>数组有<code>indexPath</code>没有被 <code>[NSIndexPath indexPathForRow:numberOfSection]</code>覆盖。<br>当数据量增加时不会出问题，当数量减少时出现。有人反映这是iOS10的bug，但实际上，我拿iOS10模拟器跑并没有问题，反而是在崩溃后台看到是iOS12的用户上报的。那究竟什么原因不详，附stackoverflow(<a href="https://stackoverflow.com/questions/39867325/ios-10-bug-uicollectionview-received-layout-attributes-for-a-cell-with-an-index">iOS 10 bug: UICollectionView received layout attributes for a cell with an index path that does not exist - Stack Overflow</a>]地址。<br><strong>解决方案：</strong><br>当我们自定义layout时，需要清除UICollectionViewLayoutAttributes的缓存</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案一： 在自定义layout的类里</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.prepare()</span><br><span class="line">attributesArr.removeAll()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案二：在collectionview刷新出</span></span><br><span class="line">collectionView.reloaData()</span><br><span class="line">collectionView.collectionViewLayout.invalidateLayout()</span><br></pre></td></tr></table></figure>

<h3 id="配置git-SSH"><a href="#配置git-SSH" class="headerlink" title="配置git SSH"></a>配置git SSH</h3><p>1、设置git的user name和email</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;username&quot;</span><br><span class="line">$ git config --global user.email &quot;username@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p>2、生成秘钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;username@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p>如果不需要设置密码，连按三个回车。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。<br>3、添加秘钥到ssh-agent中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<p>4、复制公钥内容到剪贴板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>5、登录git仓库（Github或者Bitbucket）将公钥内容粘贴到指定配置位置。<br>Github地址为：<a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p>
<h3 id="Apple-Watch开发注意事项"><a href="#Apple-Watch开发注意事项" class="headerlink" title="Apple Watch开发注意事项"></a>Apple Watch开发注意事项</h3><p>1、watch没有UIKit，对于UI的操作只能通过<code>storyboard</code>进行<br>2、watch只支持帧动画，我们只能通过png序列来实现动画效果。<code>WKInterfaceGroup</code> 和 <code>WKInterfaceImage</code>均可以实现帧动画。<br>3、开发的watch应用内存被限定为80M，太多帧的动画会不支持<br>4、提交应用watch也需要配置市场截图。<br>5、watch分为两个target。当新建一个Target为WatchDemo，xcode会自动生成一个WatchDemo Extension。前者负责UI，后者负责逻辑。引用cocoapods可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target &#39;WatchDemo Extension&#39; do</span><br><span class="line">platform :watchos, &#39;3.0&#39;</span><br><span class="line">use_frameworks!</span><br><span class="line">pod &#39;Alamofire&#39;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>6、Always Embed Swift Standard Libraries<br>在Build Settings里面，这两个target，需要将WatchDemo Extension中设置为Yes，另一个设置为No</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a href="https://github.com/marcosgriselli/Sizes">Sizes</a><br>可以在一个界面，显示各个屏幕尺寸。这样我们就不用每个模拟器跑一遍看效果了。方便调试。</p>
<p><a href="https://github.com/iGhibli/iOS-DeviceSupport">iOS-DeviceSupport</a><br>当手机升级，而xcode未升级时，我们会遇到Device Support的弹框，此时要么升级xcode，要么需要导入对应的Device Support文件。这个库就是提供这种文件的。</p>
<p><a href="https://github.com/johnno1962/InjectionIII">InjectionIII</a><br>用于解决烦人的UI调试问题。当修改了一些UI属性之后，在xcode中我们只能运行程序才能看到效果，如果是处理大量的UI问题，这个过程是很烦人的。好在InjectionIII帮我们解决了这个问题，一起了解一下吧！</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#3|201809</title>
    <url>/2018/09/30/monthly_3/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1059465-2711b521a2b371fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iPhoneX R"><br>新机发布，你中意XS Max还是XR？</p>
<a id="more"></a>
<h2 id="iOS-Tips"><a href="#iOS-Tips" class="headerlink" title="iOS Tips"></a>iOS Tips</h2><h3 id="在label中插入图片"><a href="#在label中插入图片" class="headerlink" title="在label中插入图片"></a>在label中插入图片</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>()</span><br><span class="line"><span class="keyword">let</span> attribute = <span class="type">NSMutableAttributedString</span>(string: <span class="string">"Title"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> imgAttch = <span class="type">NSTextAttachment</span>()</span><br><span class="line">imgAttch.image = image</span><br><span class="line"><span class="comment">//设置图片大小</span></span><br><span class="line">imgAttch.bounds = <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">18</span>, height: <span class="number">15</span>)</span><br><span class="line"><span class="keyword">let</span> imageAttribute = <span class="type">NSAttributedString</span>(attachment: imgAttch)</span><br><span class="line"><span class="comment">//图片插入位置</span></span><br><span class="line">attribute.insert(imageAttribute, at: <span class="number">0</span>)</span><br><span class="line">label.attributedText = attribute</span><br></pre></td></tr></table></figure>

<h3 id="CollectionCell阴影-圆角的优雅处理方式"><a href="#CollectionCell阴影-圆角的优雅处理方式" class="headerlink" title="CollectionCell阴影+圆角的优雅处理方式"></a>CollectionCell阴影+圆角的优雅处理方式</h3><p>只针对类似App Store的整体圆角阴影的效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置父视图阴影效果</span></span><br><span class="line"><span class="comment">//CollectionView.swift</span></span><br><span class="line"><span class="keyword">self</span>.layer.shadowOffset = offset</span><br><span class="line"><span class="keyword">self</span>.layer.shadowColor = color.cgColor</span><br><span class="line"><span class="keyword">self</span>.layer.shadowRadius = radius</span><br><span class="line"><span class="keyword">self</span>.layer.shadowOpacity = opacity</span><br><span class="line">contentView.layer.cornerRadius = radius</span><br><span class="line"><span class="comment">//如果切割圆角带imageView才需要添加下面</span></span><br><span class="line">contentView.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="处理tableView点击时label背景色消失问题"><a href="#处理tableView点击时label背景色消失问题" class="headerlink" title="处理tableView点击时label背景色消失问题"></a>处理tableView点击时label背景色消失问题</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式，UITableViewCell.swift</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setHighlighted</span><span class="params">(<span class="number">_</span> highlighted: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> color = <span class="keyword">self</span>.indexLabel.backgroundColor</span><br><span class="line"><span class="keyword">super</span>.setHighlighted(highlighted, animated: animated)</span><br><span class="line"><span class="keyword">self</span>.indexLabel.backgroundColor = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">cell.textLabel.backgroundColor = <span class="type">UIColor</span>.clear</span><br><span class="line">cell.textLabel.layer.backgroundColor = <span class="type">UIColor</span>.red</span><br></pre></td></tr></table></figure>

<h3 id="调整UILabel文字的内边距"><a href="#调整UILabel文字的内边距" class="headerlink" title="调整UILabel文字的内边距"></a>调整UILabel文字的内边距</h3><p>自定义<code>UILabel</code>，然后重写<code>drawText:</code>方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">drawText</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> insets = <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">20</span>, <span class="keyword">left</span>: <span class="number">20</span>, bottom: <span class="number">20</span>, <span class="keyword">right</span>: <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">super</span>.drawText(<span class="keyword">in</span>: <span class="type">UIEdgeInsetsInsetRect</span>(rect, insets))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="swift-浮点数取整"><a href="#swift-浮点数取整" class="headerlink" title="swift 浮点数取整"></a>swift 浮点数取整</h3><p>ceil(x)返回不小于x的最小整数值。<br>floor(x)返回不大于x的最大整数值。<br>round(x)返回x的四舍五入整数值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number1 = <span class="number">12.456</span></span><br><span class="line"><span class="comment">// ceil(number1) = 13.0, floor(number1) = 12.0, round(number1) = 12.0</span></span><br><span class="line"><span class="keyword">let</span> number2 = <span class="number">12.756</span></span><br><span class="line"><span class="comment">// ceil(number2) = 13.0, floor(number2) = 12.0, round(number2) = 13.0</span></span><br></pre></td></tr></table></figure>

<h3 id="跳过非store下载的应用检查"><a href="#跳过非store下载的应用检查" class="headerlink" title="跳过非store下载的应用检查"></a>跳过非store下载的应用检查</h3><p>xattr -d com.apple.quarantine app所在路径</p>
<h3 id="加载大图导致内存暴涨"><a href="#加载大图导致内存暴涨" class="headerlink" title="加载大图导致内存暴涨"></a>加载大图导致内存暴涨</h3><p><code>large_leaves_70mp.jpg</code>图片是7033x10110(占用磁盘大小8.3MB)，分辨率 = 7033 x 10110 x 4（ARGB）,对应位图占用大小 = 分辨率 x 1024 x 1024 ( = 271MB)，解压会把图片转成位图，也就意味着会占用271MB内存，所以解压过程内存会瞬间消耗很大,等转成NSData后位图的内存就会被回收掉，内存就降下来，这时候NSData占用的大小即是图片的实际大小，该过程中由于会转成位图，而位图的大小是比图片的实际的大小大很多的，内存暴增的点就在位图。位图的内存大小计算是根据图片的分辨率而来（分辨率(width x heigth) x 1024 x 1024  x 4 (ARGB)），所以一般来说图片分辨率越高转成的位图占用的内存空间越大。</p>
<h3 id="新版iphone尺寸"><a href="#新版iphone尺寸" class="headerlink" title="新版iphone尺寸"></a>新版iphone尺寸</h3><table>
<thead>
<tr>
<th>设备</th>
<th>逻辑分辨率</th>
<th align="center">比例因子</th>
<th>对角线</th>
<th align="center">分辨率</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone XS Max</td>
<td>414×896</td>
<td align="center">@3x</td>
<td>6.5inch</td>
<td align="center">1242px × 2688px</td>
</tr>
<tr>
<td>iPhone XS</td>
<td>375×812</td>
<td align="center">@3x</td>
<td>5.8inch</td>
<td align="center">1125px × 2436px</td>
</tr>
<tr>
<td>iPhone XR</td>
<td>414×896</td>
<td align="center">@2x</td>
<td>6.1inch</td>
<td align="center">828px × 1792px</td>
</tr>
<tr>
<td>iPhone X</td>
<td>375×812</td>
<td align="center">@3x</td>
<td>5.8inch</td>
<td align="center">1125px × 2436px</td>
</tr>
<tr>
<td>iPhone 8 Plus</td>
<td>414×736</td>
<td align="center">@3x</td>
<td>5.5inch</td>
<td align="center">1242px × 2208px</td>
</tr>
<tr>
<td>iPhone 8</td>
<td>375×667</td>
<td align="center">@3x</td>
<td>4.7inch</td>
<td align="center">750px × 1334px</td>
</tr>
<tr>
<td>iPhone SE</td>
<td>320×568</td>
<td align="center">@2x</td>
<td>4inch</td>
<td align="center">640px × 1136px</td>
</tr>
<tr>
<td>iPhone 4</td>
<td>320×480</td>
<td align="center">@2x</td>
<td>3.5inch</td>
<td align="center">640px × 960px</td>
</tr>
</tbody></table>
<h3 id="带透明度的渐变"><a href="#带透明度的渐变" class="headerlink" title="带透明度的渐变"></a>带透明度的渐变</h3><p>使用CAGradientLayer进行渐变的时候，如果我们需要由一个颜色渐变至透明，当我们将透明色写成<code>UIColor.clear</code>或者其他通过<code>RGBA</code>设置的颜色，改变透明度为0时，会发现实际效果跟预期有出入，会带点黑色：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-5bf477719013367f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Transparent gradient.png"></p>
<p>这是因为clearColor会有一个透明度为0的黑色通道。所以应该这样设置透明色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIColor(white: 1, alpha: 0).cgColor</span><br></pre></td></tr></table></figure>

<h3 id="指定tableView，collectionView的header高度0"><a href="#指定tableView，collectionView的header高度0" class="headerlink" title="指定tableView，collectionView的header高度0"></a>指定tableView，collectionView的header高度0</h3><p>如果我们想隐藏<code>headerView</code>可能会直接在其高度的代理方法，做如下设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实际上这并不会生效，会返回一个默认高度。也就是说这个高度只有设置成一个非0的正数才是有效的。<br>有些人会写成0.01，表面上看是解决问题了，但0.01的偏移会造成像素不对齐（Color Misaligned Images），加重CPU计算负荷。完美的解决方案是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;</span><br><span class="line">return CGFloat.leastNonzeroMagnitude</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CGFloat.leastNonzeroMagnitude</code>表示CGFloat支持的最小正数值，不会引起像素偏移。</p>
<h3 id="保持屏幕常亮"><a href="#保持屏幕常亮" class="headerlink" title="保持屏幕常亮"></a>保持屏幕常亮</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保持屏幕常亮</span></span><br><span class="line"><span class="type">UIApplication</span>.shared.isIdleTimerDisabled = <span class="literal">true</span></span><br><span class="line"><span class="comment">//关闭屏幕常亮</span></span><br><span class="line"><span class="type">UIApplication</span>.shared.isIdleTimerDisabled = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>注意：不要滥用屏幕常亮属性（苹果会因为这打回你的app），如果只在某些特殊场合需要屏幕常亮，应该在之后将该值恢复成默认值<code>false</code>。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="MMKV"><a href="#MMKV" class="headerlink" title="MMKV"></a><a href="https://github.com/Tencent/MMKV">MMKV</a></h3><p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今，在 iOS 微信上使用已有近 3 年，其性能和稳定性经过了时间的验证。近期也已移植到 Android 平台，一并开源。<br>替代<code>UserDefaults</code>的绝佳方案。</p>
<h3 id="Lottie"><a href="#Lottie" class="headerlink" title="Lottie"></a><a href="https://github.com/airbnb/lottie-ios">Lottie</a></h3><p>Lottie是一个面向Android和iOS的移动库，它能够解析由AE在bodymovin导出为json的效果动画，并在移动端渲染矢量动画!<br>一些复杂的UI可以完全交给设计师了，哈哈哈。</p>
<h3 id="RSSHud"><a href="#RSSHud" class="headerlink" title="RSSHud"></a><a href="https://github.com/DIYgod/RSSHub">RSSHud</a></h3><p>RSSHub 是一个轻量、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。<br>结合<a href="https://itunes.apple.com/us/app/reeder-3/id697846300?mt=8">Reeder</a>不要太爽哦。😆</p>
]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本操作回顾</title>
    <url>/2018/09/19/git_command/</url>
    <content><![CDATA[<p>作为git最常用的几个命令<code>git status</code>、<code>git add</code>、<code>git commit</code>，我们每天可能都会写个数十遍。但是越是这种我们熟悉的操作，越容易存在一些我们忽略的细节。这篇文章就是用来记录下这些细节，记录我们常用命令中不常用的操作。</p>
<p>在git中编辑过某些文件之后，由于自上次提交后你对它们做了修改，git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 git 时文件的生命周期如下：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-6aee09f81493701f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lifecycle.png"></p>
<p>回顾完就进入正题</p>
<a id="more"></a>
<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>git status会有以下几种状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ Changes to be committed:</span><br><span class="line">$ (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br></pre></td></tr></table></figure>
<p>表示已经在暂存区，等待添加到工作区。使用<code>git reset</code>命令可以将暂存区的内容移除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ Changes not staged for commit: </span><br><span class="line">$ (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">$ (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br></pre></td></tr></table></figure>
<p>有修改, 但是没有被添加到暂存区。使用<code>git add</code>命令可以将文件添加到暂存区，使用<code>git checkout</code>命令可以撤销文件修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ Untracked files:</span><br><span class="line">$ (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br></pre></td></tr></table></figure>
<p>含有未跟踪文件, 即未纳入版本管理的文件。使用<code>git add</code>可以将文件放入暂存区。</p>
<hr>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>添加文件到暂存区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add file</span><br></pre></td></tr></table></figure>
<p>添加多个文件到暂存区，空格隔开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add file1 file2</span><br></pre></td></tr></table></figure>
<p>使用通配符批量添加documentation目录下的所有txt后缀文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add documentation&#x2F;*.txt</span><br></pre></td></tr></table></figure>
<p>添加当前目录下的所有git-开头的shell文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add git-*.sh</span><br></pre></td></tr></table></figure>
<p>将修改和以删除的文件添加到暂存区，不包括未被跟踪文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add -u file</span><br></pre></td></tr></table></figure>
<h3 id="git-add-和git-add-A-即git-add-–all-区别"><a href="#git-add-和git-add-A-即git-add-–all-区别" class="headerlink" title="git add .和git add -A(即git add –all)区别"></a>git add .和git add -A(即git add –all)区别</h3><p>一.版本导致的差别：<br>1.x版本：<br>（1）.git add -A可以提交未跟踪、修改和删除文件。<br>（2）.git add .可以提交未跟踪和修改文件，但是不处理删除文件。<br>2.x版本：<br>两者功能在提交类型方面是相同的。</p>
<p>二.所在目录不同导致的差异：<br>（1）.git add -A无论在哪个目录执行都会提交相应文件。<br>（2）.git add .只能够提交当前目录或者它后代目录下相应文件。</p>
<hr>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>当我们执行<code>git add</code>命令将文件放到暂存区之后，还需要提交这些暂存到工作区（仓库区），从暂存区-&gt;工作区，的工作就是<code>git commmit</code>来做的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区，message为提交信息</span></span><br><span class="line">git commit -m [message]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交可以指定文件</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>
<p>常用的commit扩展命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line">git commit -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">git commit --amend [file1] [file2]</span><br></pre></td></tr></table></figure>
<p>以上三条如果不带-m [message]将会在vim的编辑器中添加提交信息。</p>
<p>如果你感觉没有<code>git add</code>,<code>git commit</code>有点麻烦，想直接将修改到工作区，可以用另外一个命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会将上次commit之后的变化，直接添加到工作区</span></span><br><span class="line">git commit -a -m [message]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm file</span><br></pre></td></tr></table></figure>
<p><strong>删除位置</strong>：相当于手动右击点删除，只删除了工作区的文件。<br><strong>git status</strong>：<code>Changes not staged for commit:</code><br><strong>恢复</strong>：直接用git checkout – file就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm file</span><br></pre></td></tr></table></figure>
<p>它等价于<code>rm file + git add file</code><br><strong>删除位置</strong>：相当于不仅删除了文件，而且还添加到了暂存区。<br><strong>git status</strong>：<code>Changes to be committed:</code>。<br><strong>恢复</strong>：先git reset，去掉暂存区修改，然后再git checkout – file，恢复文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm --cached file</span><br></pre></td></tr></table></figure>
<p><strong>删除位置</strong>：从暂存区移除，不删除文件。<br><strong>git status</strong>：<code>Changes to be committed:</code>，<code>Untracked files:</code><br><strong>恢复</strong>：git add file</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git stash储存和恢复进度</title>
    <url>/2018/09/04/git_stash/</url>
    <content><![CDATA[<p>当我们正在当前项目处理一些事情时，有一个需求插进来，使得我们要在别的分支做一些工作。切换分支之前当前任务是需要保存的，但我们并没有完成一个完整的任务，直接<code>commit</code>显得不合适，这时就可以使用<code>git stash</code>命令。stash是储藏的意思，该命令的作用也可以理解为先将当前的修改储藏起来，等我们在其他分支做完必要工作之后可以再回到储藏时的状态。</p>
<p><code>git stash</code>大致可以分为储存和恢复这两步。</p>
<a id="more"></a>
<h2 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h2><p>储藏当前进度有两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>保存当前工作进度，会把暂存区和工作区的改动都保存起来，再次运行<code>git status</code>会发现当前工作区是干净的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash save &quot;commit message&quot;</span><br></pre></td></tr></table></figure>
<p>是<code>git stash</code>的完整描述，可以为本次保存添加说明。</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>查看当前保存进度，进度保存可以有多个。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure>
<p>恢复最近保存的进度，不会删除stash内容</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个stash，恢复某一个，按时间倒叙排列</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git stash drop [stash_id]</span><br></pre></td></tr></table></figure>
<p>删除某一个存储的进度</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git stash clear <span class="comment">#删除所有储存进度</span></span><br></pre></td></tr></table></figure>
<p>删除所有存储进度</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#2|201808</title>
    <url>/2018/09/03/monthly_2/</url>
    <content><![CDATA[<h2 id="数据库用完要close"><a href="#数据库用完要close" class="headerlink" title="数据库用完要close"></a>数据库用完要close</h2><p>当我们向下面这样执行完一次数据可查询时，要记得将数据库关闭，否则，如果此时想往同一数据库写东西的话会因为数据正在锁定收到这样的提示<code>database is locked</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取下载完成的文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isExistdWith</span><span class="params">(<span class="number">_</span> id: String)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line"><span class="keyword">guard</span> db.<span class="keyword">open</span>() <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">let</span> resultSet = <span class="keyword">try</span> db.executeQuery(<span class="string">"select * from tableName where id = ?"</span>, values: [id])</span><br><span class="line"><span class="keyword">if</span> resultSet.next() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isCompleted = resultSet.bool(forColumn: <span class="keyword">self</span>.isCompleted)</span><br><span class="line">db.close()<span class="comment">//return之前要close数据库</span></span><br><span class="line"><span class="keyword">return</span> isCompleted</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">db.close()<span class="comment">//return之前要close数据库</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="UIDatePicker的时间格式"><a href="#UIDatePicker的时间格式" class="headerlink" title="UIDatePicker的时间格式"></a>UIDatePicker的时间格式</h2><p>当我们用UIDatePicker做选择时间的控件时，DatePicker会根据手机时间的设置自动选择是12小时制还是24小时制，如果我们需要强制控制DatePicker是显示12小时制还是24小时制可以这么做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">datePicker.datePickerMode = .time</span><br><span class="line">datePicker.locale = <span class="type">Locale</span>.<span class="keyword">init</span>(identifier: <span class="string">"en_GB"</span>)<span class="comment">//for 24 Hrs</span></span><br><span class="line">datePicker.locale = <span class="type">Locale</span>.<span class="keyword">init</span>(identifier: <span class="string">"en_US"</span>)<span class="comment">//for 12 Hrs</span></span><br></pre></td></tr></table></figure>
<h2 id="iOS-skill-map"><a href="#iOS-skill-map" class="headerlink" title="iOS skill map"></a>iOS skill map</h2><p><img src="http://upload-images.jianshu.io/upload_images/1059465-3576096c29667cf8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS技能图谱"></p>
<h2 id="变量对外只读，对内可读写"><a href="#变量对外只读，对内可读写" class="headerlink" title="变量对外只读，对内可读写"></a>变量对外只读，对内可读写</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> name : <span class="type">String</span>!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置UITableViewCell分割线对齐"><a href="#设置UITableViewCell分割线对齐" class="headerlink" title="设置UITableViewCell分割线对齐"></a>设置UITableViewCell分割线对齐</h2><p>默认的cell分割线都是偏向右边多一些的，如果我们想让分割线对齐的话，正确的做法是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView.separatorInset = <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">0</span>, <span class="keyword">left</span>: <span class="number">40</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>设置左右边距都是40<br>但是使用这种方法会带来一个问题就是默认的textLabel会跟着右移。为了保持label的居中我们可以再加一句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView.separatorInset = <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">0</span>, <span class="keyword">left</span>: <span class="number">40</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">40</span>)</span><br><span class="line">tableView.layoutMargins = <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">0</span>, <span class="keyword">left</span>: <span class="number">40</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">40</span>)</span><br></pre></td></tr></table></figure>

<h2 id="富文本显示图片元素"><a href="#富文本显示图片元素" class="headerlink" title="富文本显示图片元素"></a>富文本显示图片元素</h2><p>如果我们需要文字中插入图片元素时，可以使用富文本处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> attch = <span class="type">NSTextAttachment</span>()</span><br><span class="line">attch.image = <span class="type">UIImage</span>.(named:<span class="string">"logo"</span>)</span><br><span class="line">attch.bounds = <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">18</span>, height: <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> imageAttribute = <span class="type">NSAttributedString</span>(attachment: attch)</span><br><span class="line">titleLabel.attributedText = attributed</span><br></pre></td></tr></table></figure>

<h2 id="添加spotlight搜索索引"><a href="#添加spotlight搜索索引" class="headerlink" title="添加spotlight搜索索引"></a>添加spotlight搜索索引</h2><p>首先导入<code>CoreSpotlight</code>和<code>MobileCoreServices</code>框架，然后加入以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchableItems = [<span class="type">CSSearchableItem</span>]()</span><br><span class="line"><span class="comment">//索引项</span></span><br><span class="line"><span class="keyword">let</span> attributeSet = <span class="type">CSSearchableItemAttributeSet</span>(itemContentType: kUTTypeData <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line"><span class="comment">//title</span></span><br><span class="line">attributeSet.title = <span class="string">"Item Title"</span></span><br><span class="line"><span class="comment">//desription</span></span><br><span class="line">attributeSet.contentDescription = <span class="string">"match.description"</span></span><br><span class="line"><span class="comment">//thumb</span></span><br><span class="line">attributeSet.thumbnailData = <span class="keyword">try</span>? <span class="type">Data</span>.<span class="keyword">init</span>(contentsOf: <span class="type">URL</span>(string: url)!)</span><br><span class="line"><span class="comment">//keywords</span></span><br><span class="line">attributeSet.keywords = [<span class="string">"Love"</span>, <span class="string">"Peace"</span>]</span><br><span class="line"><span class="keyword">let</span> searchableItem = <span class="type">CSSearchableItem</span>(uniqueIdentifier: <span class="string">"app_keywords"</span>, domainIdentifier: <span class="string">"com.company.app"</span>, attributeSet: attributeSet)</span><br><span class="line">searchableItems.append(searchableItem)</span><br><span class="line"><span class="comment">//建立索引            </span></span><br><span class="line"><span class="type">CSSearchableIndex</span>.<span class="keyword">default</span>().indexSearchableItems(searchableItems) &#123; (error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(error?.localizedDescription ?? <span class="string">"Error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hexo编译问题"><a href="#Hexo编译问题" class="headerlink" title="Hexo编译问题"></a>Hexo编译问题</h2><p>在执行<code>hexo g</code>编译markdown文件时莫名报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: Cannot set property &#39;lastIndex&#39; of undefined</span><br></pre></td></tr></table></figure>
<p>解决方案是在_config.yml中将<code>auto_detect</code>设为<code>false</code></p>
<h2 id="Podfile用法"><a href="#Podfile用法" class="headerlink" title="Podfile用法"></a>Podfile用法</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面两行是指明依赖库的来源地址</span></span><br><span class="line">source <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">source <span class="string">'https://github.com/Artsy/Specs.git'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明平台是ios，版本是8.0</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略引入库的所有警告（强迫症者的福音啊）</span></span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成的是framework而不是静态库</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对MyApp target引入AFNetworking</span></span><br><span class="line"><span class="comment"># 针对MyAppTests target引入OCMock，</span></span><br><span class="line">target <span class="string">'MyApp'</span> <span class="keyword">do</span> </span><br><span class="line">pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 3.0'</span> </span><br><span class="line">target <span class="string">'MyAppTests'</span> <span class="keyword">do</span></span><br><span class="line">inherit! <span class="symbol">:search_paths</span> </span><br><span class="line">pod <span class="string">'OCMock'</span>, <span class="string">'~&gt; 2.0.1'</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">pod <span class="string">'JSONKit'</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">'https://example.com/JSONKit.podspec'</span></span><br><span class="line"><span class="comment"># 引入内部库</span></span><br><span class="line">pod <span class="string">'ABTest'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://bitbucket.org/sealcn/remoteabtest.git'</span></span><br><span class="line">pod <span class="string">'ABTest'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://bitbucket.org/sealcn/remoteabtest.git'</span>, <span class="symbol">:tag=&gt;</span> <span class="string">'0.0.6'</span></span><br><span class="line">pod <span class="string">'ABTest'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://bitbucket.org/sealcn/remoteabtest.git'</span>, <span class="symbol">:commit=&gt;</span> <span class="string">'082f8319af'</span></span><br><span class="line"><span class="comment"># 编译配置，指定仅在Debug模式下启用</span></span><br><span class="line">pod <span class="string">'Reveal-SDK'</span>, <span class="symbol">:configurations</span> =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line"><span class="comment"># 使用本地文件</span></span><br><span class="line">pod <span class="string">'AFNetworking'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'~/Documents/AFNetworking'</span></span><br><span class="line"><span class="comment"># 指定版本号0.1.3到0.2，不包括0.2</span></span><br><span class="line">pod <span class="string">'CHIPageControl'</span>, <span class="string">'~&gt; 0.1.3'</span></span><br><span class="line"><span class="comment"># 仅安装QueryKit下的Attribute和QuerySet模块</span></span><br><span class="line">pod <span class="string">'QueryKit'</span>, <span class="symbol">:subspecs</span> =&gt; [<span class="string">'Attribute'</span>, <span class="string">'QuerySet'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 这个是cocoapods的一些配置,官网并没有太详细的说明,一般采取默认就好了,也就是不写.</span></span><br><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span>       </span><br><span class="line">installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span> </span><br><span class="line">puts target.name </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>《精进》阅后总结</title>
    <url>/2018/09/02/jingjin-read-summary/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1059465-6b6566e95596f8a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="精进.png"></p>
<p>最近刚看完采铜的这本《精进-如何成为一个很厉害的人》，一本很值得推荐的书。这种讲述如何学习，如何自我提升的书很容易一不小心写成空洞的心灵鸡汤。然而我在实际阅读中根本没有这种想法，因为它专业性很强，我感受到的是作者的博学和诚意，还有经常性的好像被点拨了一下的惊喜。没有深入的思考和深厚的学术功底是写不出这种书，推荐大家有机会也仔细地读一读。<br>阅读过程中画了很多自己受启发的观点，也可以说是我读到的这本书中的精华部分，摘录了下来。全书分七个章节，逐一讲述如何成为一个很厉害的人：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1059465-53a1ff8e7834d421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<a id="more"></a>

<h2 id="时间之尺"><a href="#时间之尺" class="headerlink" title="时间之尺"></a>时间之尺</h2><ul>
<li>林德沃提出的更好地对待时间的十条建议：<br>1、活在当下<br>2、严肃地对待时间<br>3、留意自己拥有的空间并享受它<br>4、反思自己和其他人的时间视角<br>5、从现在出发联结过去<br>6、并不完全沉浸于过去<br>7、指定实现目标的计划<br>8、平衡计划和非计划时间<br>9、视未来存在与当下<br>10、对未来保持积极的态度</li>
<li>需要好好思考一下，如何通过一点一滴的人生增量，完成个人核心竞争力的锻造。</li>
<li>让“远期未来”更加具体，为“近期未来”增加挑战。</li>
<li>把时间花在值得做的事情上。收益指+收益半衰期。</li>
<li>使用时间之尺，审视事件的长期价值，尽可能删减掉非必要事件。</li>
<li>侯世达定律：实际做事花费的时间总比预期要长，即使预期中考虑了侯世达定律。</li>
<li>提升时间使用的“深度”，减少被动式休闲的比例，保持至少一项长期的业余爱好。<h2 id="寻找心中的“巴拿马”"><a href="#寻找心中的“巴拿马”" class="headerlink" title="寻找心中的“巴拿马”"></a>寻找心中的“巴拿马”</h2></li>
<li>仅仅是好的选择是不够的我们需要的事最好的选择。</li>
<li>一个成熟的人，他的标准来自他的内心。</li>
<li>人不能只为他自己而活。我们必须认知所有的生命都是珍贵的，而我们和所有的生命是结合在一起的。这种认知指引了我们心灵和宇宙的关系。</li>
<li>最近一周，我所做过的最有意义的一件事：<strong>____</strong></li>
<li>永远不要放弃寻找“第三选择”，因为最好的选择，往往来自在更高目标指引下的我们的创造。</li>
<li>婚恋拇指法则：生理上有冲动，精神上受鼓舞，沟通上很流畅。</li>
<li>人生是持续而反复的构造，校正选择，做出建设性的改变。</li>
<li>不管你做了哪个选择，你的某些东西永远不会改变，最终带着你走向目的地的，可能并不是某一个选择，而是那些你不会改变的东西。<h2 id="即刻行动"><a href="#即刻行动" class="headerlink" title="即刻行动"></a>即刻行动</h2></li>
<li>开始并完成一件事情，比做好它更重要。因为只要开始了，你就有机会把它做得更好。</li>
<li>先把必须要做的小时处理掉，使我们保持积极和从容心态的一剂良方。</li>
<li>“精益创业”有个关键概念叫“最小化可行产品”，它指的是可以使用最少的资源、被最快制作出来的、可执行基本功能的、能被用户使用的实验性产品。创业者应该尽快把最小化可行产品发布出去，然后根据用户使用它的反馈来进行优化，这一过程称为“构建-测量-学习”的循环。</li>
<li>成熟心智的一个特点就是，它能不偏不倚地、公正地对待自己和其他人的意见，既不固步自封也不附和盲从。</li>
<li>多线程工作，首先需要一段专注不受干扰的时间，完成工作中最核心部分的思考。</li>
<li>行动后要及时反思，并梳理这件事情的“反应连”，特别关注其中发生的意外现象。<h2 id="怎样的学习，才能够直面现实"><a href="#怎样的学习，才能够直面现实" class="headerlink" title="怎样的学习，才能够直面现实"></a>怎样的学习，才能够直面现实</h2></li>
<li>学习，应该以学习者心中的问题未中心，让问题引导着我们去探求答案。</li>
<li>不要只做信息的搬运工，通过解码，深入事物的深层。</li>
<li>伟大的艺术作品，常常有很深厚的内涵和很精巧细微的技法，不论你在哪个或深或浅的层次上解读他，他都能呈现出美妙的意味，但如果你不做一番细心的努力和挖掘，就只能尝到最表层的那一小部分味道。</li>
<li>教育心理学家把在某一领域有专长的人士，分为“常规性专长”和“适应性专长”。</li>
<li>求职分为三个层次：信息、知识和技能、技能是学习的终点，信息和知识是迈向这个终点的路河桥。</li>
<li>利用交替运用意识和潜意识进行创造性思考。<h2 id="向未知的无限逼近"><a href="#向未知的无限逼近" class="headerlink" title="向未知的无限逼近"></a>向未知的无限逼近</h2></li>
<li>简化思维意味着我们既要简化外界输入的信息，也要简化我们表达出来的信息，更要简化我们一直思考着的信息。</li>
<li>如何过滤没有价值的信息：精选可信赖的信息源、不追逐当下流行或过热的信息、重事实信息，轻观点和评论、定期闭关，屏蔽外界纷扰。</li>
<li>用足够多的资料“喂养”潜意识。</li>
<li>比如整理书柜并更换一种新的图书分类方法，或者改变日常上下班的路线去探索一条从未走过的路线，也可以尝试与不同的同学或同事共进午餐等，这些小变化引起的扰动可能会刺激出我们新的想法。</li>
<li>把思维转化为外显图形，为我们的思考扩展出了一个更大的空间。</li>
<li>现实中的问题，总是牵涉太多的因素，借助矩阵、清单等工具可以完善思考的周密程度。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>我知道</th>
<th>我不知道</th>
</tr>
</thead>
<tbody><tr>
<td>别人知道</td>
<td>公开区</td>
<td>盲区</td>
</tr>
<tr>
<td>别人不知道</td>
<td>隐秘区</td>
<td>未知区</td>
</tr>
<tr>
<td>* 为了让思维更好的发散，获得更多的灵感，一是要关掉大脑里评论的空间，而是要适当的引入混乱与随机。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 一个具有高度可塑性的大脑在良好思维工具的辅助下，在持续不断的行动的打磨中，会强大的超出你的想象。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>## 努力，是一种最需要学习的才能</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 努力不是一场意志力的较量，而是一种需要学习的策略，可以不断学习和优化。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 在心理学家眼中，“才能”被定义为“自发地重复出现且可悲高效利用的思维、情感或行为模式。”</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 以大多数人的努力程度之低，根本轮不到拼天赋。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 挑战是设计出来的，不断为自己设计“必要的难度”挑战。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 不痛苦地坚持到底，只有深入下去，才能培养出真正的兴趣。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 因努力而热爱。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 把时间投放在一个领域，以尽量高的标准要求自己，培养出非常高的才能。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>## 每一个成功者，都是唯一的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 创造成功，而不是复制成功。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 做一个积极的预设判断要优于消极的预设判断。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 尝试可能会犯错，可能会遭遇失败，但失败是包含信息的，甚至比成功包含的信息量更大。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 一个自我教育者应该学会定期审视自己的所知和未知，能评估自己所学知识的价值，特别是在实践领域中的价值。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 在现实世界中思考理论问题，在理论世界中思考现实问题。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 为大众带来新鲜的见解和启发，形成对公众的影响力。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 抗拒自己的欲望，或者延迟满足欲望。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 根据自己的内心需求，而不是外界的认同，作出独立的选择，甚至去做一些酷的事情。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 如果你找到了一条别人都还没走过的路，只要把这条路走完，你就赢了。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Cocoapods管理私有库组件</title>
    <url>/2018/08/30/private-Cocoapods/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1059465-ab8debcc283dcc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cocoapods.png"></p>
<p>CocoaPods是OS X和iOS下的一个第三方开源类库管理工具，通过CocoaPods工具我们可以为项目添加依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。它是目前iOS开发中使用最广泛的开源库管理工具，如果我们内部协作的组件化能够使用这种方式管理的话，那将是很便利的。<br>在通过Cocoapods建立内部私有库之前，我们需要再熟悉下Cocoapods的工作流程，我们创建内部私有库时也会依照这个流程来。</p>
<a id="more"></a>
<blockquote>
<p>本文目录<br>一、Cocoapods的工作流程<br>二、建立Cocoapods私有库<br>三、使用私有库<br>四、问题总结</p>
</blockquote>
<h2 id="Cocoapods工作流程"><a href="#Cocoapods工作流程" class="headerlink" title="Cocoapods工作流程"></a>Cocoapods工作流程</h2><p>工作流程如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-4799e6f105e76e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cocoapods_work_flows"></p>
<h3 id="远程索引库："><a href="#远程索引库：" class="headerlink" title="远程索引库："></a>远程索引库：</h3><p>这里存放了各个框架的描述文件，托管在github上：<br><a href="https://github.com/CocoaPods/Specs">CocoaPods/Specs</a></p>
<h3 id="本地索引库："><a href="#本地索引库：" class="headerlink" title="本地索引库："></a>本地索引库：</h3><p>在安装cocoapods时，执行的<code>pod setup</code>就是讲远程索引克隆到本地，本地索引的目录为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;.cocoapods&#x2F;repos&#x2F;master</span><br></pre></td></tr></table></figure>
<p>本地索引和远程索引的目录一致，结构如下：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-de2a30d6996c2107.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="localRepo.png"></p>
<p>每个库的每个版本都对应一个json格式的描述文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;YYImage&quot;,</span><br><span class="line">&quot;summary&quot;: &quot;Image framework for iOS to display&#x2F;encode&#x2F;decode animated WebP, APNG, GIF, and more.&quot;,</span><br><span class="line">&quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">&quot;license&quot;: &#123;</span><br><span class="line">&quot;type&quot;: &quot;MIT&quot;,</span><br><span class="line">&quot;file&quot;: &quot;LICENSE&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;authors&quot;: &#123;</span><br><span class="line">&quot;ibireme&quot;: &quot;ibireme@gmail.com&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;social_media_url&quot;: &quot;http:&#x2F;&#x2F;blog.ibireme.com&quot;,</span><br><span class="line">&quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;ibireme&#x2F;YYImage&quot;,</span><br><span class="line">&quot;platforms&quot;: &#123;</span><br><span class="line">&quot;ios&quot;: &quot;6.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;source&quot;: &#123;</span><br><span class="line">&quot;git&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;ibireme&#x2F;YYImage.git&quot;,</span><br><span class="line">&quot;tag&quot;: &quot;1.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;requires_arc&quot;: true,</span><br><span class="line">&quot;default_subspecs&quot;: &quot;Core&quot;,</span><br><span class="line">&quot;subspecs&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;Core&quot;,</span><br><span class="line">&quot;source_files&quot;: &quot;YYImage&#x2F;*.&#123;h,m&#125;&quot;,</span><br><span class="line">&quot;public_header_files&quot;: &quot;YYImage&#x2F;*.&#123;h&#125;&quot;,</span><br><span class="line">&quot;libraries&quot;: &quot;z&quot;,</span><br><span class="line">&quot;frameworks&quot;: [</span><br><span class="line">&quot;UIKit&quot;,</span><br><span class="line">&quot;CoreFoundation&quot;,</span><br><span class="line">&quot;QuartzCore&quot;,</span><br><span class="line">&quot;AssetsLibrary&quot;,</span><br><span class="line">&quot;ImageIO&quot;,</span><br><span class="line">&quot;Accelerate&quot;,</span><br><span class="line">&quot;MobileCoreServices&quot;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;WebP&quot;,</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">&quot;YYImage&#x2F;Core&quot;: [</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;ios&quot;: &#123;</span><br><span class="line">&quot;vendored_frameworks&quot;: &quot;Vendor&#x2F;WebP.framework&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="本地索引文件"><a href="#本地索引文件" class="headerlink" title="本地索引文件"></a>本地索引文件</h3><p>当执行pod search命令时，如果本地索引不存在，就会创建出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod search afn</span><br><span class="line">Creating search index for spec repo &#39;master&#39;..</span><br></pre></td></tr></table></figure>
<p>本地索引文件路径为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;Library&#x2F;Cache&#x2F;Cocoapods&#x2F;Pods</span><br></pre></td></tr></table></figure>
<h3 id="远程框架库"><a href="#远程框架库" class="headerlink" title="远程框架库"></a>远程框架库</h3><p>以YYImage为例，它的远程框架库就是json文件中的source：<br><a href="https://github.com/ibireme/YYImage.git">https://github.com/ibireme/YYImage.git</a></p>
<p>所以再用文字总结下Cocoapods工作流程大概就是<br>1、本地安装cocoapods，建立本地索引库和远程索引库的映射<br>2、本地项目pod install<br>3、查找本地索引文件，然后找到各个库对应版本的json文件<br>4、通过json文件source字段找到引用库的git地址<br>5、把库文件拉到本地项目</p>
<h2 id="建立Cocoapods私有库（framework）"><a href="#建立Cocoapods私有库（framework）" class="headerlink" title="建立Cocoapods私有库（framework）"></a>建立Cocoapods私有库（framework）</h2><p>建议采用framework的形式创建私有库，这可以很好的在开发阶段检查出库的不兼容或者文件权限出现的问题，Swift编写的代码通过Cocoapods生成的都是framework。</p>
<h3 id="0、准备工作："><a href="#0、准备工作：" class="headerlink" title="0、准备工作："></a>0、准备工作：</h3><p><strong>如何建立远程索引库</strong><br>首先我们需要建立一个内部的远程索引库，类似<code>Cocoapods/Spec</code>的功能，之后添加的库文件索引文件都会存放到这里：<a href="https://zhangferry@bitbucket.org/sealcn/sealrepo.git">https://zhangferry@bitbucket.org/sealcn/sealrepo.git</a><br>建立本地和远程索引仓库的关联：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod repo add SealRepo https:&#x2F;&#x2F;zhangferry@bitbucket.org&#x2F;sealcn&#x2F;sealrepo.git</span><br></pre></td></tr></table></figure>
<p>执行<code>pod repo</code><br><img src="https://upload-images.jianshu.io/upload_images/1059465-bc4880496ed40db6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="91bd1bf2.png"></p>
<p>可以看到我们有了两个索引仓库，可以去在这个目录<code>~/.cocoapods/repos</code>看到我们刚建立的SealRepo。</p>
<p><strong>如何组织文件结构</strong><br>我们可以看下<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>的文件组织结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1059465-a2e182ab582670fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们看到这几个文件：</p>
<ul>
<li><code>Source</code>用于存放Framework源文件，</li>
<li><code>Example</code>用于放Demo项目</li>
<li><code>docs</code>和<code>Documentation</code>放说明文档，这个是可选的，</li>
<li><code>Tests</code>测试文件也是可选。<br>我们制作私有库时会仿照这个格式。<h3 id="一、制作framework"><a href="#一、制作framework" class="headerlink" title="一、制作framework"></a>一、制作framework</h3><img src="https://upload-images.jianshu.io/upload_images/1059465-273e8e64bfbb617d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3f2a44c9.png"></li>
</ul>
<p>因为是Swift的工程，接口的开放直接通过open、public等关键字指定，所以工程中的ABTest.h头文件可以删除，加入我们自己的库文件。<br><img src="https://upload-images.jianshu.io/upload_images/1059465-312ee35e4b2f5ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5f8d2d4d.png"><br>注意：在写公有库文件时，对外界开放的属性，方法需要带上<code>public</code>或者<code>open</code>关键字。</p>
<h3 id="二、添加Example工程"><a href="#二、添加Example工程" class="headerlink" title="二、添加Example工程"></a>二、添加Example工程</h3><p>通过Xcode菜单栏<code>File-&gt;New-&gt;Target...</code>添加一个Example工程。<br><strong>引入第三方库</strong><br>如果无第三库引用可以跳过这一步。<br>注意：引入Podfile文件，需要framework和Example两个target都添加上。<br><strong>测试项目</strong><br>需要先编译framework，没有问题之后，导入到Demo项目里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ABTest</span><br></pre></td></tr></table></figure>
<p>运行Dome，测试开发功能有没有问题。</p>
<p><strong>push项目到远程库</strong><br>如果已经关联过远程私有仓库，这一步可以跳过。<br>在远程配置一个git地址，然后将本地项目关联到远程私有仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 仓库地址</span><br></pre></td></tr></table></figure>
<p>如过是首次关联远程仓库，在push之前我们一般需要先拉去远程分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p>如果提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There is no tracking information for the current branch.</span><br></pre></td></tr></table></figure>
<p>那是因为本地库和远程库没有建立联系，git认为这两个仓库可能不是同一个，如果我们确认对应库没问题，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>
<p>将远程库文件强制拉到本地仓库。<br>之后再执行push命令将项目推到远程仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="三、Cocoapods配置文件"><a href="#三、Cocoapods配置文件" class="headerlink" title="三、Cocoapods配置文件"></a>三、Cocoapods配置文件</h3><p><strong>1、添加.swift-version</strong><br>.swift-version文件用来告诉cocoapods当前文件swift的版本，用命令行建立：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;3.0&quot; &gt; .swift-version</span><br></pre></td></tr></table></figure>
<p><strong>2、添加LICENSE</strong><br>每个使用cocoapods添加的库都需要准守开源协议，一般是<code>MIT</code>协议，因为bitbucket没法自动生成，我们可以手动生成这个同名文件，然后把协议内容复制进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIT License</span><br><span class="line"></span><br><span class="line">Copyright (c) [year] [fullname]</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure>
<p><strong>3、创建库描述文件</strong><br>可以通过命令行生成描述文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod spec create ABTest</span><br></pre></td></tr></table></figure>
<p>然后我们编辑ABTest.podspec文件，可以仿照下面的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">s.name         &#x3D; &quot;ABTest&quot;</span><br><span class="line">s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">s.summary      &#x3D; &quot;ABTest with Firebase&quot;</span><br><span class="line">s.description  &#x3D; &quot;This is a ABTest Framworks on swift&quot;</span><br><span class="line">s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;bitbucket.org&#x2F;sealcn&#x2F;remoteabtest&#x2F;src&#x2F;master&#x2F;&quot;</span><br><span class="line">s.license      &#x3D; &#123; :type &#x3D;&gt; &quot;MIT&quot;, :file &#x3D;&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line">s.author             &#x3D; &#123; &quot;zhangferry&quot; &#x3D;&gt; &quot;zhangfei@dailyinnovation.biz&quot; &#125;</span><br><span class="line"></span><br><span class="line"># ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">s.platform     &#x3D; :ios, &quot;8.0&quot;</span><br><span class="line"># ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">s.source       &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;zhangferry@bitbucket.org&#x2F;sealcn&#x2F;remoteabtest.git&quot;, :tag &#x3D;&gt; s.version &#125;</span><br><span class="line">s.source_files  &#x3D; &quot;Source&quot;, &quot;Source&#x2F;*.swift&quot;</span><br><span class="line"></span><br><span class="line"># ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line"># s.resource  &#x3D; &quot;icon.png&quot;</span><br><span class="line"># s.resources &#x3D; &quot;Resources&#x2F;*.png&quot;</span><br><span class="line"></span><br><span class="line"># ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">s.requires_arc &#x3D; true</span><br><span class="line">s.static_framework &#x3D; true</span><br><span class="line">s.dependency &quot;Firebase&#x2F;Core&quot;</span><br><span class="line">s.dependency &quot;Firebase&#x2F;RemoteConfig&quot;</span><br><span class="line">#s.ios.vendored_frameworks &#x3D; &quot;ABTest.framework&quot;</span><br><span class="line">s.xcconfig &#x3D; &#123; &#39;SWIFT_INCLUDE_PATHS&#39; &#x3D;&gt; &#39;$(PODS_ROOT)&#x2F;Firebase&#x2F;CoreOnly&#x2F;Sources&#39; &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>此时我们的文件目录看起来应该大概是这个样子：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-22fe03c83eebed9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="framework_catalog.png"></p>
<p><strong>4、验证本地<code>podspec</code>文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod lib lint</span><br></pre></td></tr></table></figure>
<p>该命令用于检查podspec文件书写是否正确，如果有error需要解决，warning可以不用管（可能会遇到较多问题，需耐心解决0。0）。解决之后再次运行检查命令，当命令行显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; ABTest (0.0.1)</span><br><span class="line">ABTest passed validation.</span><br></pre></td></tr></table></figure>
<p>说明我们本地配置成功了，到这里本地的第一个版本就算完成了！<br>然后我们需要将本次修改提交打上tag，提交到远程仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;build v0.0.1&quot;</span><br><span class="line">git push origin master</span><br><span class="line">git tag 0.0.1</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<p><strong>5、验证远程索引文件</strong><br>上传代码成功之后，我们需要再次验证它跟远程仓库（ABTest远程库和.podspec）是否匹配正确，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure>
<p>当出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABTest.podspec passed validation</span><br></pre></td></tr></table></figure>
<p>时，说明我们远程仓库匹配正确。</p>
<p><strong>6、提交podspec文件到SpecsRepo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod repo push SealRepo ABTest.podspec</span><br></pre></td></tr></table></figure>
<p>这个命令会包含<code>pod spec lint</code>命令，验证通过之后，会添加.podspec文件到本地索引库：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1059465-8df2158ae8033cfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7dffd809.png"></p>
<p>和远程索引库：<br><img src="https://upload-images.jianshu.io/upload_images/1059465-749a69f468b86656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7e052503.png"></p>
<h2 id="使用私有库"><a href="#使用私有库" class="headerlink" title="使用私有库"></a>使用私有库</h2><h3 id="引用私有库"><a href="#引用私有库" class="headerlink" title="引用私有库"></a>引用私有库</h3><p>我们可以像使用其他库文件一样在Podfile文件中添加使用私有库了，引入方法有两种：</p>
<p><strong>1、全局添加</strong><br>在Podfile文件最上面添加一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;zhangferry@bitbucket.org&#x2F;sealcn&#x2F;sealrepo.git&#39;</span><br></pre></td></tr></table></figure>
<p>注意：如果私有仓库和cocoapods仓库出现同名库，会出现不可预期的情况（随机拉下来公有库或者私有库文件）。这时我们需要使用单独添加的方式。</p>
<p><strong>2、单独添加</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;ABTest&#39;, :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;zhangferry@bitbucket.org&#x2F;sealcn&#x2F;remoteabtest.git&#39;</span><br></pre></td></tr></table></figure>
<p>使用时通过import方法导入库就可以了。</p>
<h3 id="更新私有库"><a href="#更新私有库" class="headerlink" title="更新私有库"></a>更新私有库</h3><p>当我们需要升级私有库，添加或者修改方法时，只需要：</p>
<p>1、修改<code>.podspec</code>文件中<code>s.version</code>的版本号</p>
<p>2、提交本地修改至远程，打上对应tag</p>
<p>3、使用项目的工程执行<code>pod update</code></p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>1、pod search 查不到本地库<br>这个可能是cocoadpods本身问题，pod install安装没有问题</p>
<p>2、更新了版本，但是pod update没有找到<br>我们可以采用如下形式，手动指定版本号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;ABTest&#39;, :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;zhangferry@bitbucket.org&#x2F;sealcn&#x2F;remoteabtest.git&#39;, :tag &#x3D;&gt; &#39;0.0.4&#39;</span><br></pre></td></tr></table></figure>

<p>3、提示<code>The &#39;Pods-App&#39; target has transitive dependencies that include static binaries</code><br>这是因为引入的库被编译成了静态库，我们可以在<code>.podspec</code>文件中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.static_framework &#x3D; true</span><br></pre></td></tr></table></figure>

<p>4、引入的第三方库，在<code>pod lint</code>时提示找不到<br>可以手动指定pod目录，将firsebase替换成你的库文件路径:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.xcconfig &#x3D; &#123; &#39;SWIFT_INCLUDE_PATHS&#39; &#x3D;&gt; &#39;$(PODS_ROOT)&#x2F;Firebase&#x2F;CoreOnly&#x2F;Sources&#39; &#125;</span><br></pre></td></tr></table></figure>

<p>5、提示source_files对应文件为空<br>每次<code>pod lint</code>时都是根据版本号进行查找的，可以检查下当前修改跟版本号是否对应。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS技能图谱</title>
    <url>/2018/08/09/skill-map/</url>
    <content><![CDATA[<p>结合目前遇到过的一些技术点和唐巧的<a href="https://gist.github.com/tangqiaoboy/5fadd9ba398277680b87">iOS技能图谱</a>产出的这个综合版的iOS技能图谱，供大家参考交流：<br><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fu22z7y8dzj31kw29le2m.jpg" alt="iOS技能图谱"></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年七月</title>
    <url>/2018/08/06/201807-summary/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1059465-64df1811bbc768eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="十渡"></p>
<p>虽然一直都有想要保持写日记的习惯，但是对于我这种上班时间不稳定切偏晚，经常11点12点才能离开公司的人，就更难了。但如果不写点什么，总感觉这段时间就丢失了，往会看的时候会产生一种失落感。于是找到一种折中的方案，索性把时间跨度拉大一点，一个月写一篇总结。东西就放在简书上，会和博客同步。不管产出的东西多少，希望这个习惯能尽可能长的保持下去。</p>
<a id="more"></a>
<h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>七月份一直在维护冥想类的新产品Peace，七月份上的线，一周一个版本，目前是1.3了。从最开始的数据不理想，到分析投放数据，开会讨论找问题，对比竞品，找到问题，指定解决方案，快速迭代，产品在越来越好，数据也在越来越好。我也在这个过程中全程目睹了一个新产品的发展历程，这种体验可以说是一件很棒的事了。<br>但是这段时间也是最忙的一段时期，一周一版一点也不轻松。排期排到周五，就不管多晚周五那天（甚至是已经周六）都要发版的，最晚的一次是战斗到夜里一点。随后老大也调整了策略，多留出一天时间，进行codereview，排期不再那么满，但是快速迭代的节奏还是要一直保持的。<br>说下最近的能力问题，项目中磨练了很多，踩了很多坑，也总结掌握了一些经验，但并不能感觉到自己已经达到了何种地步。都是碎片化的知识点，知识面不系统，也没法找到一个系统的东西去参考，说自己掌握了那些还差那些。直到遇到了技能图谱这个东西，代表个人能力的技能树。于是参考网上的iOS技能图谱，自己做了一个图谱。瞬间思路也清晰了，以后的博客内容，学习内容就可以根据这个东西来了。</p>
<h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>生活方面，园区正在组织篮球赛，我作为篮球队的一员在比赛的一个月之前，就已经开始训练了，一周一次两小时的训练。体育这个东西一直以来也是我心心念的小梦想，怎么说呢，虽然不是运动员，但运动本身总能给我带来不一样的，超出我自身限制的体验。我以前总幻想可能这就是兴趣吧，我喜欢这个，但成熟之后，想法就变成了，体育没那么简单，作为一个爱好就够了。<br>当运动员的梦想渐行渐远时，去年和今年的两场半程马拉松，又把这个心结给勾了出来，两场比赛都完赛时，那种巨大的满足感，只有两个字可以形容，贼舒服！<br>话题拉回来，渐渐的也迎来了篮球联赛的正式比赛，小组赛6进2，我们打了两场，一胜一负。我当了一场主力，虽然表现一般，只为球队贡献了6分，但也算是战斗到最后一刻。很荣幸啦，那种奔跑如风的感觉，观众为自己加油喝彩的感觉，不管结果怎样，我都享受到了比赛了。</p>
<h3 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h3><p>去了趟天津，见自己高中时的死党，大家，一起吃饭喝酒，谈论工作，结婚，房价。想起高中时，我们几个因为食堂没有座位蹲在一起吃饭场景，恍若隔日啊。<br>和女朋友去了趟十渡，玩了标志性的玻璃栈道，高山漂流，抗日英雄纪念馆，十渡风景也很美。其中高山漂流一路冲下来，身上湿了一大半，遇到一个小朋友，说“你们怕水吗？”我还没弄明白怎么回事就说了句“不怕啊”，他就跟妈妈一起开始向我俩泼水了。这熊孩子，跟我刚！当自己放下顾忌，肆无忌惮地疯玩时，这才是真正的快乐吧。<br>关于自身的成长，感觉自己自律性还是差一些，坏习惯多一些，我能感觉到坏习惯对我形成的阻力，但是要完全克服或者完全抹掉还是需要相当一段时间努力的。<br>我也在排除一些对自己产生干扰的外界因素，卸载了手机里让我耗费时间的王者荣耀，刺激战场，头条系产品。当拿起手机发现没什么可玩时，我能感受到自己时间是富余的。<br>就这些吧，希望自己能一直遵从内心，成为那个让自己满意的人。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发月报#1|201807</title>
    <url>/2018/08/02/monthly_1/</url>
    <content><![CDATA[<h2 id="关闭隐式动画"><a href="#关闭隐式动画" class="headerlink" title="关闭隐式动画"></a>关闭隐式动画</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CATransaction</span>.begin()</span><br><span class="line"><span class="type">CATransaction</span>.setDisableActions(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">self</span>.layer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line"><span class="type">CATransaction</span>.commit()</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="AVPlayer出现一直缓存，缓存一段时间之后才开始播放的问题"><a href="#AVPlayer出现一直缓存，缓存一段时间之后才开始播放的问题" class="headerlink" title="AVPlayer出现一直缓存，缓存一段时间之后才开始播放的问题"></a>AVPlayer出现一直缓存，缓存一段时间之后才开始播放的问题</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">player.automaticallyWaitsToMinimizeStalling = <span class="literal">false</span><span class="comment">//延迟播放，默认开</span></span><br></pre></td></tr></table></figure>
<p>关于这个属性的一些说明：</p>
<blockquote>
<p>In versions of iOS prior to iOS 10.0 and versions of OS X prior to 10.12, this property is unavailable, and the behavior of the AVPlayer corresponds to the type of content being played. For streaming content, including HTTP Live Streaming, the AVPlayer acts as if automaticallyWaitsToMinimizeStalling is YES. For file-based content, including file-based content accessed via progressive http download, the AVPlayer acts as if automaticallyWaitsToMinimizeStalling is NO.</p>
</blockquote>
<p>大致是说在iOS10之前的客户端，虽然这个参数不可用，但是非流媒体类型的播放这个配置默认为false，所以在iOS10下建议这个属性值为false。</p>
<h2 id="AVPlayer是否正在播放的判断"><a href="#AVPlayer是否正在播放的判断" class="headerlink" title="AVPlayer是否正在播放的判断"></a>AVPlayer是否正在播放的判断</h2><p>当我们使用KVO监听player.rate来判断player的是否正在播放时，会发现这个值是不准的。其实准确的说是<code>player.rate=1</code>不代表正在播放，<code>player.rate=0</code>是可以代表正在暂停的。所以<code>player.rate=0</code>代表暂停，正在播放的状态可以这样判断：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.timeObserve = <span class="keyword">self</span>.player.addPeriodicTimeObserver(forInterval: <span class="type">CMTimeMake</span>(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">queue: <span class="type">DispatchQueue</span>.main,</span><br><span class="line">using: &#123;(time) <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.player.timeControlStatus == <span class="type">AVPlayerTimeControlStatus</span>.playing &#123;</span><br><span class="line"><span class="comment">//AVPlayerTimeControlStatus为iOS之后的API</span></span><br><span class="line"><span class="keyword">self</span>.state = .playing</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="下载时URLSessionConfiguration的配置"><a href="#下载时URLSessionConfiguration的配置" class="headerlink" title="下载时URLSessionConfiguration的配置"></a>下载时URLSessionConfiguration的配置</h2><p>使用Alamofire下载时，我们通常需要一个<code>SessionManager</code>配置下载参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">configuration.timeoutIntervalForRequest = <span class="number">50</span><span class="comment">//50s超时</span></span><br><span class="line"><span class="comment">/** 最大同时下载数 ---- iOS对于同一个IP服务器的并发最大默认为4，OS X为6 */</span></span><br><span class="line">configuration.httpMaximumConnectionsPerHost = <span class="number">4</span></span><br><span class="line"><span class="comment">/** A Boolean value that indicates whether TCP connections should be kept open when the app moves to the background. */</span></span><br><span class="line">configuration.shouldUseExtendedBackgroundIdleMode = <span class="literal">true</span><span class="comment">//为true支持后台下载</span></span><br><span class="line">manager = <span class="type">Alamofire</span>.<span class="type">SessionManager</span>(configuration: configuration)</span><br></pre></td></tr></table></figure>
<h2 id="不要存储沙盒绝对地址"><a href="#不要存储沙盒绝对地址" class="headerlink" title="不要存储沙盒绝对地址"></a>不要存储沙盒绝对地址</h2><p>当我们向沙盒写入数据时，将该绝对路径保存下来，下次再打开该地址并不会获取到我们存入的数据。原因如下：</p>
<p>iOS8之后，苹果添加的新特性，将每次打开app内的沙盒［唯一编码路径］（红框部分）重新生成，并保持上一次的沙盒文件（Documents、Library、tmp）移到新生成的文件内，旧文件删除，就是说，你保存的文件都在，只不过每次打开后，都会有一个新的绝对路径。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ftvc9rh18lj30gu080wk9.jpg" alt="localPath.png"><br>所以存储路径应该存相对路径：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这两个都代表document的相对路径</span></span><br><span class="line"><span class="keyword">let</span> rootPath = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/"</span></span><br><span class="line"><span class="keyword">let</span> rootPath = <span class="type">NSSearchPathForDirectoriesInDomains</span>(.documentDirectory, .userDomainMask, <span class="literal">true</span>).first</span><br></pre></td></tr></table></figure>
<h2 id="childViewController的viewDidAppear方法调用"><a href="#childViewController的viewDidAppear方法调用" class="headerlink" title="childViewController的viewDidAppear方法调用"></a>childViewController的viewDidAppear方法调用</h2><p>如果一个ViewController中嵌套了多个childViewController。当宿主VC（我们暂且这么称呼它）调用viewDidAppear等方法时，其中的childViewController都会默认调用对应方法。如果我们不想childViewController调用该方法可以重写该VC的属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> shouldAutomaticallyForwardAppearanceMethods: <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片切换渐入渐出的方法"><a href="#图片切换渐入渐出的方法" class="headerlink" title="图片切换渐入渐出的方法"></a>图片切换渐入渐出的方法</h2><p>通过<code>UIImageView</code>展示图片和<code>layer.contents</code>展示图片都可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let transition = <span class="built_in">CATransition</span>()</span><br><span class="line">transition.duration = <span class="number">0.5</span></span><br><span class="line">transition.type = kCATransitionFade</span><br><span class="line"><span class="keyword">self</span>.view.layer.add(transition, forKey: <span class="string">"layer.contents"</span>)</span><br><span class="line"><span class="keyword">self</span>.view.layer.contents = image.cgImage<span class="comment">//适用于imageView</span></span><br></pre></td></tr></table></figure>

<h2 id="cell移出视图，移入视图的方法"><a href="#cell移出视图，移入视图的方法" class="headerlink" title="cell移出视图，移入视图的方法"></a>cell移出视图，移入视图的方法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TableViewCell</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.prepareForReuse()<span class="comment">//使用重用池的cell,显示过的cell移至可视范围</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TableView</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line"><span class="comment">//cell移出视图时调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tableview-collectionView数据reload之后的操作"><a href="#tableview-collectionView数据reload之后的操作" class="headerlink" title="tableview,collectionView数据reload之后的操作"></a>tableview,collectionView数据reload之后的操作</h2><p>我们如果要想实现在reload之后弹出alertView，或者滚动到特定一行，可能会直接写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView.reloadData()</span><br><span class="line">tableView.scrollToRow(at: indexPath, at: .middle, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>看似没问题，但是滚动没起作用，因为reloadData是立即返回的，不会等tableview刷新完成。<br>解决办法就是需要等reload完成之后再做我们需要的操作，reload是否完成有几种方式监听：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//collectionView</span></span><br><span class="line">collectionView.performBatchUpdates(<span class="literal">nil</span>) &#123; (finished) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//reload完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tableView方法只有iOS11可用</span></span><br><span class="line">tableView.performBatchUpdates(<span class="literal">nil</span>) &#123; (finished) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//reload完成</span></span><br><span class="line">&#125;<span class="comment">//替代func beginUpdates()，func endUpdates()</span></span><br><span class="line"><span class="comment">//tableView等reload完成还可以使用</span></span><br><span class="line">tableView.reloadData()</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="comment">//reload完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>月报</tag>
      </tags>
  </entry>
  <entry>
    <title>可能被忽略的UIButton细节</title>
    <url>/2018/07/17/UIButton-detail/</url>
    <content><![CDATA[<h2 id="关于System-Button"><a href="#关于System-Button" class="headerlink" title="关于System Button"></a>关于System Button</h2><hr>
<p>看一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.setTitle(<span class="string">"Title"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">button.setImage(<span class="type">UIImage</span>(named: <span class="string">"icon"</span>), <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure>

<p>buttonType分别设置为system和custom，仅做如上设置，显示效果对比（上面的custom，下面的是system）</p>
<div align=center>
![button_normal](https://ws4.sinaimg.cn/large/006tKfTcgy1ftcrof65cij305x00xa9u.jpg)
![button_system](https://ws1.sinaimg.cn/large/006tKfTcgy1ftcrokww28j305x010q2r.jpg)
</div>
system Button显示出蓝色其实是tintColor的效果，关于tintColor的说法是：
<a id="more"></a>
This property has no default effect for buttons with type custom. For custom buttons, you must implement any behavior related to tintColor yourself.

<p>在custom类型的button中设置tintColor是不生效的，需要自定义样式。在system类型的button里有一个默认蓝色的tintColor，当然我们可以修改它为其他颜色，会对image和title同时生效。</p>
<p>另外可以发现image不是原始图片，而是被填充为tintColor的颜色。这是因为system类型下button的image被默认以<code>alwaysTemplate</code>类型渲染的，如果想要显示原始图片可以做如下操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"icon"</span>)?.withRenderingMode(.alwaysOriginal)</span><br><span class="line">button.setImage(image, <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure>

<h2 id="关于触摸反馈"><a href="#关于触摸反馈" class="headerlink" title="关于触摸反馈"></a>关于触摸反馈</h2><hr>
<p>看一个常见的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>()<span class="comment">//默认样式custom</span></span><br><span class="line">button.setTitle(<span class="string">"Title"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">button.setTitleColor(<span class="type">UIColor</span>.blue, <span class="keyword">for</span>: .normal)</span><br><span class="line">button.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">view.addSubview(button)</span><br></pre></td></tr></table></figure>

<p>以上是的button的常见写法。遗憾的是这种写法，不会带触摸反馈效果。那如果我们想加触摸反馈，需要如何处理：</p>
<h3 id="1、仅文字的触摸反馈"><a href="#1、仅文字的触摸反馈" class="headerlink" title="1、仅文字的触摸反馈"></a>1、仅文字的触摸反馈</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//system:</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">button.setTitleColor(<span class="type">UIColor</span>.blue, <span class="keyword">for</span>: .normal)<span class="comment">//自动添加反馈效果</span></span><br><span class="line">button.setTitleColor(<span class="type">UIColor</span>.green, <span class="keyword">for</span>: .highlighted)<span class="comment">//会和系统效果叠加，不可控，不建议写</span></span><br><span class="line"><span class="comment">//custom</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .custom)</span><br><span class="line">button.setTitleColor(<span class="type">UIColor</span>.blue, <span class="keyword">for</span>: .normal)</span><br><span class="line">button.setTitleColor(<span class="type">UIColor</span>.green, <span class="keyword">for</span>: .highlighted)<span class="comment">//自定义反馈样式</span></span><br></pre></td></tr></table></figure>

<h3 id="2、带图片和文字的触摸反馈"><a href="#2、带图片和文字的触摸反馈" class="headerlink" title="2、带图片和文字的触摸反馈"></a>2、带图片和文字的触摸反馈</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.setTitle(<span class="string">"Title"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">button.setImage(<span class="type">UIImage</span>(named: <span class="string">"icon"</span>), <span class="keyword">for</span>: .normal)</span><br><span class="line"><span class="comment">//system:会同时对图片文字添加反馈效果</span></span><br><span class="line"><span class="comment">//custom:默认仅对图片有触摸反馈</span></span><br></pre></td></tr></table></figure>

<h3 id="3、带背景图的按钮"><a href="#3、带背景图的按钮" class="headerlink" title="3、带背景图的按钮"></a>3、带背景图的按钮</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.setBackgroundImage(<span class="type">UIImage</span>(named: <span class="string">"background"</span>), <span class="keyword">for</span>: .normal)</span><br><span class="line"><span class="comment">//system是按钮整体反馈</span></span><br><span class="line"><span class="comment">//custom是仅背景图片反馈，title，image无反馈</span></span><br></pre></td></tr></table></figure>

<h3 id="4、关闭触摸反馈"><a href="#4、关闭触摸反馈" class="headerlink" title="4、关闭触摸反馈"></a>4、关闭触摸反馈</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.isUserInteractionEnabled = <span class="literal">false</span></span><br><span class="line"><span class="comment">//custome，system均会关闭触摸反馈</span></span><br><span class="line">button.adjustsImageWhenHighlighted = <span class="literal">false</span></span><br><span class="line"><span class="comment">//custom:会关闭image，backgroundImage的反馈</span></span><br><span class="line"><span class="comment">//system:此设置无效</span></span><br></pre></td></tr></table></figure>

<h3 id="5、showsTouchWhenHighlighted"><a href="#5、showsTouchWhenHighlighted" class="headerlink" title="5、showsTouchWhenHighlighted"></a>5、showsTouchWhenHighlighted</h3><p>这个属性是系统提供的一种highlighted样式，点击时按钮高亮。但是效果确实有点丑丑的，基本不用这种效果</p>
<h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="全局修改UIButton的样式可以："><a href="#全局修改UIButton的样式可以：" class="headerlink" title="全局修改UIButton的样式可以："></a>全局修改UIButton的样式可以：</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gobalBtn = <span class="type">UIButton</span>.appearance()<span class="comment">//所有继承UIView的类都可以使用这个方法</span></span><br><span class="line">gobalBtn.setTitle(<span class="string">"Good"</span>, <span class="keyword">for</span>: .normal)<span class="comment">//会将所有button的title改为Good</span></span><br></pre></td></tr></table></figure>

<h3 id="setAttributedTitle方法"><a href="#setAttributedTitle方法" class="headerlink" title="setAttributedTitle方法"></a>setAttributedTitle方法</h3><p>这个方法可以将button的title以富文本的形式进行设置，支持对不同state的设置。需要注意它和setTitle的优先级</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用attributed方式设置button的title和titleColor</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"Title"</span></span><br><span class="line"><span class="keyword">let</span> attributed = <span class="type">NSMutableAttributedString</span>(string: string)</span><br><span class="line"><span class="keyword">let</span> range = <span class="type">NSMakeRange</span>(<span class="number">0</span>, string.<span class="built_in">count</span>)</span><br><span class="line">attributed.addAttributes([<span class="type">NSAttributedStringKey</span>.foregroundColor : <span class="type">UIColor</span>.green], range: range)</span><br><span class="line">button.setAttributedTitle(attributed, <span class="keyword">for</span>: .normal)</span><br><span class="line"><span class="comment">//此时用setTitle重新设置title样式，不会生效，attributed优先级大于直接设置</span></span><br><span class="line">button.setTitle(<span class="string">"Next Button"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">button.setTitleColor(<span class="type">UIColor</span>.blue, <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>AVPlayer详解系列（一）参数设置</title>
    <url>/2017/08/25/avplayer-detail-1/</url>
    <content><![CDATA[<blockquote>
<p>最近工作内容基本都是围绕视频播放展开的，从AVPlayer到IJKPlayer，期间遇到挺多问题，趟了很多bug，也总结了一些心得。对AVPlayer了解的更多一些，因为涉及点比较多，所以打算做一个系列详尽的写一下这部分内容。希望大家多多支持，有问题的地方欢迎指正。</p>
</blockquote>
<a id="more"></a>

<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>先来一张思维导图，作为这篇文章的目录索引：<br><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a294cc5420bd29?w=951&h=435&f=png&s=53547" alt="AVPlayer.png"></p>
<h2 id="为什么使用AVPlayer："><a href="#为什么使用AVPlayer：" class="headerlink" title="为什么使用AVPlayer："></a>为什么使用AVPlayer：</h2><p>首先在iOS平台使用播放视频，可用的选项一般有这四个，他们各自的作用和功能如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>使用环境</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>MPMoviePlayerController</td>
<td>MediaPlayer</td>
<td>简单易用</td>
<td>不可定制</td>
</tr>
<tr>
<td>AVPlayerViewController</td>
<td>AVKit</td>
<td>简单易用</td>
<td>不可定制</td>
</tr>
<tr>
<td>AVPlayer</td>
<td>AVFoundation</td>
<td>可定制度高，功能强大</td>
<td>不支持流媒体</td>
</tr>
<tr>
<td>IJKPlayer</td>
<td>IJKMediaFramework</td>
<td>定制度高，支持流媒体播放</td>
<td>使用稍复杂</td>
</tr>
</tbody></table>
<p>由此可以看出，如果我们不做直播功能<a href="https://developer.apple.com/documentation/avfoundation/avplayer">AVPlayer</a>就是一个最优的选择。</p>
<p>另外AVPlayer是一个可以播放任何格式的全功能影音播放器<br><del>支持视频格式： WMV，AVI，MKV，RMVB，RM，XVID，MP4，3GP，MPG等。</del><br><del>支持音频格式：MP3，WMA，RM，ACC，OGG，APE，FLAC，FLV等。</del><br>支持视频格式： MP4，MOV，M4V，3GP，AVI等。<br>支持音频格式：MP3，AAC，WAV，AMR，M4A等。<br>详见<a href="https://www.jianshu.com/p/7373f07f1cbf">AVPlayer支持的视频格式</a><br>##如何使用<br>AVPlayer存在于AVFoundation框架，我们使用时需要导入：<br><code>#import &lt;AVFoundation/AVFoundation.h&gt;</code></p>
<h3 id="几个播放相关的参数"><a href="#几个播放相关的参数" class="headerlink" title="几个播放相关的参数"></a>几个播放相关的参数</h3><p>在创建一个播放器之前我们需要先了解一些播放器相关的类</p>
<ul>
<li>AVPlayer：控制播放器的播放，暂停，播放速度</li>
<li>AVURLAsset : AVAsset 的一个子类，使用 URL 进行实例化，实例化对象包换 URL 对应视频资源的所有信息。</li>
<li>AVPlayerItem：管理资源对象，提供播放数据源</li>
<li>AVPlayerLayer：负责显示视频，如果没有添加该类，只有声音没有画面</li>
</ul>
<p>我们这片文章就围绕这几个参数展开，光说这些你可能还有点不明白，那我们就围绕一个最简单的播放器做起，一点点扩展功能，在具体讲解这几个参数的作用。</p>
<h3 id="最简单的播放器"><a href="#最简单的播放器" class="headerlink" title="最简单的播放器"></a>最简单的播放器</h3><p>根据上面描述，我们知道<code>AVPlayer</code>是播放的必要条件，所以我们可以构建的极简播放器就是：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *playUrl = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://baobab.wdjcdn.com/14573563182394.mp4"</span>];</span><br><span class="line"><span class="keyword">self</span>.player = [[<span class="built_in">AVPlayer</span> alloc] initWithURL:playUrl];</span><br><span class="line">[<span class="keyword">self</span>.player play];</span><br></pre></td></tr></table></figure>
<p>是不是很简单，只有三行代码！<br>但是它太简单了，仅可以完成音频的播放，连画面都没有。回看上面播放相关类的介绍，是因为缺少<code>AVPlayerLayer</code>；作为一个播放器，我不能只播放一条视频啊，我还想根据需要切换视频，那我们就得把<code>AVPlayerItem</code>也加上。<br>加上这两个属性之后的播放器是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *playUrl = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://baobab.wdjcdn.com/14573563182394.mp4"</span>];</span><br><span class="line"><span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithURL:playUrl];</span><br><span class="line"><span class="comment">//如果要切换视频需要调AVPlayer的replaceCurrentItemWithPlayerItem:方法</span></span><br><span class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:_playerItem];</span><br><span class="line"><span class="keyword">self</span>.playerLayer = [<span class="built_in">AVPlayerLayer</span> playerLayerWithPlayer:<span class="keyword">self</span>.player];</span><br><span class="line"><span class="keyword">self</span>.playerLayer.frame = _videoView.bounds;</span><br><span class="line"><span class="comment">//放置播放器的视图</span></span><br><span class="line">[<span class="keyword">self</span>.videoView.layer addSublayer:<span class="keyword">self</span>.playerLayer];</span><br><span class="line">[_player play];</span><br></pre></td></tr></table></figure>

<p>现在的播放器稍微完整了一些，我们在自己创建的容器里可以看到画面了！</p>
<h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><p>但是它作为一个视频播放器，还是有很多不能让人满意的地方。例如：没有暂停、快进快退、倍速播放等，另外如果遇到url错误是不是还要有播放失败的提示，还有播放完成的相关提示。<br>为完成这些，我们需要对<code>AVPlayerItem</code>和<code>AVPlayerLayer</code>进一步了解一下。</p>
<h3 id="一、AVPlayer的控制"><a href="#一、AVPlayer的控制" class="headerlink" title="一、AVPlayer的控制"></a>一、AVPlayer的控制</h3><p>前面讲过该类是控制视频播放行为的，他的使用比较简单。<br>播放视频：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.player play];</span><br></pre></td></tr></table></figure>
<p>暂停视频：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.player pause];</span><br></pre></td></tr></table></figure>
<p>更改速度：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.player.rate = <span class="number">1.5</span>;<span class="comment">//注意更改播放速度要在视频开始播放之后才会生效</span></span><br></pre></td></tr></table></figure>
<p>还有一下其他的控制，我们可以调转到系统API进行查看</p>
<h3 id="二、AVPlayerItem的控制"><a href="#二、AVPlayerItem的控制" class="headerlink" title="二、AVPlayerItem的控制"></a>二、AVPlayerItem的控制</h3><p>AVPlayerItem作为资源管理对象，它控制着视频从创建到销毁的诸多状态。</p>
<h4 id="1、播放状态-status"><a href="#1、播放状态-status" class="headerlink" title="1、播放状态 status"></a>1、播放状态 status</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">AVPlayerItemStatus</span>) &#123;</span><br><span class="line">    <span class="built_in">AVPlayerItemStatusUnknown</span>,<span class="comment">//未知</span></span><br><span class="line">    <span class="built_in">AVPlayerItemStatusReadyToPlay</span>,<span class="comment">//准备播放</span></span><br><span class="line">    <span class="built_in">AVPlayerItemStatusFailed</span><span class="comment">//播放失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们使用KVO监测playItem.status，可以获取播放状态的变化</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"status"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">```   </span><br><span class="line">在监听回调中：</span><br><span class="line">```objectivec</span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">AVPlayerItem</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"status"</span>]) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (_playerItem.status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="built_in">AVPlayerItemStatusReadyToPlay</span>:</span><br><span class="line">                    <span class="comment">//推荐将视频播放放在这里</span></span><br><span class="line">                    [<span class="keyword">self</span> play];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">case</span> <span class="built_in">AVPlayerItemStatusUnknown</span>:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"AVPlayerItemStatusUnknown"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">case</span> <span class="built_in">AVPlayerItemStatusFailed</span>:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"AVPlayerItemStatusFailed"</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然设置完播放配置我们可以直接调用<code>[self.player play];</code>进行播放，但是更稳妥的方法是在回调收到<code>AVPlayerItemStatusReadyToPlay</code>时进行播放</p>
<h4 id="2、视频的时间信息"><a href="#2、视频的时间信息" class="headerlink" title="2、视频的时间信息"></a>2、视频的时间信息</h4><p>在AVPlayer中时间的表示有一个专门的结构体CMTime</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    CMTimeValue    value;     &#x2F;&#x2F; 帧数</span><br><span class="line">    CMTimeScale    timescale;  &#x2F;&#x2F; 帧率（影片每秒有几帧）</span><br><span class="line">    CMTimeFlags    flags;        </span><br><span class="line">    CMTimeEpoch    epoch;    </span><br><span class="line">&#125; CMTime;</span><br></pre></td></tr></table></figure>
<p>CMTime是以分数的形式表示时间，value表示分子，timescale表示分母，flags是位掩码，表示时间的指定状态。</p>
<p>获取当前播放时间，可以用value/timescale的方式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> currentTime = <span class="keyword">self</span>.playItem.currentTime.value/item.currentTime.timescale;</span><br></pre></td></tr></table></figure>
<p>还有一种利用系统提供的方法，我们用它获取视频总时间：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> totalTime   = <span class="built_in">CMTimeGetSeconds</span>(item.duration);</span><br></pre></td></tr></table></figure>
<p>如果我们想要添加一个计时的标签不断更新当前的播放进度，有一个系统的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)addPeriodicTimeObserverForInterval:(<span class="built_in">CMTime</span>)interval queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> time))block;</span><br></pre></td></tr></table></figure>
<p>方法名如其意， “添加周期时间观察者” ，参数1 interal 为<code>CMTime</code> 类型的，参数2 queue为串行队列，如果传入NULL就是默认主线程，参数3 为<code>CMTime</code> 的block类型。<br>简而言之就是，每隔一段时间后执行 block。<br>比如：我们把interval设置成<code>CMTimeMake(1, 10)</code>，在block里面刷新label，就是一秒钟刷新10次。</p>
<p>正常观察播放进度一秒钟一次就行了，所以可以这么写：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.player addPeriodicTimeObserverForInterval:<span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">1</span>) queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">CMTime</span> time) &#123;</span><br><span class="line">    <span class="built_in">AVPlayerItem</span> *item = WeakSelf.playerItem;</span><br><span class="line">    <span class="built_in">NSInteger</span> currentTime = item.currentTime.value/item.currentTime.timescale;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前播放时间：%ld"</span>,currentTime);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="3、loadedTimeRange-缓存时间"><a href="#3、loadedTimeRange-缓存时间" class="headerlink" title="3、loadedTimeRange  缓存时间"></a>3、loadedTimeRange  缓存时间</h4><p>获取视频的缓存情况我们需要监听playerItem的loadedTimeRanges属性</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loadedTimeRanges"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>在KVO的回调里:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"loadedTimeRanges"</span>])&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = _playerItem.loadedTimeRanges;</span><br><span class="line">    <span class="built_in">CMTimeRange</span> timeRange = [array.firstObject <span class="built_in">CMTimeRangeValue</span>];<span class="comment">//本次缓冲时间范围</span></span><br><span class="line">    <span class="keyword">float</span> startSeconds = <span class="built_in">CMTimeGetSeconds</span>(timeRange.start);</span><br><span class="line">    <span class="keyword">float</span> durationSeconds = <span class="built_in">CMTimeGetSeconds</span>(timeRange.duration); <span class="built_in">NSTimeInterval</span> totalBuffer = startSeconds + durationSeconds;<span class="comment">//缓冲总长度</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前缓冲时间：%f"</span>,totalBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、playbackBufferEmpty"><a href="#4、playbackBufferEmpty" class="headerlink" title="4、playbackBufferEmpty"></a>4、playbackBufferEmpty</h4><p>监听<code>playbackBufferEmpty</code>我们可以获取当缓存不够，视频加载不出来的情况：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"playbackBufferEmpty"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>在KVO回调里：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"playbackBufferEmpty"</span>]) &#123;</span><br><span class="line">   <span class="comment">//some code show loading   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、playbackLikelyToKeepUp"><a href="#5、playbackLikelyToKeepUp" class="headerlink" title="5、playbackLikelyToKeepUp"></a>5、playbackLikelyToKeepUp</h4><p><code>playbackLikelyToKeepUp</code>和<code>playbackBufferEmpty</code>是一对，用于监听缓存足够播放的状态</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"playbackLikelyToKeepUp"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span>([keyPath isEqualToString:<span class="string">@"playbackLikelyToKeepUp"</span>]) &#123;    </span><br><span class="line">    <span class="comment">//由于 AVPlayer 缓存不足就会自动暂停，所以缓存充足了需要手动播放，才能继续播放  </span></span><br><span class="line">    [_player play];      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVURLAsset"><a href="#AVURLAsset" class="headerlink" title="AVURLAsset"></a>AVURLAsset</h3><p>播放视频只需一个url就能进行这样太不安全了，别人可以轻易的抓包盗链，为此我们需要为视频链接做一个请求头的认证，这个功能可以借助AVURLAsset完成。</p>
<p><code>AVPlayerItem</code>除了可以用URL初始化，还可以用<code>AVAsset</code>初始化，而<code>AVAsset</code>不能直接使用，我们看下<code>AVURLAsset</code>的一个初始化方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">@param		URL</span></span><br><span class="line"><span class="comment">	An instance of NSURL that references a media resource.</span></span><br><span class="line"><span class="comment">@param		options</span></span><br><span class="line"><span class="comment">	An instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)URLAssetWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options;</span><br></pre></td></tr></table></figure>
<p><code>AVURLAssetPreferPreciseDurationAndTimingKey.</code>这个key对应的value是一个布尔值, 用来表明资源是否需要为时长的精确展示,以及随机时间内容的读取进行提前准备。</p>
<p>除了这个苹果官方介绍的功能外，他还可以设置请求头，这个算是隐藏功能了，因为苹果并没有明说这个功能，我是费了很大劲找到的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">NSMutableDictionary</span> * headers = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">[headers setObject:<span class="string">@"yourHeader"</span>forKey:<span class="string">@"User-Agent"</span>];</span><br><span class="line"><span class="keyword">self</span>.urlAsset = [<span class="built_in">AVURLAsset</span>   URLAssetWithURL:<span class="keyword">self</span>.videoURL options:@&#123;<span class="string">@"AVURLAssetHTTPHeaderFieldsKey"</span> : headers&#125;];</span><br><span class="line"><span class="comment">// 初始化playerItem</span></span><br><span class="line"><span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:<span class="keyword">self</span>.urlAsset];</span><br></pre></td></tr></table></figure>
<p>补充：后来得知这个参数是非公开的API，但是经多人测试项目上线不受影响。</p>
<h3 id="播放相关通知"><a href="#播放相关通知" class="headerlink" title="播放相关通知"></a>播放相关通知</h3><h4 id="1、声音类："><a href="#1、声音类：" class="headerlink" title="1、声音类："></a>1、声音类：</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声音被打断的通知（电话打来）</span></span><br><span class="line"><span class="built_in">AVAudioSessionInterruptionNotification</span></span><br><span class="line"><span class="comment">//耳机插入和拔出的通知</span></span><br><span class="line"><span class="built_in">AVAudioSessionRouteChangeNotification</span></span><br></pre></td></tr></table></figure>
<p>根据userInfo判断具体状态</p>
<h4 id="2、播放类"><a href="#2、播放类" class="headerlink" title="2、播放类"></a>2、播放类</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//播放完成</span></span><br><span class="line"><span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line"><span class="comment">//播放失败</span></span><br><span class="line"><span class="built_in">AVPlayerItemFailedToPlayToEndTimeNotification</span></span><br><span class="line"><span class="comment">//异常中断</span></span><br><span class="line"><span class="built_in">AVPlayerItemPlaybackStalledNotification</span></span><br></pre></td></tr></table></figure>
<p>对于播放完成的通知我们可以这么写：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(playerMovieFinish:) name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span> object:[<span class="keyword">self</span>.player currentItem]];</span><br></pre></td></tr></table></figure>
<h4 id="3、系统状态"><a href="#3、系统状态" class="headerlink" title="3、系统状态"></a>3、系统状态</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入后台</span></span><br><span class="line"><span class="built_in">UIApplicationWillResignActiveNotification</span></span><br><span class="line"><span class="comment">//返回前台</span></span><br><span class="line"><span class="built_in">UIApplicationDidBecomeActiveNotification</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：所有通知和KVO的使用我们都要记得在不用时remove掉。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>视频播放相关的知识比较多，细节的方面需要一点一点去扣。暂且写这么多吧，以后有需要会及时补充。<br><strong>参考：</strong><br><a href="https://github.com/renzifeng/ZFPlayer">ZFPlayer</a><br><a href="http://liunan.me/2017/01/30/avplayer">AVPlayer那些坑</a><br>如果还有什么不理解的可以简书私信问我，或者查看我写的<a href="https://github.com/zhangferry/FYPlayer">Demo</a>，欢迎star- ( ゜- ゜)つロ乾杯~</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>AVPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题总结（From J_Knight）</title>
    <url>/2017/06/29/interview-question/</url>
    <content><![CDATA[<blockquote>
<p>前一段时间看了<a href="https://knightsj.github.io/">J_Knight</a>的<a href="http://www.jianshu.com/p/56e40ea56813">2017年5月iOS找人心得（附面试题）</a>。作为一个在编程前线奋斗了将近两年的iOS从业人员，面对这些题目时，有些竟感觉生疏，甚至答不上来，很是惭愧。个人感觉，像runtime、线程、信号量相关的偏底层知识虽然平时基本用不到。特别是很多人可能都没参与过稍复杂项目的开发，优化，这些内容对于很多新手iOS开发来说只存在于理论。但并不是说这些知识不重要，相反，它是我们进阶的必经之路。此篇文章的目的一方面自己整理，一方面希望和大家共同学习进步。以下内容多数为整理，时间仓促可能有不准确的地方，如果缺漏，欢迎指正。</p>
</blockquote>
<p>部分答案出处：<a href="https://github.com/ChenYilong/iOSInterviewQuestions">iOSInterviewQuestions</a></p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="为什么说Objective-C是一门动态语言？"><a href="#为什么说Objective-C是一门动态语言？" class="headerlink" title="为什么说Objective-C是一门动态语言？"></a>为什么说Objective-C是一门动态语言？</h2><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。比如Ruby、Python等就是动态语言，而C、C++等语言则不属于动态语言。<br>所谓的动态类型语言，意思就是类型的检查是在运行时做的。</p>
<p>1、动态类型。 如id类型。实际上静态类型因为其固定性和可预知性而使用得更加广泛。静态类型是强类型，而动态类型属于弱类型。运行时决定接收者。</p>
<p>2、动态绑定。让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。</p>
<p>3、动态载入。让程序在运行时添加代码模块以及其他资源。用户可以根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件。可执行代码中可以含有和程序运行时整合的新类。</p>
<h2 id="讲一下MVC和MVVM-MVP"><a href="#讲一下MVC和MVVM-MVP" class="headerlink" title="讲一下MVC和MVVM,MVP"></a>讲一下MVC和MVVM,MVP</h2><p><a href="http://www.cocoachina.com/ios/20160108/14916.html">iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a></p>
<h2 id="为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别"><a href="#为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别" class="headerlink" title="为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?"></a>为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?</h2><p>防止循环引用。</p>
<p>另外，不建议使用assign<br>weak 当计数器为0 时对象被释放，地址指针就置为了nil 了。<br>assign 当计数器为0 时 对象被释放，地址指针还是指向那个地址，就会产生野指针</p>
<p>datasource协议里面东西是跟内容有关的，主要是cell的构造函数，各种属性<br>delegate协议里面的方法主要是操作相关的，移动编辑之类的，你都写上要用什么方法自己去翻就是了<br>delegate控制的是UI，是上层的东西；而datasource控制的是数据。他们本质都是回调，只是回调的对象不同。</p>
<p>block 和 delegate 都可以通知外面。block 更轻型，使用更简单，能够直接访问上下文，这样类中不需要存储临时数据，使用 block 的代码通常会在同一个地方，这样读代码也连贯。delegate 更重一些，需要实现接口，它的方法分离开来，很多时候需要存储一些临时数据，另外相关的代码会被分离到各处，没有 block 好读。</p>
<p>多个相关方法，避免循环引用，建议用delegate。<br>临时性的，只在栈中，需要存储，只调用一次，一个完成周期用block</p>
<h2 id="属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？-dynamic关键字和-synthesize关键字是用来做什么的？"><a href="#属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？-dynamic关键字和-synthesize关键字是用来做什么的？" class="headerlink" title="属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？"></a>属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？</h2><p>属性的本质就是实现实例变量和存取方法。<br>    @property = ivar + getter + setter;</p>
<ol>
<li>对应基本数据类型默认关键字是<code>atomic,readwrite,assign</code></li>
<li>对于普通的 Objective-C 对象<code>atomic,readwrite,strong</code></li>
</ol>
<p><code>@property</code>有两个对应的词，一个是 <code>@synthesize</code>，一个是 <code>@dynamic</code>。如果 <code>@synthesize</code>和 <code>@dynamic</code>都没写，那么默认的就是<code>@syntheszie var = _var;</code><br><code>@synthesize</code> 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。<br><code>@dynamic</code> 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 <code>@dynamic var</code>，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p>
<h2 id="NSString为什么要用copy关键字，如果用strong会有什么问题？"><a href="#NSString为什么要用copy关键字，如果用strong会有什么问题？" class="headerlink" title="NSString为什么要用copy关键字，如果用strong会有什么问题？"></a>NSString为什么要用copy关键字，如果用strong会有什么问题？</h2><p>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</p>
<p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p>
<h2 id="如何令自己所写的对象具有拷贝功能"><a href="#如何令自己所写的对象具有拷贝功能" class="headerlink" title="如何令自己所写的对象具有拷贝功能?"></a>如何令自己所写的对象具有拷贝功能?</h2><p>若想令自己所写的对象具有拷贝功能，则需实现 <code>NSCopying</code> 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p>
<h2 id="可变集合类-和-不可变集合类的-copy-和-mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？"><a href="#可变集合类-和-不可变集合类的-copy-和-mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？" class="headerlink" title="可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？"></a>可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[immutableObject copy] &#x2F;&#x2F; 浅复制</span><br><span class="line">[immutableObject mutableCopy] &#x2F;&#x2F;深复制</span><br><span class="line">[mutableObject copy] &#x2F;&#x2F;深复制</span><br><span class="line">[mutableObject mutableCopy] &#x2F;&#x2F;深复制</span><br></pre></td></tr></table></figure>
<p>但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制</p>
<h2 id="为什么IBOutlet修饰的UIView也适用weak关键字？"><a href="#为什么IBOutlet修饰的UIView也适用weak关键字？" class="headerlink" title="为什么IBOutlet修饰的UIView也适用weak关键字？"></a>为什么IBOutlet修饰的UIView也适用weak关键字？</h2><p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。<br>不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫<code>_topLevelObjectsToKeepAliveFromStoryboard</code>的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>
<h2 id="nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？"><a href="#nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？" class="headerlink" title="nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？"></a>nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？</h2><p><code>atomic</code>会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 <code>nonatomic</code> 可以节省这些虽然很小但是不必要额外开销。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 <code>atomic</code>，也还是会读到不同的属性值。</p>
<h2 id="UICollectionView自定义layout如何实现？"><a href="#UICollectionView自定义layout如何实现？" class="headerlink" title="UICollectionView自定义layout如何实现？"></a>UICollectionView自定义layout如何实现？</h2><ul>
<li>新建一个类继承<code>UICollectionViewFlowLayout</code>，实现<code>prepareLayout</code>方法。</li>
<li>新建<code>UICollectionViewFlowLayout</code>类，设置属性。</li>
<li>实现<code>UICollectionViewDelegateFlowLayout</code>方法。</li>
</ul>
<h2 id="用StoryBoard开发界面有什么弊端？如何避免？"><a href="#用StoryBoard开发界面有什么弊端？如何避免？" class="headerlink" title="用StoryBoard开发界面有什么弊端？如何避免？"></a>用StoryBoard开发界面有什么弊端？如何避免？</h2><ul>
<li>难以维护  </li>
<li>性能瓶颈  </li>
<li>错误定位不准确</li>
</ul>
<p>解决多Storyboard协作弊端，就是尽量将项目的界面分割在多个Storyboard文件中。一个最佳实践是，按照项目功能模块来区分故事板，例如<code>Login.Storyboard,Chat.Storyboard,Person.Storyboard</code>等。尽量把每个<code>Storyboard</code>的Scene数量控制在20个以内</p>
<h2 id="进程和线程的区别？同步异步的区别？并行和并发的区别？"><a href="#进程和线程的区别？同步异步的区别？并行和并发的区别？" class="headerlink" title="进程和线程的区别？同步异步的区别？并行和并发的区别？"></a>进程和线程的区别？同步异步的区别？并行和并发的区别？</h2><p>一个进程可以包括多个线程。一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>一个程序至少有一个进程,一个进程至少有一个线程. 线程只能归属于一个进程并且它只能访问该进程所拥有的资源。</p>
<p>同步会造成阻塞，异步非阻塞，网络请求操作。</p>
<p>一个形象的例子：<br>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。<br>“并行”概念是“并发”概念的一个子集</p>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><p><code>NSThread</code>可以先将自己的当前线程对象注册到某个全局的对象中去，这样相互之间就可以获取对方的线程对象，然后就可以使用下面的方法进行线程间的通信了，由于主线程比较特殊，所以框架直接提供了在主线程执行的方法</p>
<h2 id="GCD的一些常用的函数？（group，barrier，信号量，线程同步）"><a href="#GCD的一些常用的函数？（group，barrier，信号量，线程同步）" class="headerlink" title="GCD的一些常用的函数？（group，barrier，信号量，线程同步）"></a>GCD的一些常用的函数？（group，barrier，信号量，线程同步）</h2><ul>
<li><p>group<br>队列组通知监听函数(异步函数)dispatch_group_notify<br>队列组等待函数(同步函数)dispatch_group_wait<br>应用场景:下载两张图片，拼接图片后到主线程中刷新</p>
</li>
<li><p>barrier<br>栅栏函数执行顺序：栅栏函数之前的任务(执行完毕)–&gt; 栅栏函数的任务(执行完毕)–&gt; 栅栏函数之后的任务<br>栅栏函数前面和后面追加的操作执行顺序都不固定，但是前面的三个输出操作必然先执行，然后再执行栅栏函数中的操作，最后执行后面的三个输出操作。<br><a href="http://www.jianshu.com/p/d63c3100dd63">栅栏函数</a></p>
</li>
<li><p>信号量<br>信号量大小是用于控制并发数量的<br>信号量就是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的：<br>设信号量值为1， 当一个进程1运行是，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这是信号量值为0。系统中规定当信号量值为0是，必须等待，知道信号量值不为零才能继续操作。 这时如果进程2想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就到到了进程1排他访问。 当进程1运行结束后，释放资源，进行V操作。资源数重新加1，这是信号量的值变为1. 这时进程2发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0.次数进程2咱有资源，排他访问资源。 这就是信号量来控制互斥的原理</p>
</li>
<li><p>线程同步：<br>线程同步：@synchronized  NSLock  dispatch_semaphore(信号量设置为1)</p>
</li>
</ul>
<h2 id="如何使用队列来避免资源抢夺？"><a href="#如何使用队列来避免资源抢夺？" class="headerlink" title="如何使用队列来避免资源抢夺？"></a>如何使用队列来避免资源抢夺？</h2><p>当我们使用多线程来访问同一个数据的时候，就有可能造成数据的不准确性。这个时候我么可以使用线程锁的来来绑定。也是可以使用串行队列来完成。<br>如：fmdb就是使用<code>FMDatabaseQueue</code>，来解决多线程抢夺资源。</p>
<h2 id="数据持久化的几个方案（fmdb用没用过）"><a href="#数据持久化的几个方案（fmdb用没用过）" class="headerlink" title="数据持久化的几个方案（fmdb用没用过）"></a>数据持久化的几个方案（fmdb用没用过）</h2><ul>
<li>plist</li>
<li>CoreData </li>
<li>FMDB</li>
</ul>
<h2 id="说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？"><a href="#说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？" class="headerlink" title="说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？"></a>说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">didFinishLaunchingWithOptions:</span><br><span class="line">applicationDidBecomeActive:</span><br><span class="line">&#x2F;&#x2F;前台到后台：</span><br><span class="line">applicationWillResignActive:</span><br><span class="line">applicationDidEnterBackground:</span><br><span class="line">&#x2F;&#x2F;后台到前台：</span><br><span class="line">applicationWillEnterForeground:</span><br><span class="line">applicationDidBecomeActive:</span><br></pre></td></tr></table></figure></code></pre><h2 id="NSCache优于NSDictionary的几点？"><a href="#NSCache优于NSDictionary的几点？" class="headerlink" title="NSCache优于NSDictionary的几点？"></a>NSCache优于NSDictionary的几点？</h2><ul>
<li>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</li>
<li>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</li>
<li>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</li>
</ul>
<h2 id="知不知道Designated-Initializer？使用它的时候有什么需要注意的问题？"><a href="#知不知道Designated-Initializer？使用它的时候有什么需要注意的问题？" class="headerlink" title="知不知道Designated Initializer？使用它的时候有什么需要注意的问题？"></a>知不知道Designated Initializer？使用它的时候有什么需要注意的问题？</h2><p>便利初始化函数只能调用自己类中的其他初始化方法<br>指定初始化函数才有资格调用父类的指定初始化函数<br><a href="http://www.cnblogs.com/smileEvday/p/designated_initializer.html">构造便利函数</a></p>
<h2 id="实现description方法能取到什么效果？"><a href="#实现description方法能取到什么效果？" class="headerlink" title="实现description方法能取到什么效果？"></a>实现description方法能取到什么效果？</h2><p><code>description</code>方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)，可定义输出自己想要的内容。</p>
<h2 id="objc使用什么机制管理对象内存？"><a href="#objc使用什么机制管理对象内存？" class="headerlink" title="objc使用什么机制管理对象内存？"></a>objc使用什么机制管理对象内存？</h2><p>1.Objective-C中所有对象都在堆区建立，由程序员负责释放对象所占用的内存。内存管理机制由3种：垃圾回收、引用计数、C语言方式。</p>
<p>2.垃圾回收是Mac OS10.5提供的新方案，在系统存在一个垃圾收集器。如果发现某个对象没有被任何对象使用，该对象被自动释放。</p>
<p>3.C语言方式，原始内存管理方式。用户手动调用malloc、calloc函数分配内存，free回收内存。</p>
<p>4.引用计数机制：对象创建后，运行时系统通过对象维护的一个计数器来描述有多少个其他对象在使用自己，当计数器为0时，释放该对象占用的内存空间（该对象调用dealloc方法）。</p>
<p>5,内存管理规则：当使用alloc，new或copy创建一个对象时，对象的引用计数被设置为1.；向对象发送retain消息，对象引用计数加1；向对象发送release消息时，对象引用计数减1；当对象引用计数为0时，运行时系统向对象发送dealloc消息并回收对象所占用的内存。</p>
<h1 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h1><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><h3 id="block的实质是什么？一共有几种block？都是什么情况下生成的？"><a href="#block的实质是什么？一共有几种block？都是什么情况下生成的？" class="headerlink" title="block的实质是什么？一共有几种block？都是什么情况下生成的？"></a>block的实质是什么？一共有几种block？都是什么情况下生成的？</h3><p>Block是iOS开发中一种比较特殊的数据结构，它可以保存一段代码，在合适的地方再调用，具有语法简介、回调方便、编程思路清晰、执行效率高等优点，受到众多猿猿的喜爱。</p>
<ul>
<li>_NSConcreteGlobalBlock: 存储在全局数据区</li>
<li>_NSConcreteStackBlock: 存储在栈区</li>
<li>_NSConcreteMallocBlock: 存储在堆区<br>其中，<code>_NSConcreteGlobalBlock</code> 和 <code>_NSConcreteStackBlock</code> 可以由程序创建，而 <code>_NSConcreteMallocBlock</code> 则无法由程序创建，只能由 <code>_NSConcreteStackBlock</code> 通过拷贝生成。</li>
</ul>
<h3 id="为什么在默认情况下无法修改被block捕获的变量？-block都做了什么？"><a href="#为什么在默认情况下无法修改被block捕获的变量？-block都做了什么？" class="headerlink" title="为什么在默认情况下无法修改被block捕获的变量？ __block都做了什么？"></a>为什么在默认情况下无法修改被block捕获的变量？ __block都做了什么？</h3><p>Block不允许修改外部变量的值。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。<br>又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。<br>将变量由栈区移到堆区。</p>
<h3 id="模拟一下循环引用的一个情况？block实现界面反向传值如何实现？"><a href="#模拟一下循环引用的一个情况？block实现界面反向传值如何实现？" class="headerlink" title="模拟一下循环引用的一个情况？block实现界面反向传值如何实现？"></a>模拟一下循环引用的一个情况？block实现界面反向传值如何实现？</h3><p>一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。<br>解决方法是将该对象使用<code>__weak</code>或者<code>__block</code>修饰符修饰之后再在block中使用.<br><code>id weak weakSelf = self;</code> 或者 <code>weak __typeof(&amp;*self)weakSelf = self</code>该方法可以设置宏<br><code>id __block weakSelf = self;</code><br>或者将其中一方强制制空 <code>xxx = nil</code>。</p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><h3 id="objc在向一个对象发送消息时，发生了什么？"><a href="#objc在向一个对象发送消息时，发生了什么？" class="headerlink" title="objc在向一个对象发送消息时，发生了什么？"></a>objc在向一个对象发送消息时，发生了什么？</h3><ol>
<li>通过对象的isa指针获取类的结构体。</li>
<li>在结构体的方法表里查找方法的selector。</li>
<li>如果没有找到selector，则通过objc_msgSend结构体中指向父类的指针找到父类，并在父类的方法表里查找方法的selector。</li>
<li>依次会一直找到NSObject。</li>
<li>一旦找到selector，就会获取到方法实现IMP。</li>
<li>传入相应的参数来执行方法的具体实现。</li>
<li>如果最终没有定位到selector，就会走消息转发流程。</li>
</ol>
<h3 id="什么时候会报unrecognized-selector错误？iOS有哪些机制来避免走到这一步？"><a href="#什么时候会报unrecognized-selector错误？iOS有哪些机制来避免走到这一步？" class="headerlink" title="什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？"></a>什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？</h3><p>找不到执行方法。</p>
<ul>
<li>动态方法解析<br>对象接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或 者<code>+resolveClassMethod:</code>(类方法)。</li>
<li>备用接收者<br>如果这个方法返回一个对象，则这个对象会作为消息的新接收者。注意这个对象不能是self自身，否则就是出现无限循环。如果没有指定对象来处理<code>aSelector</code>，则应该 <code>return [super forwardingTargetForSelector:aSelector]</code>。</li>
<li>完整消息转发<br>这是最后一次机会将消息转发给其它对象。创建一个表示消息的<code>NSInvocation</code>对象，把与消息的有关全部细节封装在<code>anInvocation</code>中，包括<code>selector</code>，目标(target)和参数。在<code>forwardInvocation</code> 方法中将消息转发给其它对象。</li>
</ul>
<h3 id="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><p>不能向编译后得到的类中增加实例变量；<br>能向运行时创建的类中添加实例变量；<br>解释下：<br>因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表 和 <code>instance_size</code> 实例变量的内存大小已经确定，同时runtime 会调用 <code>class_setIvarLayout</code> 或 <code>class_setWeakIvarLayout</code> 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>
<p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code> 函数。但是得在调用 <code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code>之前，原因同上。</p>
<h3 id="runtime如何实现weak变量的自动置nil？"><a href="#runtime如何实现weak变量的自动置nil？" class="headerlink" title="runtime如何实现weak变量的自动置nil？"></a>runtime如何实现weak变量的自动置nil？</h3><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
<h3 id="给类添加一个属性后，在类结构体里哪些元素会发生变化？"><a href="#给类添加一个属性后，在类结构体里哪些元素会发生变化？" class="headerlink" title="给类添加一个属性后，在类结构体里哪些元素会发生变化？"></a>给类添加一个属性后，在类结构体里哪些元素会发生变化？</h3><p><img src="http://upload-images.jianshu.io/upload_images/1059465-47afdfd1950a72c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Class 结构.jpg"></p>
<p><code>instance_size</code> ：实例的内存大小<br><code>objc_ivar_list *ivars</code>:属性列表</p>
<h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><h3 id="runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？"><a href="#runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？" class="headerlink" title="runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？"></a>runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？</h3><p>循环检测线程任务。为了在我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<ol>
<li><p>主线程的run loop默认是启动的。</p>
</li>
<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>
</li>
<li><p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p>
<p> NSRunLoop *runloop = [NSRunLoop currentRunLoop];</p>
</li>
</ol>
<h3 id="runloop的mode是用来做什么的？有几种mode？"><a href="#runloop的mode是用来做什么的？有几种mode？" class="headerlink" title="runloop的mode是用来做什么的？有几种mode？"></a>runloop的mode是用来做什么的？有几种mode？</h3><p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>
<p><code>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</code>：默认，空闲状态<br><code>UITrackingRunLoopMode：ScrollView</code>滑动时<br><code>UIInitializationRunLoopMode：</code>启动时<br><code>NSRunLoopCommonModes（kCFRunLoopCommonModes）：</code>Mode集合<br>苹果公开提供的 Mode 有两个：<br>    NSDefaultRunLoopMode（kCFRunLoopDefaultMode）<br>    NSRunLoopCommonModes（kCFRunLoopCommonModes）<br>为什么把NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环以后，滑动scrollview的时候NSTimer却不动了？<br>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中<code>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</code>的mode会切换到<code>UITrackingRunLoopMode</code>来保证ScrollView的流畅滑动：只能在<code>NSDefaultRunLoopMode</code>模式下处理的事件会影响ScrollView的滑动。</p>
<p>如果我们把一个NSTimer对象以<code>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</code>添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>
<p>同时因为mode还是可定制的，所以：</p>
<p>Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到<code>NSRunLoopCommonModes（kCFRunLoopCommonModes）</code>来解决。</p>
<pre><code>//将timer添加到NSDefaultRunLoopMode中
[NSTimer scheduledTimerWithTimeInterval:1.0
                                 target:self
                               selector:@selector(timerTick:)
                               userInfo:nil
                                repeats:YES];
//然后再添加到NSRunLoopCommonModes里
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0
                                         target:self
                                       selector:@selector(timerTick:)
                                       userInfo:nil
                                        repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></pre><h3 id="苹果是如何实现Autorelease-Pool的？"><a href="#苹果是如何实现Autorelease-Pool的？" class="headerlink" title="苹果是如何实现Autorelease Pool的？"></a>苹果是如何实现Autorelease Pool的？</h3><p>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.</p>
<p><code>objc_autoreleasepoolPush</code><br><code>objc_autoreleasepoolPop</code><br><code>objc_autorelease</code><br>看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</p>
<p>举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：<br><img src="http://upload-images.jianshu.io/upload_images/1059465-b8314aaf33c5dd27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="autorealease pool.jpg"><br>备注：<a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/">Objective-C Autorelease Pool 的实现原理</a> 可能苹果在ARC的处理上又优化了，或者变更了。我自己测试的结果跟以上分析不一致，但原理可以参考。</p>
<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><h3 id="isa指针？（对象的isa，类对象的isa，元类的isa都要说）"><a href="#isa指针？（对象的isa，类对象的isa，元类的isa都要说）" class="headerlink" title="isa指针？（对象的isa，类对象的isa，元类的isa都要说）"></a>isa指针？（对象的isa，类对象的isa，元类的isa都要说）</h3><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p>
<ul>
<li>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</li>
<li>成员变量的列表,</li>
<li>属性列表,<br>它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。<br>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</li>
</ul>
<h3 id="类方法和实例方法有什么区别？"><a href="#类方法和实例方法有什么区别？" class="headerlink" title="类方法和实例方法有什么区别？"></a>类方法和实例方法有什么区别？</h3><ul>
<li><p>类方法：<br>类方法是属于类对象的<br>类方法只能通过类对象调用<br>类方法中的self是类对象<br>类方法可以调用其他的类方法<br>类方法中不能访问成员变量<br>类方法中不能直接调用对象方法</p>
</li>
<li><p>实例方法：<br>实例方法是属于实例对象的<br>实例方法只能通过实例对象调用<br>实例方法中的self是实例对象<br>实例方法中可以访问成员变量<br>实例方法中直接调用实例方法<br>实例方法中也可以调用类方法(通过类名)</p>
</li>
</ul>
<h3 id="介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？"><a href="#介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？" class="headerlink" title="介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？"></a>介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？</h3><p>分类可以在不知道系统类源代码的情况下，为这个类添加新的方法。分类只能用来添加方法，不能添加成员变量。通过分类增加的方法，系统会认为是该类类型的一部分<br><a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/">Category实现原理</a></p>
<h3 id="运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？"><a href="#运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？" class="headerlink" title="运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？"></a>运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？</h3><p>可以添加属性，不可以添加成员变量。<br><a href="http://www.cocoachina.com/ios/20150526/11918.html">OC类成员变量深度剖析</a></p>
<h3 id="objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）"><a href="#objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）" class="headerlink" title="objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）"></a>objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）</h3><p>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：</p>
<pre><code>Person *motherInlaw = [[aPerson spouse] mother];</code></pre><ol>
<li>如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。 </li>
<li>如果方法返回值为指针类型，其指针大小为小于或者等于<code>sizeof(void*)，float，double，long double</code> 或者 <code>long long</code> 的整型标量，发送给 nil 的消息将返回0。 </li>
<li>如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。 </li>
<li>如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</li>
</ol>
<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）"><a href="#UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）" class="headerlink" title="UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）"></a>UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）</h2><p>一般在网络请求结束后，在更新界面之前就把每个 cell 的高度算好，缓存到相对应的 model 中。</p>
<p>另外绘制 cell 不建议使用 UIView，建议使用 CALayer。<br>简单的形式参考：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    CGRect rect &#x3D; CGRectMake(0, 0, 100, 100);</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(rect.size, YES, 0);</span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    [[UIColor lightGrayColor] set];</span><br><span class="line">    CGContextFillRect(context, rect);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将绘制的内容以图片的形式返回，并调主线程显示</span><br><span class="line">    UIImage *temp &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 回到主线程</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        &#x2F;&#x2F;code</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><p>CALayer 的 border、圆角、阴影、遮罩（mask），<code>CASharpLayer</code> 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 <code>CALayer</code>，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 <code>CALayer.shouldRasterize</code> 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS蓝牙知识快速入门（详尽版）</title>
    <url>/2017/01/13/bluetooth-intro/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1059465-d8149efe4c37d452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS-bluetooth"><br>以前写过几篇蓝牙相关的文章，但是没有涉及扫描、收发指令这些基础功能的实现。所以打算写一篇尽可能详尽的蓝牙知识汇总，一方面给有需要的同学看，一方面是对自己学习蓝牙的一个总结。</p>
<p>这篇文章的目的：教你实现设备的扫描，连接，数据收发，蓝牙数据解析。如果在实现上面任一功能遇到问题时，欢迎留下你的问题，我将进行补充，对于说法有误的地方也请老司机予以指正。</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p><a href="#thought">0、思维导图</a><br><a href="#1">1、苹果对蓝牙设备有什么要求</a><br><a href="#2">2、操作蓝牙设备使用什么库</a><br><a href="#3">3、如何扫描</a><br><a href="#4">4、如何连接</a><br><a href="#5">5、如何发送数据和接收数据</a><br><a href="#6">6、如何解析数据</a><br><a href="#7">7、扩展</a></p>
</blockquote>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1059465-46a0e68cfd9c4c9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="思维导图"><br>第一次做图，大家凑合着看哈。这张是我总结的蓝牙知识的结构图，下面的内容将围绕这些东西展开进行。<br><img src="http://upload-images.jianshu.io/upload_images/1059465-18ebcb6eb1790121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连接设备流程"><br>这张是蓝牙连接发送数据的流程图，下文进入coding阶段的讲解顺序，大家先有个大概印象，等阅读完本文再回来看这张图将理解的更深一些。</p>
<h2 id="苹果对蓝牙设备有什么要求"><a href="#苹果对蓝牙设备有什么要求" class="headerlink" title="苹果对蓝牙设备有什么要求"></a>苹果对蓝牙设备有什么要求</h2><p>BLE：bluetouch low energy，蓝牙4.0设备因为低功耗，所有也叫作BLE。苹果在iphone4s及之后的手机型号开始支持蓝牙4.0，这也是最常见的蓝牙设备。低于蓝牙4.0协议的设备需要进行MFI认证，关于MFI认证的申请工作可以看这里：<a href="http://www.jianshu.com/p/b90b0c45398d">关于MFI认证你所必须要知道的事情</a></p>
<p>在进行操作蓝牙设备前，我们先下载一个蓝牙工具<code>LightBlue</code>，它可以辅助我们的开发，在进行蓝牙开发之前建议先熟悉一下<a href="https://itunes.apple.com/us/app/lightblue-explorer-bluetooth/id557428110?mt=8">LightBlue</a>这个工具。</p>
<h2 id="操作蓝牙设备使用什么库"><a href="#操作蓝牙设备使用什么库" class="headerlink" title="操作蓝牙设备使用什么库"></a>操作蓝牙设备使用什么库</h2><p>苹果自身有一个操作蓝牙的库<code>CoreBluetooth.framework</code>，这个是大多数人员进行蓝牙开发的首选框架，除此之外目前github还有一个比较流行的对原生框架进行封装的三方库<a href="https://github.com/coolnameismy/BabyBluetooth">BabyBluetooth</a>，它的机制是将CoreBluetooth中众多的delegate写成了block方法，有兴趣的同学可以了解下。下面主要介绍的是原生蓝牙库的知识。</p>
<h3 id="中心和外围设备"><a href="#中心和外围设备" class="headerlink" title="中心和外围设备"></a>中心和外围设备</h3><p><img src="http://upload-images.jianshu.io/upload_images/1059465-d4c7cabd9f2ca98a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="central-peripheral"></p>
<p>如图所示，电脑、Pad、手机作为中心，心跳监听器作为外设，这种中心外设模式是最常见的。简单理解就是，发起连接的是中心设备（Central），被连接的是外围设备（Peripheral），对应传统的客户机-服务器体系结构。Central能够扫描侦听到，正在播放广告包的外设。</p>
<h3 id="服务与特征"><a href="#服务与特征" class="headerlink" title="服务与特征"></a>服务与特征</h3><p>外设可以包含一个或多个服务（CBService），服务是用于实现装置的功能或特征数据相关联的行为集合。<br>而每个服务又对应多个特征（CBCharacteristic）,特征提供外设服务进一步的细节，外设，服务，特征对应的数据结构如下所示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-bbcf073456d1f3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CBService-CBCharacteristic"></p>
<h2 id="如何扫描蓝牙"><a href="#如何扫描蓝牙" class="headerlink" title="如何扫描蓝牙"></a>如何扫描蓝牙</h2><p>在进行扫描之前我们需要，首先新建一个类作为蓝牙类，例如<code>FYBleManager</code>，写成单例，作为处理蓝牙操作的管理类。引入头文件<code>#import &lt;CoreBluetooth/CoreBluetooth.h&gt;</code><br><code>CBCentralManager</code>是蓝牙中心的管理类，控制着蓝牙的扫描，连接，蓝牙状态的改变。</p>
<h3 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h3><pre><code>dispatch_queue_t centralQueue = dispatch_queue_create(“centralQueue&quot;,DISPATCH_QUEUE_SERIAL);
    NSDictionary *dic = @{CBCentralManagerOptionShowPowerAlertKey : YES,
    CBCentralManagerOptionRestoreIdentifierKey : @&quot;unique identifier&quot;
};
self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:centralQueue options:dic];</code></pre><p><code>CBCentralManagerOptionShowPowerAlertKey</code>对应的BOOL值，当设为YES时，表示CentralManager初始化时，如果蓝牙没有打开，将弹出Alert提示框<br><code>CBCentralManagerOptionRestoreIdentifierKey</code>对应的是一个唯一标识的字符串，用于蓝牙进程被杀掉恢复连接时用的。</p>
<h3 id="2、扫描"><a href="#2、扫描" class="headerlink" title="2、扫描"></a>2、扫描</h3><pre><code>//不重复扫描已发现设备        
NSDictionary *option = @{CBCentralManagerScanOptionAllowDuplicatesKey : [NSNumber numberWithBool:NO],CBCentralManagerOptionShowPowerAlertKey:YES};        
[self.centralManager scanForPeripheralsWithServices:nil options:option];
- (void)scanForPeripheralsWithServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;</code></pre><p>扫面方法，<code>serviceUUIDs</code>用于第一步的筛选，扫描此UUID的设备<br>options有两个常用参数：<code>CBCentralManagerScanOptionAllowDuplicatesKey</code>设置为NO表示不重复扫瞄已发现设备，为YES就是允许。<code>CBCentralManagerOptionShowPowerAlertKey</code>设置为YES就是在蓝牙未打开的时候显示弹框</p>
<h3 id="3、CBCentralManagerDelegate代理方法"><a href="#3、CBCentralManagerDelegate代理方法" class="headerlink" title="3、CBCentralManagerDelegate代理方法"></a>3、CBCentralManagerDelegate代理方法</h3><p>在初始化的时候我们调用了代理，在CoreBluetooth中有两个代理，</p>
<ul>
<li>CBCentralManagerDelegate</li>
<li>CBPeripheralDelegate</li>
</ul>
<p>iOS的命名很友好，我们通过名字就能看出，上面那个是关于中心设备的代理方法，下面是关于外设的代理方法。我们这里先研究<code>CBCentralManagerDelegate</code>中的代理方法</p>
<pre><code>- (void)centralManagerDidUpdateState:(CBCentralManager *)central;</code></pre><p>这个方法标了<code>@required</code>是必须添加的，我们在self.centralManager初始换之后会调用这个方法，回调蓝牙的状态。状态有以下几种：</p>
<pre><code>typedef NS_ENUM(NSInteger, CBCentralManagerState{
    CBCentralManagerStateUnknown = CBManagerStateUnknown,//未知状态
    CBCentralManagerStateResetting = CBManagerStateResetting,//重启状态
    CBCentralManagerStateUnsupported = CBManagerStateUnsupported,//不支持
    CBCentralManagerStateUnauthorized = CBManagerStateUnauthorized,//未授权
    CBCentralManagerStatePoweredOff = CBManagerStatePoweredOff,//蓝牙未开启
    CBCentralManagerStatePoweredOn = CBManagerStatePoweredOn,//蓝牙启
} NS_DEPRECATED(NA, NA, 5_0, 10_0, &quot;Use CBManagerState instead”);</code></pre><p>该枚举在iOS10之后已经废除了，系统推荐使用<code>CBManagerState</code>，类型都是对应的</p>
<pre><code>typedef NS_ENUM(NSInteger, CBManagerState{
    CBManagerStateUnknown = 0,
    CBManagerStateResetting,
    CBManagerStateUnsupported,
    CBManagerStateUnauthorized,
    CBManagerStatePoweredOff,
    CBManagerStatePoweredOn,
} NS_ENUM_AVAILABLE(NA, 10_0);

- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI;</code></pre><p>peripheral是外设类<br><code>advertisementData</code>是广播的值，一般携带设备名，<code>serviceUUIDs</code>等信息<br>RSSI绝对值越大，表示信号越差，设备离的越远。如果想装换成百分比强度，（RSSI+100）/100，（这是一个约数，蓝牙信号值并不一定是-100 - 0的值，但近似可以如此表示）</p>
<pre><code>- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict;</code></pre><p>在蓝牙于后台被杀掉时，重连之后会首先调用此方法，可以获取蓝牙恢复时的各种状态</p>
<h2 id="如何连接"><a href="#如何连接" class="headerlink" title="如何连接"></a>如何连接</h2><p>在扫面的代理方法中，我们连接外设名是MI的蓝牙设备</p>
<pre><code>- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{    
    NSLog(@&quot;advertisementData:%@，RSSI:%@&quot;,advertisementData,RSSI);      
    if([peripheral.name isEqualToString:@&quot;MI&quot;]){        
    [self.centralManager connectPeripheral:peripheral options:nil];//发起连接的命令       
          self.peripheral = peripheral;     
    }
}</code></pre><p><strong>连接的状态</strong><br>对应另外的<code>CBCentralManagerDelegate</code>代理方法<br>连接成功的回调</p>
<pre><code>- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral;</code></pre><p>连接失败的回调</p>
<pre><code>- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error;</code></pre><p>连接断开的回调</p>
<pre><code>- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error;</code></pre><p>连接成功之后并没有结束，还记得<code>CBPeripheral</code>中的<code>CBService</code>和<code>CBService</code>中的<code>CBCharacteristic</code>吗，对数据的读写是由<code>CBCharacteristic</code>控制的。我们先用lightblue连接小米手环为例，来看一下，手环内部的数据是不是我们说的那样。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-1ab902ebe252094e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lightblue"></p>
<p>其中<code>ADVERTISEMENT DATA</code>显示的就是广播信息。</p>
<blockquote>
<p><strong>iOS蓝牙无法直接获取设备蓝牙MAC地址，可以将MAC地址放到这里广播出来</strong></p>
</blockquote>
<p><code>FEEO</code>是<code>ServiceUUIDs</code>,里面的<code>FF01</code>、<code>FF02</code>是<code>CBCharacteristic的UUID</code></p>
<p><code>Properties</code>是特征的属性，可以看出<code>FF01</code>具有读的权限，<code>FF02</code>具有读写的权限。特征拥有的权限类别有如下几种：</p>
<pre><code>typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties{
    CBCharacteristicPropertyBroadcast = 0x01,
    CBCharacteristicPropertyRead = 0x02,
    CBCharacteristicPropertyWriteWithoutResponse = 0x04,
    CBCharacteristicPropertyWrite = 0x08,
    CBCharacteristicPropertyNotify = 0x10,
    CBCharacteristicPropertyIndicate = 0x20,
    CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40,
    CBCharacteristicPropertyExtendedProperties = 0x80,
    CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100,
    CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200};</code></pre><h2 id="如何发送并接收数据"><a href="#如何发送并接收数据" class="headerlink" title="如何发送并接收数据"></a>如何发送并接收数据</h2><p>通过上面的步骤我们发现<code>CBCentralManagerDelegate</code>提供了蓝牙状态监测、扫描、连接的代理方法，但是<code>CBPeripheralDelegate</code>的代理方法却还没使用。别急，马上就要用到了，通过名称判断这个代理的作用，肯定是跟<code>Peripheral</code>有关，我们进入系统API，看它的代理方法都有什么，因为这里的代理方法较多，我就挑选几个常用的拿出来说明一下。</p>
<h3 id="1、代理方法"><a href="#1、代理方法" class="headerlink" title="1、代理方法"></a>1、<strong>代理方法</strong></h3><pre><code>//发现服务的回调
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error;
//发现特征的回调
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error;
//读数据的回调
- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error;
//是否写入成功的回调
 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error;</code></pre><h3 id="2、步骤"><a href="#2、步骤" class="headerlink" title="2、步骤"></a>2、<strong>步骤</strong></h3><p>通过这几个方法我们构建一个流程：连接成功-&gt;获取指定的服务-&gt;获取指定的特征-&gt;订阅指定特征值-&gt;通过具有写权限的特征值写数据-&gt;在<code>didUpdateValueForCharacteristic</code>回调中读取蓝牙反馈值</p>
<p>解释一下订阅特征值：特征值具有Notify权限才可以进行订阅，订阅之后该特征值的value发生变化才会回调<code>didUpdateValueForCharacteristic</code></p>
<h3 id="3、实现上面流程的实例代码"><a href="#3、实现上面流程的实例代码" class="headerlink" title="3、实现上面流程的实例代码"></a>3、<strong>实现上面流程的实例代码</strong></h3><pre><code>//连接成功
- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{
        //连接成功之后寻找服务，传nil会寻找所有服务
        [peripheral discoverServices:nil];
}

//发现服务的回调
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{   
    if (!error) {        
        for (CBService *service in peripheral.services) {                
            NSLog(@&quot;serviceUUID:%@&quot;, service.UUID.UUIDString);            
            if ([service.UUID.UUIDString isEqualToString:ST_SERVICE_UUID]) {
                        //发现特定服务的特征值               
                [service.peripheral discoverCharacteristics:nil forService:service];            
            }        
        }    
    }
}

//发现characteristics，由发现服务调用（上一步），获取读和写的characteristics
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error {    
    for (CBCharacteristic *characteristic in service.characteristics) {        
    //有时读写的操作是由一个characteristic完成        
        if ([characteristic.UUID.UUIDString isEqualToString:ST_CHARACTERISTIC_UUID_READ]) {   
            self.read = characteristic;           
            [self.peripheral setNotifyValue:YES forCharacteristic:self.read];        
        } else if ([characteristic.UUID.UUIDString isEqualToString:ST_CHARACTERISTIC_UUID_WRITE]) {  
             self.write = characteristic;        
        }    
    }
}

//是否写入成功的代理
- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{   
    if (error) {        
        NSLog(@&quot;===写入错误：%@&quot;,error);    
    }else{        
        NSLog(@&quot;===写入成功&quot;);    
    }
}

//数据接收
- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {    
        if([characteristic.UUID.UUIDString isEqualToString:ST_CHARACTERISTIC_UUID_READ]){
        //获取订阅特征回复的数据
        NSData *value = characteristic.value;        
        NSLog(@&quot;蓝牙回复：%@&quot;,value);
        }
}</code></pre><p>比如我们要获取蓝牙电量，由硬件文档查询得知该指令是<code>**0x1B9901**</code>,那么获取电量的方法就可以写成</p>
<pre><code>- (void)getBattery{
    Byte value[3]={0};
    value[0]=x1B;
    value[1]=x99;
    value[2]=x01;
    NSData * data = [NSData dataWithBytes:&amp;value length:sizeof(value)];
    //发送数据
    [self.peripheral writeValue:data forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse];
}</code></pre><p>如果写入成功，我们将会在<code>didUpdateValueForCharacteristic</code>方法中获取蓝牙回复的信息。</p>
<h2 id="如何解析蓝牙数据"><a href="#如何解析蓝牙数据" class="headerlink" title="如何解析蓝牙数据"></a>如何解析蓝牙数据</h2><p>如果你顺利完成了上一步的操作，并且看到了蓝牙返回的数据，那么恭喜你，蓝牙的常用操作你已经了解大半了。因为蓝牙的任务大部分就是围绕发送指令，获取指令，将蓝牙数据呈现给用户。上一步我们已经获取了蓝牙指令，但是获取的却是<code>0x567b0629</code>这样的数据，这是什么意思呢。这时我们参考硬件文档，看到这样一段:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-141b274b7ed8e976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="device-document"><br>那么我们就可以得出设备电量是 60%。</p>
<p>对数据解析的流程就是：判断校验和是否正确，是不是一条正确的数据-&gt;该条数据是不是我们需要的电量数据，即首字节为<code>0x567b</code>-&gt;根据定义规则解析电量，传给view显示。其中第一步校验数据，视情况而定，也有不需要的情况。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="http://www.jianshu.com/p/a5e25206df39">iOS蓝牙中的进制转换</a><br><a href="http://www.jianshu.com/p/0d956862ffa1">蓝牙固件升级</a><br><a href="http://www.jianshu.com/p/eb5b1e26adf7">nRF芯片设备DFU升级</a></p>
]]></content>
      <categories>
        <category>蓝牙总结</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>为博客设一个自定义域名</title>
    <url>/2017/01/05/custom-domain-blog/</url>
    <content><![CDATA[<p>现在越来越多的人悬着使用githubpage搭建自己的个人博客，但是github提供的默认的域名是这种形式：<code>username.github.io</code>，是个二级域名，这对于很多人来说可能感觉不是很酷。那么我们今天就来做一件比较酷的事情，为站点自定义一个域名。</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p>0、准备工作<br>1、域名申请<br>2、为站点添加CNAME<br>3、在DNSPOD配置域名解析<br>4、修改DNS<br>5、验证结果</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>一个完整的github page博客项目。</li>
<li>名词解释：<br>DNS：网域名称系统。你可以把它想象成一张域名和IP地址映射的数据表。<br>DNS解析：就是通过我们输入的网址（域名）查找到对应的主机（IP地址）<br>CNAME重定向：username.github.io和username.tk是两个域名，添加CNAME文件选择首选域，使其指向同一主机。<br><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">DNS原理&gt;&gt;</a></li>
</ul>
<h2 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h2><p>有很多网站都有域名购买服务，我使用的是<a href="https://my.freenom.com/domains.php">Freenom</a>。常见的域名注册网站还有<a href="https://wanwang.aliyun.com">万网</a>、<a href="https://www.qcloud.com/product/dm?utm_source=pcsem&utm_medium=kwd-328922380&utm_campaign=google&gclid=CLTEuaHvpNECFUYKKgodhYQAFw">腾讯云</a>、<a href="https://sg.godaddy.com/zh/">GoDaady</a>（狗爹）。<br>我选择Freenom的最主要原因就是：免费+顶级域名。对，你没有听错就是免费的顶级域名，一开始就认为注册域名肯定要花费不少moneyd的人是不是感觉赚到了😉。进入该网站注册成功之后，选择Register a New Domain进行域名申请检验。它可以提供免费的顶级域名有：tk，ml，ga，cf，gq</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-fbce92549a18f65a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p>
<p>选择你喜欢的域名，进入选购界面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-7e7cb240f4d62f4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p>
<p>在Period里面可以选择使用时间，最多是一年的免费使用，顶级域名耶，已经很大的优惠了。当然如果你是土豪这都无所谓了。</p>
<h2 id="为站点添加CNAME文件"><a href="#为站点添加CNAME文件" class="headerlink" title="为站点添加CNAME文件"></a>为站点添加CNAME文件</h2><p>在Hexo的本地站点里，进入source文件，新建文件<code>CNAME</code>，注意没有后缀，打开文件填入刚申请的域名</p>
<blockquote>
<p>zhangferry.tk</p>
</blockquote>
<p>保存。然后发布站点，这时<code>CNAME</code>文件就被发布到了github上对应的站点仓库中</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-c8c19312012904eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p>
<p>CNAME文件的作用：<br>CNAME是一个别名记录，它允许你将多个名字映射到同一台计算机。比如刚才添加的CNAME文件，会被github自动识别，当我们输入<code>zhangferry.github.io</code>和输入<code>zhangferry.tk</code>时，它将指向同一个ip地址，展示同样的内容。</p>
<h2 id="在DNSPOD中配置域名解析"><a href="#在DNSPOD中配置域名解析" class="headerlink" title="在DNSPOD中配置域名解析"></a>在DNSPOD中配置域名解析</h2><p>注册<a href="https://www.dnspod.cn/">DNSPOS</a>账号，进入管理控制台</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-fb90966d0b49e5db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"></p>
<p>点击添加域名，输入我们刚刚申请的域名。确定之后就是进行添加记录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-6ad9908219780e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"></p>
<p>添加记录的每一项，系统都会提示代表意思，这里主要解释记录类型</p>
<ul>
<li>A记录：地址记录，用来指定域名的IP地址</li>
<li>CNAME记录：如果需要将域名指向另一个域名，再由另一个域名提供IP地址，就需要添加CNAME记录</li>
<li>NS记录：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录</li>
</ul>
<p>上面的NS记录是系统默认添加的。</p>
<p>A记录就是指向对应IP地址，这里的<code>192.30.252.153</code>和<code>192.30.252.154</code>是github的服务器IP地址。<br>CNAME记录这里可填可不填，因为A记录已经将zhangferry.tk和<code>zhangferry.github.io</code>的域名统一为一个IP地址了。有一种情况就是为了提高访问速度，要区分国内国外不同用户使用不同的网站进行重定向需要添加对应的CNAME记录。</p>
<h2 id="修改域名DNS"><a href="#修改域名DNS" class="headerlink" title="修改域名DNS"></a>修改域名DNS</h2><p>再回到刚才的域名申请网站，点Services-&gt;My Domains-&gt;Manage Domain-&gt;Management Tools-&gt;Nameservers</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-d709c85c43e6b271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"></p>
<p>将<code>f1g1ns1.dnspod.net</code>和<code>f1g1ns2.dnspod.net</code>填入到Nameserver1和Nameserver中，点击Change Nameservers保存操作。注意到刚填的域名服务就是对应NS记录的记录值。完成之后稍等片刻，DNSPod会有如下提示，否则就按照提示进行检验哪一步出了问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-0cbbb7a554af3145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="07.png"></p>
<h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>之后需要等待全球递归DNS服务器刷新（最多72小时）<br>在命令行执行：<code>$ dig zhangferry.tk</code>，出现以下结果说明配置成功，主要IP地址的对应。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-de44f6a9d62989c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="08.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.isetsuna.com/hexo/domain-dns/">Hexo博客系列：域名和DNS</a><br><a href="http://itcoding.tk/2016/06/26/set-up-custom-domain-for-github-pages/">为你的Github Pages博客绑定一个免费顶级域名吧
 </a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>nRF芯片设备DFU升级（适配Xcode10.2.1）</title>
    <url>/2016/12/28/nRF-DFU-upgrade/</url>
    <content><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2972de5721a39?w=712&h=262&f=png&s=18797" alt="Nordic.png"></p>
<blockquote>
<p>这里主要参考这个项目：<a href="https://github.com/NordicSemiconductor/IOS-nRF-Toolbox">iOS-nRF-Toolbox</a>，它是Nordic公司开发的测试工程，包含一整套nRF设备的测试解决方案。</p>
</blockquote>
<a id="more"></a>

<p>项目是用Swift写的，不过之前还是有OC版本的，但是后来由于一些**（不可描述的问题），才变成了现在的纯Swift版本。对于使用Swift开发的人员，直接仿照Demo操作即可。如果你是用Swift开发的，那下面的内容你可以不用看了。接下来我就讲一下针对OC引用DFU升级的操作步骤和我遇到的问题。</p>
<h2 id="代码研究"><a href="#代码研究" class="headerlink" title="代码研究"></a>代码研究</h2><p>nRF-Toolbox项目包含BGM，HRM，HTM，DFU等多个模块，我们今天只关注其中的DFU升级模块。打开项目，在对应的<code>NORDFUViewController.swift</code>中我们能够看到有三个引用库<br><code>import UIKit</code>,<code>import CoreBluetooth</code>,<code>import iOSDFULibrary</code>，这里的<a href="https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library">iOSDFULibrary</a>就是DFU升级的库，也是解决DFU升级最重要的组件。我们只要把这个库集成到我们的项目中，就能够完成nRF设备的DFU升级了。</p>
<h2 id="集成步骤"><a href="#集成步骤" class="headerlink" title="集成步骤"></a>集成步骤</h2><p>有两种方案集成：</p>
<ul>
<li>通过cocoapods集成</li>
<li>编译出framework然后把库导入项目</li>
</ul>
<p>第一种方案是作者推荐的，但是我试了很久，引入DFULibrary会出现头文件找不到等一系列问题，无奈只能放弃，如果有人通过这种方式成功，还望告知。下面讲的是通过第二种方案的集成。</p>
<p><strong>第一步：导出iOSDFULibrary</strong></p>
<p>这一步是最关键也是最容易出问题的，这个库也是由Swift写成的，我们将这个库clone到本地，然后选择iOSDFULibrary进行编译</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2972c0da5d4ef?w=410&h=175&f=png&s=40355" alt="01.png"></p>
<p>最后生成两个framework:</p>
<ul>
<li>iOSDFULibrary.framework</li>
<li>Zip.framework</li>
</ul>
<p>这时库内的代码已经变成了我们熟悉的OC语言。理论上这个库应该是没问题的了，但是事实还是有问题的，见<a href="https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library/issues/39">issues#39</a>。作者给出的解决方法是：</p>
<blockquote>
<p>1、On your mac please install carthage (<a href="https://github.com/Carthage/Carthage#installing-carthage">instructions</a>)<br>   2、Create a file named cartfile anywhere on your computer<br>   3、add the following content to the file:</p>
</blockquote>
<blockquote>
<pre><code>github &quot;NordicSemiconductor/IOS-Pods-DFU-Library&quot; ~&gt; 2.1.2
github &quot;marmelroy/Zip&quot; ~&gt; 0.6</code></pre><p> 1、Open a new terminal and cd to the directory where the file is<br> 2、Enter the command carthage update –platform iOS<br> 3、Carthage will now take care of building your frameworks, the produced .framework files will be found in a newly created directory called Carthage/Build/iOS,copy over iOSDFULibrary.framework and Zip.framework to your project and you are good to go.</p>
</blockquote>
<p><a href="https://github.com/Carthage/Carthage#installing-carthage">carthage</a>是一种和cocoapods相似的的类库管理工具，如果不会使用的话可以参照Demo，将framework文件导入到自己的项目。</p>
<p><strong>第二步、导入framework</strong><br>Target-&gt;General<br><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2972c0c8a0efa?w=718&h=283&f=jpeg&s=15809" alt="128F494E-C863-49E7-AC44-A7B53B3EB463.png"></p>
<p>直接拖入项目默认只会导入到<code>Linked Frameworks and Libraries</code>，我们还需要在Embeded Binaries中引入。</p>
<p><strong>第三步、使用iOSDFULibrary</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;create a DFUFirmware object using a NSURL to a Distribution Packer(ZIP)</span><br><span class="line">DFUFirmware *selectedFirmware &#x3D; [[DFUFirmware alloc] initWithUrlToZipFile:url];&#x2F;&#x2F; or</span><br><span class="line">&#x2F;&#x2F;Use the DFUServiceInitializer to initialize the DFU process.</span><br><span class="line">DFUServiceInitiator *initiator &#x3D; [[DFUServiceInitiator alloc] initWithCentralManager: centralManager target:selectedPeripheral];</span><br><span class="line">[initiator withFirmware:selectedFirmware];</span><br><span class="line">&#x2F;&#x2F; Optional:</span><br><span class="line">&#x2F;&#x2F; initiator.forceDfu &#x3D; YES&#x2F;NO; &#x2F;&#x2F; default NO</span><br><span class="line">&#x2F;&#x2F; initiator.packetReceiptNotificationParameter &#x3D; N; &#x2F;&#x2F; default is 12</span><br><span class="line">initiator.logger &#x3D; self; &#x2F;&#x2F; - to get log info</span><br><span class="line">initiator.delegate &#x3D; self; &#x2F;&#x2F; - to be informed about current state and errors </span><br><span class="line">initiator.progressDelegate &#x3D; self; &#x2F;&#x2F; - to show progress bar</span><br><span class="line">&#x2F;&#x2F; initiator.peripheralSelector &#x3D; ... &#x2F;&#x2F; the default selector is used</span><br><span class="line"></span><br><span class="line">DFUServiceController *controller &#x3D; [initiator start];</span><br></pre></td></tr></table></figure>
<p>库中有三个代理方法<code>DFUProgressDelegate</code>，<code>DFUServiceDelegate</code>，<code>LoggerDelegate</code>，它们的作用分别为监视DFU升级进度，DFU升级及蓝牙连接状态，打印状态日志。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1、<strong>selectedFirmware返回nil</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DFUFirmware *selectedFirmware &#x3D; [[DFUFirmware alloc] initWithUrlToZipFile:url];</span><br></pre></td></tr></table></figure>
<p>需要在<code>General</code>的<code>Embeded Binaries</code>选项卡里导入那<code>Zip.framework</code>和<code>iOSDFULibrary.framework</code><br>2、<strong>崩溃报错</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">dyld:</span> Library <span class="keyword">not</span> <span class="symbol">loaded:</span> @rpath/libswiftCore.dylibReferenced <span class="symbol">from:</span> /private/var/containers/Bundle/Application/<span class="number">02516</span>D79-BB3<span class="number">0</span>-<span class="number">4278</span>-<span class="number">81</span>B8-<span class="number">3</span>F86BF2AE2A7/XingtelBLE.app/Frameworks/iOSDFULibrary.framework/<span class="symbol">iOSDFULibraryReason:</span> image <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
<p>需要改两个地方<br><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2972c0dc16473?w=1068&h=324&f=png&s=45942" alt="error1.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2972c0deed50a?w=1148&h=308&f=png&s=46299" alt="erro2.png"><br>如果不起作用，将Runpath Search Paths的选项内容删掉再重新添加一遍即可<br>3、<strong>打包上架时报ERROR IT MS-90087等问题</strong><br>问题描述：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">ERROR ITMS-<span class="number">90087</span>: <span class="string">"Unsupported Architectures. The executable for ***.app/Frameworks/SDK.framework contains unsupported architectures '[x86_64, i386]'."</span></span><br><span class="line">ERROR ITMS-<span class="number">90362</span>: <span class="string">"Invalid Info.plist value. The value for the key 'MinimumOSVersion' in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0"</span></span><br><span class="line">ERROR ITMS-<span class="number">90209</span>: <span class="string">"Invalid Segment Alignment. The app binary at '***.app/Frameworks/SDK.framework/SDK' does not have proper segment alignment. Try rebuilding the app with the latest Xcode version."</span></span><br><span class="line">ERROR ITMS-<span class="number">90125</span>: <span class="string">"The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple's linker."</span></span><br></pre></td></tr></table></figure>
<p>解决方法，添加Run Script Phase</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2972c0dc15f54?w=1220&h=390&f=png&s=70833" alt="error3.png"><br>Shell脚本内容填写如下内容，再次编译即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">APP_PATH="$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This script loops through the frameworks embedded <span class="keyword">in</span> the application and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> removes unused architectures.</span></span><br><span class="line">find "$APP_PATH" -name '*.framework' -type d | while read -r FRAMEWORK</span><br><span class="line">do</span><br><span class="line">FRAMEWORK_EXECUTABLE_NAME=$(defaults read "$FRAMEWORK/Info.plist" CFBundleExecutable)</span><br><span class="line">FRAMEWORK_EXECUTABLE_PATH="$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME"</span><br><span class="line">echo "Executable is $FRAMEWORK_EXECUTABLE_PATH"</span><br><span class="line"></span><br><span class="line">EXTRACTED_ARCHS=()</span><br><span class="line"></span><br><span class="line">for ARCH in $ARCHS</span><br><span class="line">do</span><br><span class="line">echo "Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME"</span><br><span class="line">lipo -extract "$ARCH" "$FRAMEWORK_EXECUTABLE_PATH" -o "$FRAMEWORK_EXECUTABLE_PATH-$ARCH"</span><br><span class="line">EXTRACTED_ARCHS+=("$FRAMEWORK_EXECUTABLE_PATH-$ARCH")</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "Merging extracted architectures: $&#123;ARCHS&#125;"</span><br><span class="line">lipo -o "$FRAMEWORK_EXECUTABLE_PATH-merged" -create "$&#123;EXTRACTED_ARCHS[@]&#125;"</span><br><span class="line">rm "$&#123;EXTRACTED_ARCHS[@]&#125;"</span><br><span class="line"></span><br><span class="line">echo "Replacing original executable with thinned version"</span><br><span class="line">rm "$FRAMEWORK_EXECUTABLE_PATH"</span><br><span class="line">mv "$FRAMEWORK_EXECUTABLE_PATH-merged" "$FRAMEWORK_EXECUTABLE_PATH"</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="完整OC项目"><a href="#完整OC项目" class="headerlink" title="完整OC项目"></a>完整OC项目</h2><p>这个是对应Swift版本用OC写的完整项目，应该是OC停止维护之前的版本。会有一些bug。在将DFUFramework更新之后，我把它搬到了我的github上，有需要的同学可以下载研究：<a href="https://github.com/zhangferry/nRF-Toolbox">OC-nRFTool-box</a>。</p>
<hr>
<p>以下为更新内容，时间：2017.12.26<br>收到很多关于无法适配Xcode9.2的反馈，因为最近比较忙没时间处理，不好意思啦，今天抽出时间来把代码更新了一下。</p>
<h2 id="Xcode9-2-出现的问题"><a href="#Xcode9-2-出现的问题" class="headerlink" title="Xcode9.2 出现的问题"></a>Xcode9.2 出现的问题</h2><blockquote>
<p>1、dyld: Library not loaded: @rpath/libswiftCore.dylib<br>Referenced from: /private/var/containers/Bundle/Application/02516D79-BB30-4278-81B8-3F86BF2AE2A7/XingtelBLE.app/Frameworks/iOSDFULibrary.framework/iOSDFULibrary<br>Reason: image not found<br>2、DFUFirmware *selectedFirmware = [[DFUFirmware alloc] initWithUrlToZipFile:url]; 返回为空或者崩溃问题</p>
</blockquote>
<p>我的测试结果是更新iOSDFULibrary. framework和Zip.framework可以解决以上问题。</p>
<h2 id="解决方案-Carthage"><a href="#解决方案-Carthage" class="headerlink" title="解决方案 Carthage"></a>解决方案 Carthage</h2><p>因为这两个库都是通过Swift维护的，所以更新framework最好还是要用适用Swift的方式，包括以后的更新也一样。所以我推荐用Carthage更新这俩库，下面是使用Carthage的简单介绍，详细的可以看这里<a href="https://www.jianshu.com/p/a734be794019">Carthage的安装和使用</a>。<br>另外<a href="https://github.com/zhangferry/nRF-Toolbox">OC-nRFTool-box</a>也已经更新，里面的Framework可以直接拿来用。</p>
<p>1、安装brew</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure>
<p>2、brew更新</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br></pre></td></tr></table></figure>
<p>3、安装Carthage</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install carthage</span></span><br></pre></td></tr></table></figure>
<p>4、使用Carthage</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/路径/项目文件夹 /**进入项目文件夹下*/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch Cartfile /**创建carthage文件*/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> open Cartfile /**打开carthage文件*/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /**输入以下内容*/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> github <span class="string">"NordicSemiconductor/IOS-Pods-DFU-Library"</span> ~&gt; 4.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> github <span class="string">"marmelroy/Zip"</span> ~&gt; 1.1</span></span><br></pre></td></tr></table></figure>
<p>5、运行Carthage</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> carthage update --platform iOS /**编译出iOS版本*/</span></span><br></pre></td></tr></table></figure>
<p>6、更新framework</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Carthage/Build/iOS  /**framework输出位置，将老的framework替换掉*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>nRF Toolbox项目方法变更</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[initiator withFirmwareFile:selectedFirmware];<span class="comment">/** 旧版本方法 */</span></span><br><span class="line">initiator = [initiator withFirmware:selectedFirmware];<span class="comment">/** 新版本方法 */</span></span><br></pre></td></tr></table></figure>

<h2 id="更新：2019-7-14"><a href="#更新：2019-7-14" class="headerlink" title="更新：2019-7-14"></a>更新：2019-7-14</h2><p>针对之前常出的这种问题：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">dyld:</span> Library <span class="keyword">not</span> <span class="symbol">loaded:</span> @rpath/libswiftCore.dylib</span><br><span class="line">Referenced <span class="symbol">from:</span> /private/var/containers/Bundle/Application/CDB2F4ED-C49C-<span class="number">4303</span>-BE1F-<span class="number">5</span>D9D990380F3/nRF Toolbox.app/Frameworks/Zip.framework/Zip</span><br><span class="line"><span class="symbol">Reason:</span> image <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
<p>均是由Swift库版本不一致引起的，<code>iOSDFULibrary</code>目前已经支持到<code>Swift 5</code>，所以我们应该升级一下版本。为了方便使用，我将<code>Carthage</code>集成到了项目里，如果以后需要再升级，更新Cartfile文件里的版本号，执行更新命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ carthage update --platform iOS</span><br></pre></td></tr></table></figure>

<p>如果你想要将DFU的framework集成到你自己的项目里，可以在<code>Carthage/Build/iOS/</code>中找到<code>iOSDFULibrary.framework</code>, <code>ZIPFoundation.framework</code> 将其拖到项目中即可。</p>
<h3 id="上线注意事项（由-jianxiong1997提供）"><a href="#上线注意事项（由-jianxiong1997提供）" class="headerlink" title="上线注意事项（由@jianxiong1997提供）"></a>上线注意事项（由@jianxiong1997提供）</h3><p><img src="https://raw.githubusercontent.com/zhangferry/Images/master/blog/9fd65f10e4416cff5fe61ea9cf1ca4f0.jpg" alt=""><br>需要删除<code>ZIPFoundation.framework</code>中的</p>
<ul>
<li>libswiftRemoteMirror.dylib</li>
<li>Frameworks</li>
</ul>
<p><a href="https://github.com/zhangferry/nRF-Toolbox">github</a>项目同步更新。</p>
]]></content>
      <categories>
        <category>蓝牙总结</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
        <tag>DFU</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo搭建自己的博客小屋</title>
    <url>/2016/12/20/build-blog-by-hexo/</url>
    <content><![CDATA[<blockquote>
<p>作为一名技术人员没有属于自己的博客，就像是喜欢LOL的玩家却没有一款炫酷的皮肤一样，这不叫真爱。虽然现在是微博的时代，讲究方便阅读，易传播，但是对于博客来说，特别是技术博客，专业性永远都是第一位的。我们需要用大大的篇幅去阐述自己对技术的理解并将其分享给其他人，所以无论社交软件如何发展，我们都需要博客。下面就跟着我一块搭建属于自己的博客小屋吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>已经安装Git的Mac电脑，这个默认都能满足，所以就不详细介绍了。</p>
<h2 id="创建github-page"><a href="#创建github-page" class="headerlink" title="创建github page"></a>创建github page</h2><p>首先注册<a href="https://github.com">github</a>账号，然后在repository选项卡里New一个新的仓库来存储我们的网站</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-7ea5a5bdf68d6170.png" alt="01.png"></p>
<p>然后命名为username.github.io。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-6fe4e7bfeaeecca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在安装Hexo之前我们需要安装nvm和Node.js。</p>
<ul>
<li>Hexo是目前很流行的博客管理框架，基于Node.js</li>
<li>nvm是Node.js的版本管理工具</li>
<li>而Node.js是一个基于 <a href="https://developers.google.com/v8/">Chrome V8</a> 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</li>
</ul>
<p>不太理解和想要深入了解各软件作用的同学可以自行google，接下来我们开始安装这些东西（确实挺多的）。</p>
<p>1、<strong>通过curl方式安装node版本管理工具nvm</strong></p>
<pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash</code></pre><p>其他方式的安装可以自行google。</p>
<p>2、<strong>配置环境变量</strong><br>完成之后nvm就被安装在了<code>~/.nvm</code>下，接下来配置环境变量<br>在<code>~/</code>目录下看是否有<code>.zshrc</code>,<code>.bash_profile</code>,或者<code>.profile</code>,如果没有就新建一个<code>.profile</code>文件。<br>注意：<code>.</code>开头的文件是隐藏文件，在终端查看的时候使用命令<code>ls -a</code>,然后打开对应的配置文件在最后一行加上：</p>
<pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</code></pre><p>这一步的目的是每次新打开一个bash，nvm都会被自动添加到环境变量中。<br>3、<strong>验证nvm安装</strong><br>在命令行输入<code>nvm</code>看到如下信息：</p>
<pre><code>Node Version Manager

Note: &lt;version&gt; refers to any version-like string nvm understands. This includes:
- full or partial version numbers, starting with an optional &quot;v&quot; (0.10, v0.1.2, v1)
- default (built-in) aliases: node, stable, unstable, iojs, system
- custom aliases you define with `nvm alias foo`

Usage:
nvm help                                  Show this message
nvm --version                             Print out the latest released version of nvm
nvm install [-s] &lt;version&gt;                Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available
--reinstall-packages-from=&lt;version&gt;     When installing, reinstall packages installed in &lt;node|iojs|node version number&gt;
nvm uninstall &lt;version&gt;                   Uninstall a version
nvm use [--silent] &lt;version&gt;              Modify PATH to use &lt;version&gt;. Uses .nvmrc if available
nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available
nvm run [--silent] &lt;version&gt; [&lt;args&gt;]     Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available
nvm current                               Display currently activated version
nvm ls                                    List installed versions
nvm ls &lt;version&gt;                          List versions matching a given description
(usually `~/.nvm`)</code></pre><p>那么恭喜你！nvm安装成功了。这一步在我看来是最容易出错的。</p>
<p>4、<strong>安装node.js</strong><br>如果上面的步骤完成了，node.js的安装就简单多了，直接：</p>
<pre><code>nvm install node</code></pre><p>这个指令是安装最新版node<br>安装成功后可以使用nvm ls查看当前node版本号</p>
<p>5、<strong>安装Hexo</strong><br>安装Hexo也比较简单</p>
<pre><code>sudo npm install hexo-cli -g</code></pre><h2 id="配置Hexo站点"><a href="#配置Hexo站点" class="headerlink" title="配置Hexo站点"></a>配置Hexo站点</h2><p>完成所需组建的安装，接下来就要建立本地站点，配置站点了。</p>
<p>1、<strong>本地新建博客目录</strong><br>目录可以自由选择，我选择在主目录下：</p>
<pre><code>~$ mkdir username.github.io
~$ cd username.github.io
~$ hexo init username.github.io</code></pre><p>2、<strong>配置站点</strong></p>
<p>在站点下有一个<code>_config.yml</code>，这里我们可以进行一些对博客的配置</p>
<pre><code>language: en #语言设置
theme: next #主题设置，因为下面将使用next主题
deploy:
type: git
repo: https://github.com/username/username.github.io.git</code></pre><p>这里的repo就是我们新建仓库的git地址，之后发布的时候就会将内容发布到这个地址下。更多设置可以查看<a href="https://hexo.io/zh-cn/docs/configuration.html">更多Hexo配置</a></p>
<p>3、<strong>配置主题</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-14d7e7cf2fecebda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p>
<p>我使用的是目前最受欢迎的一款Hexo主题<a href="http://theme-next.iissnan.com/">Next</a>使用它的话，我们需要先把它clone到本地</p>
<pre><code>$ cd username.github.io
$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>在theme文件夹内也有一个<code>_config.yml</code>文件，这里是用来配置主题的，<a href="http://theme-next.iissnan.com/theme-settings.html">详细设置</a></p>
<h2 id="新建、发布博客"><a href="#新建、发布博客" class="headerlink" title="新建、发布博客"></a>新建、发布博客</h2><p>经过上面的努力终于可以开心的写博客了，Hexo博客是基于Markdown格式编译的，所以，我们需要了解常用的Markdown语法，不了解Markdown的可以点这里参考<a href="https://segmentfault.com/markdown#articleHeader15">Markdown</a>，以下命令均在博客站点目录操作</p>
<p>1、<strong>新建</strong></p>
<pre><code>hexo new &quot;my blog&quot;</code></pre><p>文件生成在<code>username/source/_posts/my-blog.md</code>，打开文件，利用markdown语法将内容写到里面。</p>
<p>2、<strong>编译</strong></p>
<pre><code>hexo generate //可以简写为hexo g</code></pre><p>这一步的作用是将刚才的markdown语法的博客内容编译成html语言。编译之后生成<code>public</code>文件夹，里面放的是生成的html文件。之后同步到github上的就是这个文件夹的内容。</p>
<p>3、** 开启本地服务**</p>
<pre><code>hexo server //可以简写hexo s</code></pre><p>这个命令的作用是开启本地服务。之后会有下面两条语句生成</p>
<pre><code>INFO  Start processing
INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p>我们就可以访问 <a href="http://localhos:4000/">http://localhos:4000/</a>预览博客内容了。</p>
<p>4、<strong>部署</strong></p>
<pre><code>hexo deploy //可以简写为 hexo d</code></pre><p>部署的作用就是将博客内容发布到网络。执行完成之后我们就可以访问<a href="http://username.github.io">http://username.github.io</a>了，当你能够看到自己写的内容呈现在自己眼前的时候有没有很激动呢。哈哈</p>
<p>5、<strong>清楚public内容</strong></p>
<pre><code>hexo clean </code></pre><p>这个命令用在当我们更改source内部的资源路径之后，执行此命令可以重新编译生成public文件夹。</p>
<hr>
<p>好了，讲解到此结束，下一篇讲解如何发布博客到指定域名。这个是我的博客<a href="http://zhangferry.tk">http://zhangferry.tk</a>，欢迎访问</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS蓝牙中的进制转换</title>
    <url>/2016/12/12/bluetooth-number-transform/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1059465-e8b76e6d8dcb9416.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bluetooth4.0.jpg"><br>最近在忙一个蓝牙项目，在处理蓝牙数据的时候，经常遇到进制之间的转换，蓝牙处理的是16进制（NSData），而我们习惯的计数方式是10进制，为了节省空间，蓝牙也会把16进制（NSData）拆成2进制记录。这里我们研究下如何在他们之间进行转换。</p>
<a id="more"></a>
<p><strong>假设我们要向蓝牙发送0x1B9901这条数据</strong></p>
<h2 id="Byte转NSData"><a href="#Byte转NSData" class="headerlink" title="Byte转NSData"></a>Byte转NSData</h2><pre><code>Byte value[3]={0};
value[0]=0x1B;
value[1]=0x99;
value[2]=0x01;
NSData * data = [NSData dataWithBytes:&amp;value length:sizeof(value)];
//发送数据
[self.peripheral writeValue:data forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse];</code></pre><ul>
<li><p>优点：这种方法比较简单，没有进行转换，直接一个字节一个字节的拼装好发送出去。</p>
</li>
<li><p>缺点：当发送数据比较长时会很麻烦，而且不易更改。</p>
</li>
</ul>
<h2 id="NSString转NSData"><a href="#NSString转NSData" class="headerlink" title="NSString转NSData"></a>NSString转NSData</h2><pre><code>- (NSData *)hexToBytes:(NSString *)str
{
    NSMutableData* data = [NSMutableData data];
    int idx;
    for (idx = 0; idx+2 &lt;= str.length; idx+=2) {
        NSRange range = NSMakeRange(idx, 2);
        NSString* hexStr = [str substringWithRange:range];
        NSScanner* scanner = [NSScanner scannerWithString:hexStr];
        unsigned int intValue;
        [scanner scanHexInt:&amp;intValue];
        [data appendBytes:&amp;intValue length:1];
    }
    return data;
}
//发送数据
[self.peripheral writeValue:[self hexToBytes:@&quot;1B9901&quot;] forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse];</code></pre><ul>
<li>优点：比较直观，可以一次转换一长条数据，对于一些功能简单的蓝牙程序，这种转换能处理大部分情况。</li>
<li>缺点：只能发送一些固定的指令，不能参与计算。</li>
</ul>
<hr>
<h2 id="求校验和"><a href="#求校验和" class="headerlink" title="求校验和"></a>求校验和</h2><p>接下来探讨下发送的数据需要计算的情况。<br>最常用的发送数据需要计算的场景是求<strong>校验和（CHECKSUM）</strong>。这个根据硬件厂商来定，常见的求校验和的规则有：</p>
<ul>
<li>如果发送数据长度为n字节，则CHECKSUM为前n-1字节之和的低字节</li>
<li>CHECKSUM=0x100-CHECKSUM（上一步的校验和）</li>
</ul>
<p>如果我要发送带上校验和的0x1B9901，方法就是：<br>    - (NSData *)getCheckSum:(NSString *)byteStr{<br>        int length = (int)byteStr.length/2;<br>        NSData *data = [self hexToBytes:byteStr];<br>        Byte *bytes = (unsigned char *)[data bytes];<br>        Byte sum = 0;<br>        for (int i = 0; i&lt;length; i++) {<br>            sum += bytes[i];<br>        }<br>        int sumT = sum;<br>        int at = 256 -  sumT;</p>
<pre><code>    printf(&quot;校验和：%d\n&quot;,at);
    if (at == 256) {
        at = 0;
    }
    NSString *str = [NSString stringWithFormat:@&quot;%@%@&quot;,byteStr,[self ToHex:at]];
    return [self hexToBytes:str];
}

//将十进制转化为十六进制
- (NSString *)ToHex:(int)tmpid
{
    NSString *nLetterValue;
    NSString *str =@&quot;&quot;;
    int ttmpig;
    for (int i = 0; i&lt;9; i++) {
        ttmpig=tmpid%16;
        tmpid=tmpid/16;
        switch (ttmpig)
        {
            case 10:
                nLetterValue =@&quot;A&quot;;break;
            case 11:
                nLetterValue =@&quot;B&quot;;break;
            case 12:
                nLetterValue =@&quot;C&quot;;break;
            case 13:
                nLetterValue =@&quot;D&quot;;break;
            case 14:
                nLetterValue =@&quot;E&quot;;break;
            case 15:
                nLetterValue =@&quot;F&quot;;break;
            default:
                nLetterValue = [NSString stringWithFormat:@&quot;%u&quot;,ttmpig];

        }
        str = [nLetterValue stringByAppendingString:str];
        if (tmpid == 0) {
            break;
        }
    }
//不够一个字节凑0
    if(str.length == 1){
        return [NSString stringWithFormat:@&quot;0%@&quot;,str];
    }else{
        return str;
    }
}
//发送数据
NSData *data = [self getCheckSum:@&quot;1B9901&quot;];//data=&lt;1b99014b&gt;
[self.peripheral writeValue:data forCharacteristic:self.write type:CBCharacteristicWriteWithoutResponse];</code></pre><h2 id="拆分数据"><a href="#拆分数据" class="headerlink" title="拆分数据"></a>拆分数据</h2><p>这种是比较麻烦的，举个栗子：在传输某条信息时，我想把时间放进去，不能用时间戳，还要节省空间，这样就出现了一种新的方式存储时间。<br>这里再补充一些C语言知识：</p>
<ul>
<li>一个字节8位（bit）</li>
<li>char 1字节 int 4字节 unsigned 2字节 float 4字节</li>
</ul>
<p>存储时间的条件是：</p>
<ul>
<li>只用四个字节（32位）</li>
<li>前5位表示年（从2000年算起），接着4位表示月，接着5位表示日，接着5位表示时，接着6位表示分，接着3位表示星期，剩余4位保留。</li>
</ul>
<p>这样直观的解决办法就是分别取出现在时间的年月日时分星期，先转成2进制，再转成16进制发出去。当然你这么写进去，读的时候就要把16进制数据先转成2进制再转成10进制显示。我们就按这个简单粗暴的思路来，准备工作如下：</p>
<h3 id="10进制转2进制"><a href="#10进制转2进制" class="headerlink" title="10进制转2进制"></a>10进制转2进制</h3><pre><code>//  十进制转二进制
- (NSString *)toBinarySystemWithDecimalSystem:(int)num length:(int)length
{
    int remainder = 0;      //余数
    int divisor = 0;        //除数

    NSString * prepare = @&quot;&quot;;

    while (true)
    {
        remainder = num%2;
        divisor = num/2;
        num = divisor;
        prepare = [prepare stringByAppendingFormat:@&quot;%d&quot;,remainder];

        if (divisor == 0)
        {
            break;
        }
    }
    //倒序输出
    NSString * result = @&quot;&quot;;
    for (int i = length -1; i &gt;= 0; i --)
    {
        if (i &lt;= prepare.length - 1) {
            result = [result stringByAppendingFormat:@&quot;%@&quot;,
                      [prepare substringWithRange:NSMakeRange(i , 1)]];

        }else{
            result = [result stringByAppendingString:@&quot;0&quot;];

        }
    }
    return result;
}
### 2进制转10进制
//  二进制转十进制
- (NSString *)toDecimalWithBinary:(NSString *)binary
{
    int ll = 0 ;
    int  temp = 0 ;
    for (int i = 0; i &lt; binary.length; i ++)
    {
        temp = [[binary substringWithRange:NSMakeRange(i, 1)] intValue];
        temp = temp * powf(2, binary.length - i - 1);
        ll += temp;
    }

    NSString * result = [NSString stringWithFormat:@&quot;%d&quot;,ll];

    return result;
}
### 16进制和2进制互转
- (NSString *)getBinaryByhex:(NSString *)hex binary:(NSString *)binary
{
    NSMutableDictionary  *hexDic = [[NSMutableDictionary alloc] init];
    hexDic = [[NSMutableDictionary alloc] initWithCapacity:16];
    [hexDic setObject:@&quot;0000&quot; forKey:@&quot;0&quot;];
    [hexDic setObject:@&quot;0001&quot; forKey:@&quot;1&quot;];
    [hexDic setObject:@&quot;0010&quot; forKey:@&quot;2&quot;];
    [hexDic setObject:@&quot;0011&quot; forKey:@&quot;3&quot;];
    [hexDic setObject:@&quot;0100&quot; forKey:@&quot;4&quot;];
    [hexDic setObject:@&quot;0101&quot; forKey:@&quot;5&quot;];
    [hexDic setObject:@&quot;0110&quot; forKey:@&quot;6&quot;];
    [hexDic setObject:@&quot;0111&quot; forKey:@&quot;7&quot;];
    [hexDic setObject:@&quot;1000&quot; forKey:@&quot;8&quot;];
    [hexDic setObject:@&quot;1001&quot; forKey:@&quot;9&quot;];
    [hexDic setObject:@&quot;1010&quot; forKey:@&quot;a&quot;];
    [hexDic setObject:@&quot;1011&quot; forKey:@&quot;b&quot;];
    [hexDic setObject:@&quot;1100&quot; forKey:@&quot;c&quot;];
    [hexDic setObject:@&quot;1101&quot; forKey:@&quot;d&quot;];
    [hexDic setObject:@&quot;1110&quot; forKey:@&quot;e&quot;];
    [hexDic setObject:@&quot;1111&quot; forKey:@&quot;f&quot;];

    NSMutableString *binaryString=[[NSMutableString alloc] init];
    if (hex.length) {
        for (int i=0; i&lt;[hex length]; i++) {
            NSRange rage;
            rage.length = 1;
            rage.location = i;
            NSString *key = [hex substringWithRange:rage];
            [binaryString appendString:hexDic[key]];
        }

    }else{
        for (int i=0; i&lt;binary.length; i+=4) {
            NSString *subStr = [binary substringWithRange:NSMakeRange(i, 4)];
            int index = 0;
            for (NSString *str in hexDic.allValues) {
                index ++;
                if ([subStr isEqualToString:str]) {
                    [binaryString appendString:hexDic.allKeys[index-1]];
                    break;
                }
            }
        }
    }
    return binaryString;
}</code></pre><p>有了这几种转换函数，完成上面的功能就容易多了，具体怎么操作这里就不写一一出来了。但总感觉怪怪的，这么一个小功能怎么要写这么一大堆代码，当然还可以用C语言的方法去解决。这里主要是为了展示iOS中数据如何转换，C语言的实现方法这里就不写了，有兴趣的同学可以研究下。</p>
<h2 id="附带两个函数"><a href="#附带两个函数" class="headerlink" title="附带两个函数"></a>附带两个函数</h2><p><strong>int转NSData</strong><br>    - (NSData *) setId:(int)Id {<br>    //用4个字节接收<br>        Byte bytes[4];<br>        bytes[0] = (Byte)(Id&gt;&gt;24);<br>        bytes[1] = (Byte)(Id&gt;&gt;16);<br>        bytes[2] = (Byte)(Id&gt;&gt;8);<br>        bytes[3] = (Byte)(Id);<br>        NSData *data = [NSData dataWithBytes:bytes length:4];<br>    }<br><strong>NSData转int</strong><br>接受到的数据<code>0x00000a0122</code></p>
<pre><code>//4字节表示的int
NSData *intData = [data subdataWithRange:NSMakeRange(2, 4)];
    int value = CFSwapInt32BigToHost(*(int*)([intData bytes]));//655650
//2字节表示的int
NSData *intData = [data subdataWithRange:NSMakeRange(4, 2)];
    int value = CFSwapInt16BigToHost(*(int*)([intData bytes]));//290
//1字节表示的int
char *bs = (unsigned char *)[[data subdataWithRange:NSMakeRange(5, 1) ] bytes];
    int value = *bs;//34
------------------------
//补充内容，因为没有三个字节转int的方法，这里补充一个通用方法
- (unsigned)parseIntFromData:(NSData *)data{

       NSString *dataDescription = [data description];
       NSString *dataAsString = [dataDescription substringWithRange:NSMakeRange(1, [dataDescription length]-2)];

       unsigned intData = 0;
       NSScanner *scanner = [NSScanner scannerWithString:dataAsString];
       [scanner scanHexInt:&amp;intData];
    return intData;
}</code></pre><p>这两个转换在某些场景下使用频率也是挺高的，蓝牙里面的数据转换基本也就这么多了，希望能够帮助大家。<br>更多关于字节编码的问题，大家可以点这里：<a href="http://www.doc88.com/p-2905571595364.html>">传送门</a></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>基于CoreBluetooth4.0框架的连接BLE4.0的Demo：<a href="https://github.com/zhangferry/FYBluetooth">你不点一下吗</a></p>
]]></content>
      <categories>
        <category>蓝牙总结</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS获取来电和短信发送状态</title>
    <url>/2016/12/12/calling-and-sms-state/</url>
    <content><![CDATA[<h2 id="获取电话状态"><a href="#获取电话状态" class="headerlink" title="获取电话状态"></a>获取电话状态</h2><p>在我想要了解iOS获取来电状态时，经常被这是不是允许的，是不是要调用私有库等问题困扰。费了好大劲终于解决了上面问题，你可以获取系统提供的电话相关状态，而且它不属于私有库。为了需要这方面资料的人查阅时少走弯路，我把这些东西写下来，废话少说，上代码。</p>
<a id="more"></a>
<h3 id="如何获取电话状态"><a href="#如何获取电话状态" class="headerlink" title="如何获取电话状态"></a>如何获取电话状态</h3><p>首先要导入CoreTelephony框架：<br><code>@import CoreTelephony;</code></p>
<p>然后声明一个CTCallCenter变量：</p>
<pre><code>@interface ViewController () {  
CTCallCenter *center_;   //为了避免形成retain cycle而声明的一个变量，指向接收通话中心对象
}  </code></pre><p>@end<br>然后监听电话状态：</p>
<pre><code>- (void) aboutCall{   
//获取电话接入信息
callCenter.callEventHandler = ^(CTCall *call){
if ([call.callState isEqualToString:CTCallStateDisconnected]){
NSLog(@&quot;Call has been disconnected&quot;);

}else if ([call.callState isEqualToString:CTCallStateConnected]){
NSLog(@&quot;Call has just been connected&quot;);

}else if([call.callState isEqualToString:CTCallStateIncoming]){
NSLog(@&quot;Call is incoming&quot;);

}else if ([call.callState isEqualToString:CTCallStateDialing]){
NSLog(@&quot;call is dialing&quot;);

}else{
NSLog(@&quot;Nothing is done&quot;);
}
};
}</code></pre><p>还可以获取运营商信息：</p>
<pre><code>- (void)getCarrierInfo{
// 获取运营商信息
CTTelephonyNetworkInfo *info = [[CTTelephonyNetworkInfo alloc] init];
CTCarrier *carrier = info.subscriberCellularProvider;
NSLog(@&quot;carrier:%@&quot;, [carrier description]);

// 如果运营商变化将更新运营商输出
info.subscriberCellularProviderDidUpdateNotifier = ^(CTCarrier *carrier) {
NSLog(@&quot;carrier:%@&quot;, [carrier description]);
};

// 输出手机的数据业务信息
NSLog(@&quot;Radio Access Technology:%@&quot;, info.currentRadioAccessTechnology);
}    </code></pre><p>当然这样在真机进行测试，以下为输出信息：</p>
<pre><code>2015-12-29 16:34:14.525 RWBLEManagerDemo[1489:543655] carrier:CTCarrier (0x134e065c0) {
Carrier name: [中国移动]
Mobile Country Code: [460]
Mobile Network Code:[07]
ISO Country Code:[cn]
Allows VOIP? [YES]
}
2015-12-29 16:34:14.526 RWBLEManagerDemo[1489:543655] Radio Access Technology:CTRadioAccessTechnologyHSDPA    </code></pre><h3 id="CoreTelephony框架是不是私有库"><a href="#CoreTelephony框架是不是私有库" class="headerlink" title="CoreTelephony框架是不是私有库"></a>CoreTelephony框架是不是私有库</h3><p>私有框架的目录为：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/PrivateFrameworks/</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-3d7bb9f8ff9ce3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FDC2B801-0F1C-41FD-A9A4-399592DF4BEF.png"></p>
<p>可以看出CoreTelephony框架是在frameworks内而不是PrivateFrameworks，所以它是可以放心使用的。网上之所以有说CoreTelephony是私有库，是因为在iOS6的时候是私有框架，后来苹果又给公开了。</p>
<h2 id="获取短信状态"><a href="#获取短信状态" class="headerlink" title="获取短信状态"></a>获取短信状态</h2><p>关于短信的状态获取，我直接看了<br><code>#import &lt;MessageUI/MessageUI.h&gt;</code><br>里面就两个头文件：</p>
<p><code>#import &lt;MessageUI/MFMailComposeViewController.h&gt;</code><br><code>#import &lt;MessageUI/MFMessageComposeViewController.h&gt;</code><br>一个是邮件相关的方法，一个短信相关的方法。进到MFMessageComposeViewController.h有一个枚举值：</p>
<pre><code>enum MessageComposeResult {
MessageComposeResultCancelled,
MessageComposeResultSent,
MessageComposeResultFailed
};</code></pre><p>typedef enum MessageComposeResult MessageComposeResult;   // available in iPhone 4.0<br>这是表示短信发送状态的值。要使用这个框架发送自己编辑的内容还需要添加代理：<code>MFMessageComposeViewControllerDelegate</code></p>
<p>代码如下：</p>
<pre><code>- (void)showMessageView
{
if( [MFMessageComposeViewController canSendText] )// 判断设备能不能发送短信
    {
    MFMessageComposeViewController*picker = [[MFMessageComposeViewControlleralloc] init];
    // 设置委托
    picker.messageComposeDelegate= self;
    // 默认信息内容
    picker.body = @&quot;nihao&quot;;
    // 默认收件人(可多个)
    picker.recipients = [NSArray arrayWithObject:@&quot;12345678901&quot;, nil];
    [self presentModalViewController:picker animated:YES];
    [picker release];
    }
    else
    {
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;提示信息&quot;
    message:@&quot;该设备不支持短信功能&quot;
    delegate:self
    cancelButtonTitle:nil
    otherButtonTitles:@&quot;确定&quot;, nil];
    [alert show];
    [alert release];
    }
}

- (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result
{
    switch (result){
    case MessageComposeResultCancelled:
    NSLog(@&quot;取消发送&quot;);
    break;
    case MessageComposeResultFailed:
    NSLog(@&quot;发送失败&quot;);
    break;
    case MessageComposeResultSent:
    NSLog(@&quot;发送成功&quot;);
    break;

    default:
    break;
    }
}</code></pre><p>对于来短信的通知没有找到，应该是不能获取的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>private framework使用<br><a href="http://chenjohney.blog.51cto.com/4132124/1288551">http://chenjohney.blog.51cto.com/4132124/1288551</a> </li>
<li>CoreTelephony框架的简单使用<br><a href="http://blog.csdn.net/jymn_chen/article/details/19240903">http://blog.csdn.net/jymn_chen/article/details/19240903</a>  </li>
<li>iOS关于系统短信和电话的调用<br><a href="http://blog.csdn.net/frank_jb/article/details/49815883">http://blog.csdn.net/frank_jb/article/details/49815883</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS知识点</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>处理ANCS设备连接绑定问题</title>
    <url>/2016/10/14/ancs-bind/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1059465-f45041c3c8cf024b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ANCS.jpg"></p>
<p><a href="https://developer.apple.com/library/content/documentation/CoreBluetooth/Reference/AppleNotificationCenterServiceSpecification/Introduction/Introduction.html">ANCS</a>（Apple Notification Center Service，苹果通知中心）的目的是提供给蓝牙外设一种简单、方便的获取iOS设备通知信息的方式。使得蓝牙手环，手表可以接收到来自iPhone的来电、短信及QQ、微信等应用的通知消息。</p>
<a id="more"></a>
<p>如果你已经能够连接普通蓝牙，初次面对ANCS设备可能会有以下问题：</p>
<blockquote>
<p>问题一：遵循ANCS协议的的设备会直接和系统相连，即使杀掉应用，连接还是存在的。而如果蓝牙设备处于连接状态，它不会被扫描到，怎么再次连接呢？</p>
</blockquote>
<p>在Core Bluetooth framework里提供了两个方法，用于获取已连接的设备</p>
<pre><code>//通过传入的peripherals.identifier返回与系统连接的已知设备数组
- (NSArray&lt;CBPeripheral *&gt; *)retrievePeripheralsWithIdentifiers:(NSArray&lt;NSUUID *&gt; *)identifiers;
//通过传入设备的serviceID返回已连接的设备数组
- (NSArray&lt;CBPeripheral *&gt; *)retrieveConnectedPeripheralsWithServices:(NSArray&lt;CBUUID *&gt; *)serviceUUIDs;</code></pre><p>我们就可以通过这两个方法，获取已连接设备，并建立重连。参考代码：</p>
<pre><code>NSArray *peripherals = [central retrieveConnectedPeripheralsWithServices:@[serviceUUID]];
if (peripherals.count &gt; 0) {
    CBPeripheral *peripheral = [peripherals firstObject];
    peripheral.delegate = self;
    self.peripheral = peripheral;//**关键**需要转存外设值，才能发起连接
    [central connectPeripheral:self.peripheral options:nil];
} else {
    [central scanForPeripheralsWithServices:@[serviceUUID] options:nil];
}</code></pre><p>根据不同的使用情况，可能会有不同的扫描，连接的逻辑，苹果提供了一个流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-ee5970ce54abaaed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="workflow.png"></p>
<blockquote>
<p>问题二：有绑定和解除功能，如何处理两者的关系</p>
</blockquote>
<p>首先我们要知道，不能通过代码，断开ANCS设备与系统之间的连接，那么如果我们想解除设备的绑定，只能控制设备与APP之间的断开。</p>
<p>###绑定<br>再回看上面提到的苹果提供的两个获取已连接设备的方法，一个是通过<code>serviceUUID</code>，它可以返回同一类型的设备列表；一个是通过设备UUID，它在一定情况下就是唯一的（如果设备名唯一，这里可以使用设备名），返回的是唯一设备。那么我们就可以利用UUID的唯一性，作为绑定的标示，存到<code>NSUserDefault</code>里面，对于未绑定的设备通过<code>serviceUUID</code>去获取设备列表。参考代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *userDefault = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line"><span class="built_in">NSString</span> *uuidString = [userDefault objectForKey:RWBLE_BANDIDENTIFI_ID];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSArray</span> *peripherals;</span><br><span class="line"><span class="keyword">if</span> (uuidString) &#123;</span><br><span class="line">        <span class="comment">//通过uuid获取连接设备</span></span><br><span class="line">    <span class="built_in">NSUUID</span> *uuid = [[<span class="built_in">NSUUID</span> alloc] initWithUUIDString:uuidString];</span><br><span class="line">        peripherals = [<span class="keyword">self</span>.centralManager retrievePeripheralsWithIdentifiers:@[uuid]];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//通过serviceUUID获取连接设备</span></span><br><span class="line">        peripherals = [<span class="keyword">self</span>.centralManager retrieveConnectedPeripheralsWithServices:@[[CBUUID UUIDWithString:ST_SERVICE_UUID]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* peripherals connect code */</span></span><br></pre></td></tr></table></figure>
<p>###解绑<br>不能使ANCS设备与系统连接断开，那么我们就在程序里销毁这个外设对象，这样APP与蓝牙设备的连接通讯就不存在了，造成了一种断开的感觉。参考代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解绑设备</span></span><br><span class="line">- (<span class="keyword">void</span>)unbindDevice&#123;</span><br><span class="line">    [<span class="keyword">self</span> disconnect];<span class="comment">//通知app，设备已经断开</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSUserDefaults</span> *userDefault = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    [userDefault removeObjectForKey:RWBLE_BANDIDENTIFI_ID];<span class="comment">//销毁uuid</span></span><br><span class="line">    <span class="keyword">self</span>.peripheral = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么写看似已经解决问题了，但是会出现一种情况：解绑了设备，杀掉应用，再次进入设备还是能连上。why?因为虽然没有了UUID，但进入程序会通过<code>serviceUUID</code>再次获取连接。</p>
<p>这时可以在扫面做一个判断，是否刚解绑过设备。可以是个BOOL值，绑定和初始绑定为NO，解绑操作改为YES。如果刚解绑过设备，就直接返回不做后面的扫描操作，这样就解决了上面的问题。这个比较简单，就不列具体代码了。</p>
<p>参考文档：<br><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/BestPracticesForInteractingWithARemotePeripheralDevice/BestPracticesForInteractingWithARemotePeripheralDevice.html#//apple_ref/doc/uid/TP40013257-CH6-SW11">Best Practices for Interacting with a Remote Peripheral Device</a></p>
]]></content>
      <categories>
        <category>蓝牙总结</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
        <tag>ANCS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS10本地通知UserNotifications快速入门</title>
    <url>/2016/09/30/usernotifications-introduction/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1059465-24a743794b38b19c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification.png"></p>
<p>iOS10更新变动最大的就是通知这部分了，新版通知变得更加统一，使用更加方便，设计更加自由。以前本地通知和远程推送是分开的，虽然这些到了iOS10都合在一起了，但是为了便于理解，我们还是把他俩分开来进行学习。这节我们学习的是本地通知。</p>
<a id="more"></a>
<p>以下的用语，如无特别表述，<code>通知</code>就代表本地通知，<code>推送</code>就代表远程服务器的推送。</p>
<p>##快速添加一个通知<br>我们先举个完整的代码例子，大家了解下这个流程，然后分步介绍这几项：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：注册通知</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">    <span class="comment">//请求获取通知权限（角标，声音，弹框）</span></span><br><span class="line">    [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted) &#123;</span><br><span class="line">            <span class="comment">//获取用户是否同意开启通知</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"request authorization successed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步：新建通知内容对象</span></span><br><span class="line">    UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init]</span><br><span class="line">    content.title = <span class="string">@"iOS10通知"</span>;</span><br><span class="line">    content.subtitle = <span class="string">@"新通知学习笔记"</span>;</span><br><span class="line">    content.body = <span class="string">@"新通知变化很大，之前本地通知和远程推送是两个类，现在合成一个了。这是一条测试通知，"</span>;</span><br><span class="line">    content.badge = @<span class="number">1</span>;</span><br><span class="line">    UNNotificationSound *sound = [UNNotificationSound soundNamed:<span class="string">@"caodi.m4a"</span>];</span><br><span class="line">    content.sound = sound;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：通知触发机制。（重复提醒，时间间隔要大于60s）</span></span><br><span class="line">    UNTimeIntervalNotificationTrigger *trigger1 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:<span class="number">5</span> repeats:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：创建UNNotificationRequest通知请求对象</span></span><br><span class="line">    <span class="built_in">NSString</span> *requertIdentifier = <span class="string">@"RequestIdentifier"</span>;</span><br><span class="line">    UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requertIdentifier content:content trigger:trigger1];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：将通知加到通知中心</span></span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error:%@"</span>,error);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-6d61819c9bfd09dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification01.png"></p>
<blockquote>
<p>通知内容UNMutableNotificationContent</p>
</blockquote>
<p>通知内容就是设定通知的一些展示信息，iOS10之后可以设置subtitle。<br>声音的设置需要借助一个新类<code>UNNotificationSound</code>，通知文件要放到bundle里面。另外在实际的测试过程中发现，添加通知的声音有时候会无效。这应该是iOS10存在的一个bug，删除掉程序，再安装运行就好了。</p>
<blockquote>
<p>触发机制UNNotificationTrigger</p>
</blockquote>
<p>Trigger是新加入的一个功能，通过此类可设置本地通知触发条件。它一共有一下几种类型：<br>1、UNPushNotificaitonTrigger<br>推送服务的Trigger，由系统创建<br>2、UNTimeIntervalNotificaitonTrigger<br>时间触发器，可以设置多长时间以后触发，是否重复。如果设置重复，重复时长要大于60s<br>3、UNCalendarNotificaitonTrigger<br>日期触发器，可以设置某一日期触发。例如，提醒我每天早上七点起床：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDateComponents</span> *components = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">components.hour = <span class="number">7</span>;</span><br><span class="line">components.minute = <span class="number">0</span>; <span class="comment">// components 日期         UNCalendarNotificationTrigger *calendarTrigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES];</span></span><br></pre></td></tr></table></figure>
<p> 4、UNLocationNotificaitonTrigger<br>位置触发器，用于到某一范围之后，触发通知。通过CLRegion设定具体范围。</p>
<blockquote>
<p>通知请求UNNotificationRequest</p>
</blockquote>
<p>通知请求的构造<br><code>+ (instancetype)requestWithIdentifier:(NSString *)identifier 
content:(UNNotificationContent *)content 
trigger:(nullable UNNotificationTrigger *)trigger;</code><br>就是把上面三项连接起来。它有一个参数identifier，这相当于通知的一个身份。iOS10通知支持更新，就是基于此identifier再发一条通知。</p>
<blockquote>
<p>通知中心UNUserNotificationCenter</p>
</blockquote>
<p>获取通知<code>[UNUserNotificationCenter currentNotificationCenter]</code>然后通过<code>addNotificaitonRequest:</code>就完成了一个通知的添加。</p>
<p>##扩展通知的内容<br>通知我们已经添加上了，现在我们需要扩展一下通知的内容，给它加一些内容。扩展的内容需要支持3D-touch的手机（6s以上），重压之后全面显示</p>
<blockquote>
<p>添加附件</p>
</blockquote>
<p>iOS10之前通知的样式不能更改，在iOS10之后引入了UNNotificationationAttachment，可以在通知中添加图片，音频，视频。苹果对这些附件的大小和类型有一个限制：<br><img src="http://upload-images.jianshu.io/upload_images/1059465-f41c6386d613fbd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attachment_type.png"><br>如果我想在通知里加一个图片，可以这样处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *imageFile = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"sport"</span> ofType:<span class="string">@"png"</span>];</span><br><span class="line">UNNotificationAttachment *imageAttachment = [UNNotificationAttachment attachmentWithIdentifier:<span class="string">@"iamgeAttachment"</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:imageFile] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">content.attachments = @[imageAttachment];<span class="comment">//虽然是数组，但是添加多个只能显示第一个</span></span><br><span class="line"><span class="comment">/* add request and notificaiton code ... */</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-a459ae47a216b686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification02.png"><br>重压之后：<br><img src="http://upload-images.jianshu.io/upload_images/1059465-6572c5180d447cbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notificaiton03.png"></p>
<blockquote>
<p>添加交互</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击可以显示文本输入框</span></span><br><span class="line">UNTextInputNotificationAction *action1 = [UNTextInputNotificationAction actionWithIdentifier:<span class="string">@"replyAction"</span> title:<span class="string">@"文字回复"</span> options:UNNotificationActionOptionNone];</span><br><span class="line">    <span class="comment">//点击进入应用</span></span><br><span class="line">UNNotificationAction *action2 = [UNNotificationAction actionWithIdentifier:<span class="string">@"enterAction"</span> title:<span class="string">@"进入应用"</span> options:UNNotificationActionOptionForeground];</span><br><span class="line">    <span class="comment">//点击取消，没有任何操作</span></span><br><span class="line">UNNotificationAction *action3 = [UNNotificationAction actionWithIdentifier:<span class="string">@"cancelAction"</span> title:<span class="string">@"取消"</span> options:UNNotificationActionOptionDestructive];</span><br><span class="line">    <span class="comment">//通过UNNotificationCategory对象将这几个action行为添加到通知里去</span></span><br><span class="line">UNNotificationCategory *categroy = [UNNotificationCategory categoryWithIdentifier:<span class="string">@"Categroy"</span> actions:@[action1,action2,action3] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction];</span><br><span class="line">    <span class="comment">//将categroy赋值到通知内容上</span></span><br><span class="line">    content.categoryIdentifier = <span class="string">@"Categroy"</span>;</span><br><span class="line">    <span class="comment">//设置通知代理，用于检测点击方法</span></span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] setDelegate:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">/* add request and notificaiton code ... */</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-b7497931a422eb7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notificaiotn04.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-98dad809d88ab0e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification05.png"></p>
<p>获取通知交互内容：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//识别通知交互处理的代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(<span class="keyword">void</span> (^)())completionHandler&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *categoryIdentifier = response.notification.request.content.categoryIdentifier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([categoryIdentifier isEqualToString:<span class="string">@"Categroy"</span>]) &#123;</span><br><span class="line">        <span class="comment">//识别需要被处理的拓展</span></span><br><span class="line">        <span class="keyword">if</span> ([response.actionIdentifier isEqualToString:<span class="string">@"replyAction"</span>])&#123;</span><br><span class="line">            <span class="comment">//识别用户点击的是哪个 action</span></span><br><span class="line">            UNTextInputNotificationResponse *textResponse = (UNTextInputNotificationResponse*)response;</span><br><span class="line">            <span class="comment">//获取输入内容</span></span><br><span class="line">            <span class="built_in">NSString</span> *userText = textResponse.userText;</span><br><span class="line">            <span class="comment">//发送 userText 给需要接收的方法</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"要发送的内容是：%@"</span>,userText);</span><br><span class="line">            <span class="comment">//[ClassName handleUserText: userText];</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>([response.actionIdentifier isEqualToString:<span class="string">@"enterAction"</span>])&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"点击了进入应用按钮"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"点击了取消"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此我们可以知道action，categroy，request这些东西都是通过各自的identifier获取的。这样可以很方便的定位到某一个通知或者action上，为交互的处理提供了很大的便利。<br>##自定义通知样式<br>在Xcode中File-&gt;New-&gt;Targe会出现下面的视图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-ea496e4072fdc52f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification06.png"><br>Notification Content对应的是通知，Notification Service Extension对应的是推送。我们这里要实现通知的自定义，选择左边那个。创建成功之后会在工程里多一个文件件<br><img src="http://upload-images.jianshu.io/upload_images/1059465-5881abd4c65e5d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification07.png"><br>NotificationViewController文件是自动生成的，里面有一个<br><code>- (void)didReceiveNotification:(UNNotification *)notification</code><br>可以在这里定义一些通知的显示。</p>
<p>MainInterface.storyboard文件是控制通知的storyboard文件，可以编辑需要的通知样式。我们设计一下文字的颜色和显示位置</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-296bf320ce219e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notificaiton08.png"></p>
<p>接下来你可能会问，怎么把这个自定义的通知样式应用到当前通知里呢？先别急，我们看下一个文件Info.flist里面的内容</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-46dfa08e664a7a3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification09.png"></p>
<p>第一项<code>UNNotificationExtensionCategory</code>就是UNNotificationCategory的标示，我们把他换成我们通知里使用的标示<code>&quot;Category&quot;</code>，系统就会自动匹配通知显示的样式。<br>第二项<code>UNNotificationExtensionIntialContentSizeRation</code>初始内容 Size 的比例。也可以在 viewDidLoad 中使用 self.preferredContentSize 直接设置 Size。<br>第三项<code>UNNotificationExtensionDefaultContentHidden</code>是否隐藏默认内容，如果设为YES，默认内容会被隐藏。<br>显示的效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1059465-b1dd1a73d6c21873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="notification10.png"></p>
<p>##总结<br>至此，iOS通知部分的内容就学完了，参考代码：<a href="https://github.com/zhangferry/UserNotificaitonDemo">Demo</a>。<br>参考文档：<br><a href="http://maquannene.github.io/2016/06/27/iOS10%20UserNotifications%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">iOS10 User Notificaitons学习笔记</a><br><a href="https://onevcat.com/2016/08/notification/">活久见的重构-iOS10 UserNotificaiotns框架解析</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中实现JS和OC的交互(Hybrid App)</title>
    <url>/2016/08/18/ios-hybrid-app/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1059465-475ece93e7990cbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hybrid.png"></p>
<p>在项目开发中，我们常常遇到这种情况，一个功能性界面需要分享到其他平台，或者是一个较复杂，原生框架不易实现，需要经常变动的界面，处理这种功能，最优的处理办法就是交给H5来完成了。像这种介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”的应用就被成为<code>Hybrid App</code>。</p>
<a id="more"></a>
<p>在iOS端涉及的知识就是JS和OC之间的交互，下面我们逐步学习如何处理这两者交互的问题。<br>##目录</p>
<blockquote>
<ul>
<li>使用JavaScriptCore与JS交互</li>
</ul>
</blockquote>
<ul>
<li>JavaScriptCore了解</li>
<li>获取JS点击事件（JS调用OC）</li>
<li>OC调用JS方法  <ul>
<li>使用WebViewJavascriptBridge与JS交互</li>
</ul>
</li>
<li>引入WebViewJavascriptBridge</li>
<li>JS调用OC</li>
<li>OC调用JS</li>
</ul>
<p>##使用JavaScriptCore与JS交互<br>###JavaScriptCore了解<br>JavaScript和OC交互常用的框架就是这个了，首先我们了解几个概念：</p>
<ul>
<li>JSValue: 代表一个JavaScript实体，一个JSValue可以表示很多JavaScript原始类型例如boolean, integers, doubles，甚至包括对象和函数。</li>
<li>JSContext: 代表JavaScript的运行环境，你需要用JSContext来执行JavaScript代码。所有的JSValue都是捆绑在一个JSContext上的。</li>
<li>JSExport: 这是一个协议，可以用这个协议来将原生对象导出给JavaScript，这样原生对象的属性或方法就成为了JavaScript的属性或方法，非常神奇。<br><a href="http://nshipster.cn/javascriptcore">JavaScriptCore了解</a></li>
</ul>
<p>###网页内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 20px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>JavaSript与OC交互<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Native传值"</span> <span class="attr">onclick</span>=<span class="string">"Native.call('Native调用')"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"传值测试"</span> <span class="attr">onclick</span>=<span class="string">"passValue('test')"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> alertShow = <span class="function"><span class="keyword">function</span><span class="params">(str)</span></span></span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">        alert(str);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>HTML运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/1059465-cc53a2d8dd514f16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screen shot.png"></p>
<p>###获取JS点击事件</p>
<p>我们目的是获取点击方法</p>
<p><strong>第一步</strong><br>导入JavaScriptCore</p>
<pre><code>#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</code></pre><p><strong>第二步</strong><br>加载HTML文件</p>
<pre><code>NSString* path = [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot;];
NSURL* url = [NSURL fileURLWithPath:path];
NSURLRequest* request = [NSURLRequest requestWithURL:url] ;
[self.webView loadRequest:request];</code></pre><p><strong>第三步</strong><br>获取当前页面JSContxt对象   </p>
<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView {
self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];
//捕捉异常回调
self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {
    context.exception = exceptionValue;
    NSLog(@&quot;异常信息：%@&quot;, exceptionValue);
};
}</code></pre><p><strong>第四步</strong><br>获取点击事件<br> 有两种添加点击事件的方式</p>
<ul>
<li>直接调用的函数</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"传值测试"</span> <span class="attr">onclick</span>=<span class="string">"passValue('test')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是第一种情况，比较简单。在代理<code>- (void)webViewDidFinishLoad:(UIWebView *)webView</code> 中加上</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.context[<span class="string">@"passValue"</span>] = ^(<span class="built_in">NSString</span> *str)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果点击传值按钮，就会调用此block，输出<code>test</code></p>
<ul>
<li>第二种：通过native调用的方式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Native传值"</span> <span class="attr">onclick</span>=<span class="string">"Native.call('Native调用')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  这种方式需要声明一个JSExport的协议，协议中声明供JS使用的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JSObjcDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)call:(<span class="built_in">NSString</span> *)str;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>然后还要以JSExport协议关联Native方法，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.content[<span class="string">@"Native"</span>] = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure>
<p>在实现文件中实现这个方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)call:(<span class="built_in">NSString</span> *)str&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"call"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时点击一下Native传值，就会输出<code>Native调用</code><br>还有一个需要注意的地方是，在JS调用的方法里实现页面跳转时，要回到主线程执行。可以使用GCD方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>至此，获取JS点击事件的功能就完成了。</p>
<p>###OC调用JS方法<br>在上面那段HTML里有一个函数<code>alertShow()</code>，是调用弹框并将<code>str</code>值显示出来。那么我们如何调用这个方法呢？<br>第一步、获取这个函数，有两种方法</p>
<pre><code>JSValue *Callback = self.context[@&quot;alertShow&quot;];//第一种方式
JSValue *Callback = [self.context objectForKeyedSubscript:@&quot;alertShow&quot;];//第二种方式</code></pre><p>第二步、向JS传参</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[Callback callWithArguments:@[<span class="string">@"OC调用JS方法"</span>]];<span class="comment">//出现一个弹框，`OC调用JS方法`</span></span><br></pre></td></tr></table></figure>
<p>如果想直接使用JS的方法可以</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"alert('OC添加JS提示成功')"</span>;</span><br><span class="line">[<span class="keyword">self</span>.context evaluateScript:str];</span><br></pre></td></tr></table></figure>

<p>###加载新的URL<br>WebView有一个代理方法，每当需要去加载一个request，就会回调这个方法，让上层决定是否加载。常常一个H5页面会进行不同url之间的跳转，这里截获，进行本地处理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *url = request.URL.absoluteString;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"____%@"</span>,url);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(![<span class="keyword">self</span> isNetwork])&#123;</span><br><span class="line">     <span class="comment">//无网情况的一个处理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>([url hasSuffix:<span class="string">@"ios/test"</span>])&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//do something you want return NO;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##使用WebViewJavascriptBridge与JS交互<br><a href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a>是一个轻量的用于OC与JS交互的第三方库，使用它可以用CocoaPods导入：<br><code>pod &#39;WebViewJavascriptBridge&#39;, &#39;~&gt; 5.0&#39;</code><br>也可以在Github上下载示例工程，将工程文件<code>WebViewJavascriptBridge</code>拖入自己项目中。本节主要介绍使用方法，关于实现原理网上介绍也比较多，感兴趣的同学可以自行了解。</p>
<p><strong>引入WebViewJavascriptBridge</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置能够进行桥接</span></span><br><span class="line">[WebViewJavascriptBridge enableLogging];</span><br><span class="line"><span class="comment">//注册handler在Object-C，如果有self.webView.delegate = self。应注释掉，否则注册方法不执行</span></span><br><span class="line"><span class="keyword">self</span>.bridge = [WebViewJavascriptBridge bridgeForWebView:<span class="keyword">self</span>.webView];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想执行UIWebView的代理方法，需设置</span></span><br><span class="line">[<span class="keyword">self</span>.bridge setWebViewDelegate:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>
<p><strong>JS调用OC</strong><br>JS调用原生方法<code>getUsername</code>，可以使用如下方式注册。JS需要返回值的可以用responseCallback将返回值传过去</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.bridge registerHandler:<span class="string">@"getUsername"</span> handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,data);</span><br><span class="line">    responseCallback([<span class="keyword">self</span> getUsername]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>OC调用JS</strong><br>OC调用JS可以使用如下方法实现，如果需要传参，可以写到参数<code>data:</code>里，如果没有参数就传<code>nil</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OC调JS的方法</span></span><br><span class="line">[<span class="keyword">self</span>.bridge callHandler:<span class="string">@"testJavascriptHandler"</span> data:<span class="literal">nil</span> responseCallback:^(<span class="keyword">id</span> responseData) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ObjC received response: %@"</span>, responseData);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<hr>
<p>常见的处理JS与OC之间交互的问题，基本就这些了。希望对大家有所帮助，Demo在这里<a href="https://github.com/zhangferry/JavaScript-OC">传送门</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝牙固件升级</title>
    <url>/2016/03/10/bluetooth-ota-upgrade/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1059465-3f9893059e8e70ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bluetooth.png"><br>###升级介绍</p>
<blockquote>
<p>蓝牙固件升级是使用手机给固件进行更新，以达到修复bug，完善功能的作用。升级的大概流程是：首先，当手环的固件需要升级时，由嵌入式开发人员提供新的固件，由服务器管理人员将固件放到服务器上，此时，用户打开手机APP的时候会检测到服务器有更新，请求更新手环固件，确认更新后，手机会从服务器下载固件。下载完毕后，APP会读取固件内容，并根据升级协议将内容传到手环里，完成升级。  </p>
</blockquote>
<ul>
<li>DFU =  Device Firmware Update （设备固件更新）</li>
<li>OTA = Over The Air （空中升级）<a id="more"></a>
###升级流程<br>各个蓝牙设备不尽相同，以下是我测试设备的升级流程：<br>######OTA下载固件<br>从云端下载的固件为.bin后缀的文件，文件名会有一定的格式，含有固件版本号和文件CRC32校验值。<br>######数据分块<br>规定一个数据块大小比如2048字节，然后把升级数据进行分块，不够的就剩余多少作为一块。蓝牙一次发送的数据量是有限的，所以每次发送20字节的数据。这个数据要遵循升级数据格式，带指令头和校验和，下载包的数据只是这20字节中的一部分。所有包内数据都携带在每条升级数据指令中。<br>######升级过程<ul>
<li>连接设备，发送升级请求。</li>
<li>待蓝牙确认之后，开始发送数据头告知蓝牙此次发送的数据量和CRC校验。</li>
<li>开始发送升级数据。（每条数据之间间隔20ms为了蓝牙能够方便处理）</li>
<li>待一个块发送完就发送块结束命令</li>
<li>蓝牙确认发送下一个块，返回错误则终止此次升级</li>
<li>发完所有数据之后发送升级完成</li>
<li>蓝牙确认则升级完成，返回错误则升级失败</li>
</ul>
</li>
</ul>
<p>######流程图<br><img src="http://upload-images.jianshu.io/upload_images/1059465-fe149f35edab6e56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="upgrade.png"><br>###总结<br>蓝牙升级最复杂的就在升级过程，大量的数据与蓝牙交互，这时最好记录发送到升级数据的那一部分，可以给用户展示升级的进程。</p>
]]></content>
      <categories>
        <category>蓝牙总结</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
</search>
